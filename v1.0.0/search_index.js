var documenterSearchIndex = {"docs":
[{"location":"manual/#Calculators","page":"Basics","title":"Calculators","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"Typically, when calculating special functions, we will use recurrence relations along with some coefficients ‚Äî which frequently requires significant setup processing.  That processing can be cached, so that the calculations themselves consist primarily of memory accesses and simple arithmetic.  For this reason, we use \"calculator\" objects, which will be constructed with some indication of the largest indices you expect to use.  The calculators can then be called repeatedly for specific values of the arguments, which will compute the function values for all (or some subset of) indices.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [SphericalFunctions.AssociatedLegendreFunction]\nPages   = [\"src/associated_legendre/calculator.jl\"]","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [SphericalFunctions]\nPages   = [\"wigner_matrices/calculator.jl\", \"wigner_matrices/evaluate.jl\"]","category":"page"},{"location":"manual/#SphericalFunctions.D!-Tuple{Any, Quaternionic.AbstractQuaternion, Any, Any, Any, Any}","page":"Basics","title":"SphericalFunctions.D!","text":"D!(ùîá, R, ‚Ñì‚Çò‚Çê‚Çì, (a‚Çô·µê,b‚Çô·µê,d‚Çô·µê), expimŒ±, expimŒ≥)\n\nCompute Wigner's ùîá matrix\n\nThis function implements the preferred method of computing the ùîá matrix for large ell values.  In particular, above ell‚âà32 standard formulas become completely unusable because of numerical instabilities and overflow.  This function uses stable recursion methods instead, and should be usable beyond ell‚âà1000.\n\nThis function computes ùîáÀ°‚Çò‚Çö,‚Çò(R).  The result is returned in a 1-dimensional array ordered as\n\n[\n    ùîá(ell, mp, m, R)\n    for ell in range(ell_max+1)\n    for mp in range(-min(‚Ñì, mp_max), min(‚Ñì, mp_max)+1)\n    for m in range(-ell, ell+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.Y!","page":"Basics","title":"SphericalFunctions.Y!","text":"Y(s, R, ‚Ñì‚Çò‚Çê‚Çì)\nY!(Y, s, R, ‚Ñì‚Çò‚Çê‚Çì)\n\nEvaluate (and write into Y, if present) the values of _sY_ell m(R) for the input value of s, for all (ell m) throughout the range specified by wigner.  R is assumed to be a unit quaternion (which may be Rotor, or simply a Quaternion).  If R does not have unit magnitude, the output elements will be too large by a factor R^ell.  If Y is not present, a new array will be created.\n\nThe spherical harmonics of spin weight s are related to Wigner's mathfrakD matrix as\n\nbeginaligned\n_sY_ell m(R)\n  = (-1)^s sqrtfrac2ell+14pi mathfrakD^(ell)_m -s(R) \n  = (-1)^s sqrtfrac2ell+14pi barmathfrakD^(ell)_-s m(barR)\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"manual/#SphericalFunctions.Yprep-Union{Tuple{T}, Tuple{Any, Any, Type{T}}, Tuple{Any, Any, Type{T}, Any}} where T<:Real","page":"Basics","title":"SphericalFunctions.Yprep","text":"Yprep(‚Ñì‚Çò‚Çê‚Çì, s‚Çò‚Çê‚Çì, T, ‚Ñì‚Çò·µ¢‚Çô)\n\nPrepare the storage, recursion coefficients, and workspace to compute ‚ÇõY‚Çó,‚Çò data up to the maximum sizes given.\n\nReturns a tuple of Y, H_rec_coeffs, Hwedge, expimœï, which can be passed to the correspondingly named arguments of Y!.\n\nNote that the same results of this function can be passed to Y!, even if the value of ‚Ñì‚Çò‚Çê‚Çì passed to that function is smaller than the value passed to this function, or the value of spin passed to that function is smaller (in absolute value) than the s‚Çò‚Çê‚Çì passed to this function.  However, the value of ‚Ñì‚Çò·µ¢‚Çô passed to that function must not be smaller than the value passed to this function (unless one of the other sizes is sufficiently smaller).\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.d!-Tuple{Any, Complex, Any, Any}","page":"Basics","title":"SphericalFunctions.d!","text":"d!(d, expiŒ≤, ‚Ñì‚Çò‚Çê‚Çì, H_rec_coeffs)\nd!(d, expiŒ≤, ‚Ñì‚Çò‚Çê‚Çì)\nd!(d, Œ≤, ‚Ñì‚Çò‚Çê‚Çì, H_rec_coeffs)\nd!(d, Œ≤, ‚Ñì‚Çò‚Çê‚Çì)\n\nCompute Wigner's d matrix dÀ°‚Çò‚Çö,‚Çò(Œ≤)\n\nNotes\n\nThis function is the preferred method of computing the d matrix for large ell values.  In particular, above ell‚âà32 standard formulas become completely unusable because of numerical instabilities and overflow.  This function uses stable recursion methods instead, and should be usable beyond ell‚âà1000.\n\nThe result is returned in a 1-dimensional array ordered as\n\n[\n    d(ell, mp, m, Œ≤)\n    for ell in range(ell_max+1)\n    for mp in range(-min(‚Ñì, mp_max), min(‚Ñì, mp_max)+1)\n    for m in range(-ell, ell+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"manual/#Transformation","page":"Basics","title":"Transformation","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [SphericalFunctions]\nPages   = [\"map2salm.jl\"]","category":"page"},{"location":"manual/#SphericalFunctions.map2salm!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, Int64, Int64, Any}} where T<:Real","page":"Basics","title":"SphericalFunctions.map2salm!","text":"map2salm!(salm, map, spin, ‚Ñìmax)\nmap2salm!(salm, map, plan)\n\nTransform map values sampled on the sphere to _sa_ell m modes in place.\n\nFor details, see map2salm.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, Int64, Int64, Any}} where T<:Real","page":"Basics","title":"SphericalFunctions.map2salm","text":"map2salm(map, spin, ‚Ñìmax)\nmap2salm(map, plan)\n\nTransform map values sampled on the sphere to _sa_ell m modes.\n\nThe map array should have size NœÜ along its first dimension and Nœë along its second; any number of dimensions may follow.  The spin must be entered explicitly, and ‚Ñìmax is the highest ‚Ñì value you want in the output.\n\nFor repeated applications of this function with different values of map, it is more efficient to pre-compute plan using plan_map2salm.  These functions will create a new salm array on each call.  To operate in place on a pre-allocated salm array, use map2salm!.\n\nThe core of this function follows the method described by Reinecke and Seljebotn.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.plan_map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, Int64, Int64}} where T<:Real","page":"Basics","title":"SphericalFunctions.plan_map2salm","text":"plan_map2salm(map, spin, ‚Ñìmax)\n\nPrecompute values to use in executing map2salm or map2salm!.\n\nThe arguments to this function exactly mirror those of the first form of map2salm, and all but the first argument in the first form of map2salm!.  The plan returned by this function can be passed to the second forms of those functions to avoid some computation and allocation costs.\n\nNote that the plan object is not thread safe; a separate plan should be created for each thread that will use one, or locks should be used to ensure that a single plan is not used at the same time on different threads.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"While not usually the star of the show, the following utilities can be quite helpful for actually using the rest of the code.","category":"page"},{"location":"utilities/#Complex-powers","page":"Utilities","title":"Complex powers","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"One common task we find when working with spherical functions is the computation of a range of integer powers of some complex number ‚Äî so much so that it can be best to pre-compute the powers and cache their values.  While a naive approach is generally quite accurate, and reasonably fast, we can do a little better with a specialized routine.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"complex_powers.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#SphericalFunctions.complex_powers!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 1}, Complex{T}}} where T<:Real","page":"Utilities","title":"SphericalFunctions.complex_powers!","text":"complex_powers!(zpowers, z)\n\nCompute integer powers of z from z^0 through z^m, recursively, where m is one less than the length of the input zpowers vector.\n\nNote that z is assumed to be normalized, with complex amplitude approximately 1.\n\nSee also: complex_powers\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.complex_powers-Union{Tuple{T}, Tuple{Complex{T}, Int64}} where T<:Real","page":"Utilities","title":"SphericalFunctions.complex_powers","text":"complex_powers(z, m)\n\nCompute integer powers of z from z^0 through z^m, recursively.\n\nNote that z is assumed to be normalized, with complex amplitude approximately 1.\n\nThis algorithm is mostly due to Stoer and Bulirsch in \"Introduction to Numerical Analysis\" (page 24) ‚Äî with a little help from de Moivre's formula, which is essentially exp(iŒ∏)‚Åø = exp(inŒ∏), as well as my own alterations to deal with different behaviors in different quadrants.\n\nThere isn't usually a huge advantage to using this specialized function.  If you just need a particular power, it will generally be far more efficient and just as accurate to compute either exp(iŒ∏)‚Åø or exp(inŒ∏) explicitly.  However, if you need all powers from 0 to m, this function is about 10 or 5 times faster than those options, respectively, for large m.  Like those options, this function is numerically stable, in the sense that its errors are usually smaller than m times the error from machine-precision errors in the input argument ‚Äî or at worst about 50% larger, which occurs as the phase approaches multiples of œÄ/2.\n\nSee also: complex_powers!\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Quadrature-weights","page":"Utilities","title":"Quadrature weights","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"weights.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#SphericalFunctions.clenshaw_curtis-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"Utilities","title":"SphericalFunctions.clenshaw_curtis","text":"clenshaw_curtis(n, [T])\n\nCompute n weights for the Clenshaw-Curtis rule, corresponding to n evenly spaced nodes from 0 to œÄ inclusive.  That is, the nodes are located at\n\ntheta_k = k fracpin-1 quad k=0 ldots n-1\n\nThis function uses Waldvogel's method.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.fejer1-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"Utilities","title":"SphericalFunctions.fejer1","text":"fejer1(n, [T])\n\nCompute n weights for Fej√©r's first rule, corresponding to n evenly spaced nodes from 0 to œÄ inclusive.  That is, the nodes are located at\n\ntheta_k = k fracpin-1 quad k=0 ldots n-1\n\nThis function uses Waldvogel's method.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.fejer2-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"Utilities","title":"SphericalFunctions.fejer2","text":"fejer2(n, [T])\n\nCompute n weights for Fej√©r's second rule, corresponding to n evenly spaced nodes between 0 and œÄ exclusive.  That is, the nodes are located at\n\ntheta_k = k fracpin+1 quad k=1 ldots n\n\nThis function uses Waldvogel's method.  However, contrary to Waldvogel's notation, this routine does not include the weight corresponding to the œë=0 or œÄ nodes, which both have weight 0.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Y-and-D-data","page":"Utilities","title":"Y and D data","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"By Y data, we mean anything indexed like Y_ell m modes; by D data, we mean anything indexed like Wigner's mathfrakD matrices, or special subsets of them, like the H matrices.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"indexing.jl\", \"wigner_matrices/indexing.jl\", \"wigner_matrices/Hrecursions.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#SphericalFunctions.WignerDindex","page":"Utilities","title":"SphericalFunctions.WignerDindex","text":"WignerDindex(‚Ñì, m‚Ä≤, m, m‚Ä≤‚Çò‚Çê‚Çì=‚Ñì)\n\nCompute index into Wigner ùîá matrix\n\nParameters\n\n‚Ñì : int     Integer satisfying ‚Ñì‚Çò·µ¢‚Çô <= ‚Ñì <= ‚Ñì‚Çò‚Çê‚Çì m‚Ä≤ : int     Integer satisfying -min(‚Ñì‚Çò‚Çê‚Çì, m‚Ä≤‚Çò‚Çê‚Çì) <= m‚Ä≤ <= min(‚Ñì‚Çò‚Çê‚Çì, m‚Ä≤‚Çò‚Çê‚Çì) m : int     Integer satisfying -‚Ñì <= m <= ‚Ñì ‚Ñì‚Çò·µ¢‚Çô : int, optional     Integer satisfying 0 <= ‚Ñì‚Çò·µ¢‚Çô <= ‚Ñì‚Çò‚Çê‚Çì.  Defaults to 0. m‚Ä≤‚Çò‚Çê‚Çì : int, optional     Integer satisfying 0 <= m‚Ä≤‚Çò‚Çê‚Çì.  Defaults to ‚Ñì.\n\nReturns\n\ni : int     Index into Wigner ùîá matrix arranged as described below\n\nSee Also\n\nWignerDsize : Total size of the ùîá matrix WignerDrange : Array of (‚Ñì, m', m) indices corresponding to the ùîá matrix\n\nNotes\n\nThis assumes that the Wigner ùîá matrix is arranged as\n\n[\n    ùîá(‚Ñì, m‚Ä≤, m)\n    for ‚Ñì in range(‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì+1)\n    for m‚Ä≤ in range(-min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì), min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì)+1)\n    for m in range(-‚Ñì, ‚Ñì+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerDrange","page":"Utilities","title":"SphericalFunctions.WignerDrange","text":"WignerDrange(‚Ñì‚Çò‚Çê‚Çì, m‚Ä≤‚Çò‚Çê‚Çì=‚Ñì‚Çò‚Çê‚Çì)\n\nCreate an array of (‚Ñì, m', m) indices as in ùîá array\n\nParameters\n\n‚Ñì‚Çò·µ¢‚Çô : int     Integer satisfying 0 <= ‚Ñì‚Çò·µ¢‚Çô <= ‚Ñì‚Çò‚Çê‚Çì m‚Ä≤‚Çò‚Çê‚Çì : int, optional     Integer satisfying 0 <= m‚Ä≤‚Çò‚Çê‚Çì.  Default is ‚Ñì‚Çò‚Çê‚Çì. ‚Ñì‚Çò‚Çê‚Çì : int     Integer satisfying 0 <= ‚Ñì‚Çò·µ¢‚Çô <= ‚Ñì‚Çò‚Çê‚Çì\n\nSee Also\n\nWignerDsize : Total size of ùîá array WignerDindex : Index inside these wedges\n\nNotes\n\nThis assumes that the Wigner ùîá matrix is arranged as\n\n[\n    ùîá(‚Ñì, m‚Ä≤, m)\n    for ‚Ñì in range(‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì+1)\n    for m‚Ä≤ in range(-min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì), min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì)+1)\n    for m in range(-‚Ñì, ‚Ñì+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerDsize-Tuple{Any}","page":"Utilities","title":"SphericalFunctions.WignerDsize","text":"WignerDsize(‚Ñì‚Çò‚Çê‚Çì, m‚Ä≤‚Çò‚Çê‚Çì=‚Ñì‚Çò‚Çê‚Çì)\n\nCompute total size of Wigner ùîá matrix\n\nSee also 'WignerDrange` and WignerDindex.\n\nNotes\n\nThis assumes that the Wigner ùîá matrix is arranged as\n\n[\n    ùîá(‚Ñì, m‚Ä≤, m)\n    for ‚Ñì in ‚Ñì‚Çò·µ¢‚Çô:‚Ñì‚Çò‚Çê‚Çì\n    for m‚Ä≤ in -min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì):min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì)\n    for m in -‚Ñì:‚Ñì\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.WignerHindex","page":"Utilities","title":"SphericalFunctions.WignerHindex","text":"WignerHindex(‚Ñì, m‚Ä≤, m, m‚Ä≤‚Çò‚Çê‚Çì)\n\nIndex to \"wedge\" arrays\n\nParameters\n\n‚Ñì : int m‚Ä≤ : int m : int m‚Ä≤‚Çò‚Çê‚Çì : int, optional     If nothing, it is assumed to be at least ‚Ñì\n\nSee Also\n\nWignerHsize : Total size of wedge array WignerHrange : Array of (‚Ñì, m', m) indices corresponding to this wedge\n\nNotes\n\nHere, it is assumed that only data with m‚â•|m'| are stored, and only corresponding values are passed.  We also assume |m|‚â§‚Ñì and |m'|‚â§‚Ñì.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(‚Ñì, m‚Ä≤, m) for ‚Ñì in range(‚Ñì‚Çò‚Çê‚Çì+1)\n    for m‚Ä≤ in range(-min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì), min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì)+1)\n    for m in range(abs(m‚Ä≤), ‚Ñì+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerHrange","page":"Utilities","title":"SphericalFunctions.WignerHrange","text":"WignerHrange(‚Ñì‚Çò‚Çê‚Çì, m‚Ä≤‚Çò‚Çê‚Çì=‚Ñì‚Çò‚Çê‚Çì)\n\nCreate an array of (‚Ñì, m', m) indices as in H array\n\nSee also 'WignerHsize` and WignerHindex\n\nNotes\n\nHere, it is assumed that only data with m‚â•|m'| are stored, and only corresponding values are passed.  We also assume |m|‚â§‚Ñì and |m'|‚â§‚Ñì.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(‚Ñì, m‚Ä≤, m) for ‚Ñì in range(‚Ñì‚Çò‚Çê‚Çì+1)\n    for m‚Ä≤ in range(-min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì), min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì)+1)\n    for m in range(abs(m‚Ä≤), ‚Ñì+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerHsize-Tuple{Any}","page":"Utilities","title":"SphericalFunctions.WignerHsize","text":"WignerHsize(‚Ñì‚Çò‚Çê‚Çì, m‚Ä≤‚Çò‚Çê‚Çì=‚Ñì‚Çò‚Çê‚Çì)\n\nTotal size of array of wedges of width m‚Ä≤‚Çò‚Çê‚Çì up to ‚Ñì‚Çò‚Çê‚Çì.  If m‚Ä≤‚Çò‚Çê‚Çì is not given, it defaults to ‚Ñì‚Çò‚Çê‚Çì.\n\nSee also 'WignerHrange` and WignerHindex.\n\nNotes\n\nHere, it is assumed that only data with m‚â•|m‚Ä≤| are stored, and only corresponding values are passed.  We also assume |m|‚â§‚Ñì and |m‚Ä≤|‚â§‚Ñì.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(‚Ñì, m‚Ä≤, m) for ‚Ñì in 0:‚Ñì‚Çò‚Çê‚Çì\n    for m‚Ä≤ in -min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì):min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì)\n    for m in abs(m‚Ä≤):‚Ñì\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.Yindex","page":"Utilities","title":"SphericalFunctions.Yindex","text":"Yindex(‚Ñì, m, ‚Ñì‚Çò·µ¢‚Çô=0)\n\nCompute index into array of mode weights\n\nParameters\n\n‚Ñì : int     Integer satisfying ‚Ñì‚Çò·µ¢‚Çô <= ‚Ñì <= ‚Ñì‚Çò‚Çê‚Çì m : int     Integer satisfying -‚Ñì <= m <= ‚Ñì ‚Ñì‚Çò·µ¢‚Çô : int, optional     Integer satisfying 0 <= ‚Ñì‚Çò·µ¢‚Çô.  Defaults to 0.\n\nReturns\n\ni : int     Index of a particular element of the mode-weight array as described below\n\nSee Also\n\nYsize : Total size of array of mode weights Yrange : Array of (‚Ñì, m) indices corresponding to this array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ‚Ñì, m)\n    for ‚Ñì in range(‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì+1)\n    for m in range(-‚Ñì, ‚Ñì+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.Yrange-Tuple{Any}","page":"Utilities","title":"SphericalFunctions.Yrange","text":"Yrange(‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì)\n\nCreate an array of (‚Ñì, m) indices as in Y array\n\nParameters\n\n‚Ñì‚Çò·µ¢‚Çô : int     Integer satisfying 0 <= ‚Ñì‚Çò·µ¢‚Çô <= ‚Ñì‚Çò‚Çê‚Çì ‚Ñì‚Çò‚Çê‚Çì : int     Integer satisfying 0 <= ‚Ñì‚Çò·µ¢‚Çô <= ‚Ñì‚Çò‚Çê‚Çì\n\nReturns\n\ni : int     Total size of array of mode weights arranged as described below\n\nSee Also\n\nYsize : Total size of array of mode weights Yindex : Index of a particular element of the mode weight array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ‚Ñì, m)\n    for ‚Ñì in range(‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì+1)\n    for m in range(-‚Ñì, ‚Ñì+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.Ysize-Tuple{Any}","page":"Utilities","title":"SphericalFunctions.Ysize","text":"Ysize(‚Ñì‚Çò‚Çê‚Çì)\n\nCompute total size of array of mode weights\n\nSee Also\n\nYrange : Array of (‚Ñì, m) indices corresponding to this array Yindex : Index of a particular element of the mode weight array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ‚Ñì, m)\n    for ‚Ñì in range(‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì+1)\n    for m in range(-‚Ñì, ‚Ñì+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions._WignerHindex-NTuple{4, Any}","page":"Utilities","title":"SphericalFunctions._WignerHindex","text":"Helper function for WignerHindex\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.deduce_limits","page":"Utilities","title":"SphericalFunctions.deduce_limits","text":"deduce_limits(ysize, [‚Ñìmin])\n\nDeduce the value of (‚Ñìmin, ‚Ñìmax) that produces Y arrays of the given size.\n\nIf ‚Ñìmin is not given, it is assumed to be 0.  If it is set to nothing, the smallest possible value of ‚Ñìmin will be used.  However, note that this is not a well-posed problem; multiple combinations of (‚Ñìmin, ‚Ñìmax) can give rise to Y arrays of the same size.\n\nSee also Ysize\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.phi_theta-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"Utilities","title":"SphericalFunctions.phi_theta","text":"phi_theta(Nœï, NŒ∏, [T=Float64])\n\nConstruct (phi, theta) grid in order expected by this package.\n\nSee also theta_phi for the opposite ordering.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.theta_phi-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"Utilities","title":"SphericalFunctions.theta_phi","text":"theta_phi(NŒ∏, Nœï, [T=Float64])\n\nConstruct (theta, phi) grid in spinsfast order.\n\nNote that this order is different from the one assumed by this package; use phi_theta for the opposite ordering.\n\n\n\n\n\n","category":"method"},{"location":"notes/H_recursions/#Algorithm-for-computing-H","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"The H array, as given by Gumerov and Duraiswami, is related to Wigner's (small) d matrices ‚Äî which is itself related to the (big) mathfrakD matrices and the various spin-weighted spherical harmonics _sY_ellm ‚Äî via","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"d_ell^mm = epsilon_m epsilon_-m H_ell^mm","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"where","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"epsilon_k =\n  begincases\n    1  kleq 0 \n    (-1)^k  k  0\n  endcases","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"H has various advantages over d, including the fact that it can be efficiently and robustly valculated via recurrence relations, and the following symmetry relations:","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  H^m m_n(Œ≤) = H^m m_n(Œ≤) \n  H^m m_n(Œ≤) = H^-m -m_n(Œ≤) \n  H^m m_n(Œ≤) = (-1)^n+m+m H^-m m_n(œÄ - Œ≤) \n  H^m m_n(Œ≤) = (-1)^m+m H^m m_n(-Œ≤)\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Because of these symmetries, we only need to evaluate at most 1/4 of all the elements.","category":"page"},{"location":"notes/H_recursions/#Steps-to-compute-H","page":"Algorithm for computing H","title":"Steps to compute H","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"The following describes various details that are not spelled out correctly by Gumerov and Duraiswami.  All equation numbers refer to that paper.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Because of the symmetries noted above, we only compute H^m m_n with m  m ‚Äî roughly one quarter of all possible values.  Furthermore, for computations of spin-weighted spherical harmonics of weight s, we only need to compute values with m  s, which constitutes a dramatic savings when s  ‚Ñì‚Çò‚Çê‚Çì.  The data are stored in the array Hwedge.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"However, some parts of this calculation require calculating terms with m=n+1 ‚Äî whereas such elements of d and mathfrakD are considered zero.  For this purpose, we need additional storage.  Rather than allocating extra space, or requiring some additional workspace to be passed in, we can actually use parts of the input H data space for temporary storage while these extra terms are needed, which is before those parts of the storage are needed.  Specifically, we need this additional storage for H^0 m_n_mathrmmax+1 with m in 0 n_mathrmmax+1, and we can use the storage destined for H^-1 m_n_mathrmmax with m in 1 n_mathrmmax.  But this leaves two more indices, which we just store as individual variables ‚Äî HŒ© and HŒ® ‚Äî representing the last and second-to-last of these additional elements stored.","category":"page"},{"location":"notes/H_recursions/#Step-1","page":"Algorithm for computing H","title":"Step 1","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Set H_0^00=1.","category":"page"},{"location":"notes/H_recursions/#Step-2","page":"Algorithm for computing H","title":"Step 2","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Compute values H^0m_n(Œ≤) for m=0ldotsn and H^0m_n+1(Œ≤) for m=0ldotsn+1.  Using Eq. (32), we see that within Gumerov and Duraiswami's conventions","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  H^0m_n(Œ≤) = (-1)^m sqrtfrac(n-m)(n+m) P^m_n(cos Œ≤) \n                 = frac1sqrtk_m (2n+1) P_nm(cos Œ≤)\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Here, k_0=1 and k_m=2 for m0, and P is defined as","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"  P_nm = sqrtfrack_m(2n+1)(n-m)(n+m) P_nm","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Note that the factor of (-1)^m in the first equation above is different from the convention used here, and is related to the Condon-Shortley phase. Note that Gumerov and Duraiswami use the notation P^m_n, whereas we are using the notation P_nm ‚Äî which usually differ by a factor of (-1)^m.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"We use the \"fully normalized\" associated Legendre functions (fnALF) P because, as explained by Xing et al. (2020), it is possible to compute these values very efficiently and accurately, while also delaying the onset of overflow and underflow.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"The algorithm Xing et al. describe as the best for computing P is due to Belikov (1991), and is given by them as","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  P_00 = 1 \n  P_10 = sqrt3 cos Œ≤ \n  P_11 = sqrt3 sin Œ≤ \n  P_n0 = a_n cos Œ≤ P_n-10 - b_n fracsin Œ≤2 P_n-11 \n  P_nm =\n    c_nm cos Œ≤ P_n-1m\n    - sin Œ≤ left d_nm P_n-1m+1 - e_nm P_n-1m-1 right\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"where the coefficients are given by","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  a_n = sqrtfrac2n+12n-1 \n  b_n = sqrtfrac2(n-1)(2n+1)n(2n-1) \n  c_nm = frac1n sqrtfrac(n+m)(n-m)(2n+1)2n-1 \n  d_nm = frac12n sqrtfrac(n-m)(n-m-1)(2n+1)2n-1 \n  e_nm = frac12n sqrtfrac22-delta_0^m-1 sqrtfrac(n+m)(n+m-1)(2n+1)2n-1\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Now, we can directly obtain a recurrence relation for H^0m_n = P_nm  sqrtk_m (2n+1) from those expressions:","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  H^00_0 = 1 \n  H^00_1 = cos Œ≤ \n  H^01_1 = sqrt12 sin Œ≤ \n  H^00_n = a_n cos Œ≤ H^00_n-1 - b_n sin Œ≤ H^01_n-1 \n  H^0m_n =\n    c_nm cos Œ≤ H^0m_n-1\n    - sin Œ≤ left d_nm H^0m+1_n-1 - e_nm H^0m-1_n-1 right\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"where the coefficients are given by","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  b_n = sqrtfracn-1n \n  c_nm = frac1n sqrt(n+m)*(n-m) \n  d_nm = frac12n sqrt(n-m)*(n-m-1) \n  e_nm = frac12n sqrt(n+m)*(n+m-1)\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Note that the coefficients all simplified (in fact, a_n disappeared), without any increase in the complexity of the recurrence relations themselves.  Rewriting Belikov's algorithm explicitly in terms of the H^0m_n also allows us to avoid an extra normalization step.","category":"page"},{"location":"notes/H_recursions/#Step-3","page":"Algorithm for computing H","title":"Step 3","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Compute H^1m_n(Œ≤) for m=1ldotsn using relation (41).  Symmetry and shift of the indices allow this relation to be written as","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"b^0_n+1 H^1 m_n\n  = fracb^m1_n+1 (1cos Œ≤)2 H^0 m+1_n+1\n   fracb^ m1_n+1 (1+cos Œ≤)2 H^0 m1_n+1\n   a^m_n sin Œ≤ H^0 m_n+1","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Here the constants are defined by","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"a^m_n = sqrtfrac(n+m+1)(n-m+1) (2n+1)(2n+3)","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"b^m_n = mathrmsgn(m) sqrtfrac(n-m-1)(n-m) (2n-1)(2n+1)","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Note that all values are assumed to be zero whenever m  n, we use mathrmsgn(0)=1 (unlike the common convention that mathrmsgn(0)=0), and we have a^m_n = a^-m_n.","category":"page"},{"location":"notes/H_recursions/#Step-4","page":"Algorithm for computing H","title":"Step 4","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Recursively compute H^m+1 m_n(Œ≤) for m=1ldotsn1, m=mn using relation (50) resolved with respect to H^m+1 m_n:","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"d^m_n H^m+1 m_n\n  = d^m1_n H^m1 m_n\n   d^m1_n H^m m1_n\n  + d^m_n H^m m+1_n","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"(where the last term drops out for m=n).  The constants are defined by","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"d^m_n = fracmathrmsgn(m)2 sqrt(n-m)(n+m+1)","category":"page"},{"location":"notes/H_recursions/#Step-5","page":"Algorithm for computing H","title":"Step 5","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Recursively compute H^m1 m_n(Œ≤) for m=1ldotsn+1, m=mldotsn using relation (50) resolved with respect to H^m1 m_n:","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"d^m1_n H^m1 m_n\n  = d^m_n H^m+1 m_n\n  + d^m1_n H^m m1_n\n   d^m_n H^m m+1_n","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"(where the last term drops out for m=n).","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"NOTE: Although Gumerov and Duraiswami specify the loop over m to start at -1, I find it necessary to start at 0, or there will be missing information. This also requires setting the H^0 -1_n components (for all n) before beginning this loop.","category":"page"},{"location":"notes/H_recursions/#Pre-computing-constants-versus-computing-on-the-fly","page":"Algorithm for computing H","title":"Pre-computing constants versus computing on the fly","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Each of the constants a^m_n, b^m_n, and c^m_n involves divisions and square-roots, which can be very costly to compute.  It can be advantageous to pre-compute the constants, and simply index the pre-computed arrays rather than re-computing them on each recursion.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"If we include the cost of computing all these constants in a single call to the H recurrence, it can be much cheaper to compute each constant as needed within the algorithm, rather than computing them all at once at the beginning of the algorithm ‚Äî but only for very small computations, such as those involving n_mathrmmax  10.  Beyond this, despite the storage penalties for all those constants, it turns out to be better to pre-compute them.  However, it should be noted that the fractional cost of storing the constants is sim 3n_mathrmmax compared to just storing H itself, so this will never be a very significant amount of space.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"On the other hand, if we can pre-compute the constants just once, and store them between multiple calls to the H recurrence, then it is always advantageous to do so ‚Äî typically by factors of 2 or 3 in speed.  The only difficulty here is ensuring that each call to the recurrence has access to the constants, which can be a little awkward when using multiple processes and/or threads.  However, it should be thread safe, since we only need to read those constants within the H recurrence.  All in all, I conclude that it is probably not worth the effort to maintain separate versions of the recurrence for pre-computed and on-the-fly constants.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia package for evaluating and transforming Wigner's ùîá matrices, and spin-weighted spherical harmonics (which includes the ordinary scalar spherical harmonics).  These functions are evaluated directly in terms of quaternions, as well as in the more standard forms of spherical coordinates and Euler angles.[1] Among other applications, those functions permit \"synthesis\" (evaluation of the spin-weighted spherical functions) of spin-weighted spherical harmonic coefficients on regular or distorted grids.  This package also includes functions enabling efficient \"analysis\" (decomposition into mode coefficients) of functions evaluated on regular grids to high order and accuracy.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"These quantities are computed using recursion relations, which makes it possible to compute to very high ‚Ñì values.  Unlike direct evaluation of individual elements, which will generally cause overflow or underflow beyond ‚Ñì‚âà30 when using double precision, these recursion relations should be valid for far higher ‚Ñì values.  More precisely, Inf values appear starting at ‚Ñì=22 for Float16, ‚Ñì=183 for Float32, and ‚Ñì=1474 for Float64.  BigFloat also works, and presumably will not overflow for any ‚Ñì value that could reasonably fit into computer memory ‚Äî though it is far slower.  Also note that DoubleFloats will work, and achieve significantly greater accuracy (but no greater range) than Float64.  The results are accurate to roughly ‚Ñì times the precision of the input quaternion.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The conventions for this package are described in detail on this page.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note that numerous other packages cover some of these use cases, including FastTransforms.jl, FastSphericalHarmonics.jl, and WignerSymbols.jl.  However, I need support for higher-precision numbers ‚Äî even at the cost of some speed ‚Äî which is what this package provides.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Depth = 4","category":"page"},{"location":"#Function-list","page":"Introduction","title":"Function list","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following list contains the public functions inside the SphericalFunctions module.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [SphericalFunctions]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1]: Euler angles are quite generally a very poor choice for computing with rotations.  (The only context in which they may be preferred is when analytically integrating some analytically known functions.)  Almost universally, it is best to use quaternions when computing with rotations.  All the computations done within this package use quaternions; the user interfaces involving Euler angles essentially convert to/from quaternions.  While the calculations needed for those conversions would still need to be done if this package used Euler angles internally ‚Äî meaning that this approach is as efficient as any ‚Äî that work can be avoided entirely if you work with quaternions directly.","category":"page"}]
}
