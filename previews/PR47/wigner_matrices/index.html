<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Wigner&#39;s 𝔇 and d matrices · SphericalFunctions.jl</title><meta name="title" content="Wigner&#39;s 𝔇 and d matrices · SphericalFunctions.jl"/><meta property="og:title" content="Wigner&#39;s 𝔇 and d matrices · SphericalFunctions.jl"/><meta property="twitter:title" content="Wigner&#39;s 𝔇 and d matrices · SphericalFunctions.jl"/><meta name="description" content="Documentation for SphericalFunctions.jl."/><meta property="og:description" content="Documentation for SphericalFunctions.jl."/><meta property="twitter:description" content="Documentation for SphericalFunctions.jl."/><meta property="og:url" content="https://moble.github.io/SphericalFunctions.jl/stable/wigner_matrices/"/><meta property="twitter:url" content="https://moble.github.io/SphericalFunctions.jl/stable/wigner_matrices/"/><link rel="canonical" href="https://moble.github.io/SphericalFunctions.jl/stable/wigner_matrices/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SphericalFunctions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../transformations/"><span>$s$</span>-SHT Transformations</a></li><li class="is-active"><a class="tocitem" href>Wigner&#39;s <span>$𝔇$</span> and <span>$d$</span> matrices</a><ul class="internal"><li><a class="tocitem" href="#Docstrings"><span>Docstrings</span></a></li></ul></li><li><a class="tocitem" href="../sYlm/"><span>${}_{s}Y_{\ell,m}$</span> functions</a></li><li><a class="tocitem" href="../operators/">Differential operators</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../internal/">Internal functions</a></li><li><a class="tocitem" href="../functions/">Complete function list</a></li></ul></li><li><span class="tocitem">Notes</span><ul><li><a class="tocitem" href="../notes/H_recursions/">Algorithm for computing <span>$H$</span></a></li><li><a class="tocitem" href="../notes/sampling_theorems/">Sampling theorems and transformations of spin-weighted spherical harmonics</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Wigner&#39;s <span>$𝔇$</span> and <span>$d$</span> matrices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Wigner&#39;s <span>$𝔇$</span> and <span>$d$</span> matrices</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/moble/SphericalFunctions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/moble/SphericalFunctions.jl/blob/main/docs/src/wigner_matrices.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Wigner&#39;s-𝔇-and-d-matrices"><a class="docs-heading-anchor" href="#Wigner&#39;s-𝔇-and-d-matrices">Wigner&#39;s <span>$𝔇$</span> and <span>$d$</span> matrices</a><a id="Wigner&#39;s-𝔇-and-d-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Wigner&#39;s-𝔇-and-d-matrices" title="Permalink"></a></h1><p>Wigner&#39;s <span>$𝔇$</span> matrices — and to a lesser extent, the related <span>$d$</span> matrices — are extremely important in the theory of rotations.  Each element is, itself, a special function of the rotation group: in particular, an eigenfunction of <a href="../operators/#Differential-operators">the left- and right-Lie derivatives</a>, and thus a spin-weighted spherical function.  Collectively, they describe how spin-weighted spherical functions transform under rotation.  But their accurate and efficient computation is surprisingly subtle.  This package implements the current state-of-the-art techniques for their fast and accurate computation, based on the <a href="../notes/H_recursions/#Algorithm-for-computing-H"><span>$H$</span> recursion</a>.</p><p>The actual computations can be done with the <a href="#SphericalFunctions.D_matrices"><code>D_matrices</code></a> function:</p><pre><code class="language-julia hljs">using Quaternionic
using SphericalFunctions

R = randn(RotorF64)
ℓₘₐₓ = 8
𝔇 = D_matrices(R, ℓₘₐₓ)</code></pre><p>However, the matrices can take up a lot of memory.  So for maximum efficiency when calling this function repeatedly with different <code>R</code> values, it is best to pre-allocate the necessary memory with the <a href="#SphericalFunctions.D_prep"><code>D_prep</code></a> function, and the pass that in as an argument to <a href="#SphericalFunctions.D_matrices!"><code>D_matrices!</code></a>:</p><pre><code class="language-julia hljs">D_storage = D_prep(ℓₘₐₓ)
𝔇 = D_matrices!(D_storage, R)</code></pre><p>(Beware that, as noted in the documentation for <a href="#SphericalFunctions.D_matrices!"><code>D_matrices!</code></a>, the output <code>𝔇</code> is just a reference to part of the <code>D_storage</code> object, so you should not reuse <code>D_storage</code> until you have copied or otherwise finished using <code>𝔇</code>.)</p><p>The output <code>𝔇</code> is a (linear!) vector of <code>Complex</code> numbers with the same base type as <code>R</code>.  The ordering of the elements is described in the documentation for <a href="#SphericalFunctions.D_matrices"><code>D_matrices</code></a>.  It is also possible to efficiently view slices of this vector as a series of individual matrices using a <a href="#SphericalFunctions.D_iterator"><code>D_iterator</code></a>:</p><pre><code class="language-julia hljs">for (ℓ, Dˡ) in zip(0:ℓₘₐₓ, D_iterator(𝔇, ℓₘₐₓ))
    # Do something with the matrix Dˡ[ℓ+m′+1, ℓ+m+1]
end</code></pre><p>For the <span>$d$</span> matrices, we have almost the same interface, except that instead of the input quaternion <code>R</code> we only need the angle <code>β</code> (or its complex angle <code>expiβ</code>, which can be computed directly in some cases), and the output is real-valued:</p><pre><code class="language-julia hljs">using Quaternionic
using SphericalFunctions

β = π * rand(Float64)
ℓₘₐₓ = 8
d = d_matrices(β, ℓₘₐₓ)</code></pre><p>Again, for repeated calls, it is best to pre-allocate storage:</p><pre><code class="language-julia hljs">d_storage = d_prep(ℓₘₐₓ)
d = d_matrices!(d_storage, β)</code></pre><p>The output <code>d</code> is a vector of numbers of the same type as <code>β</code>, ordered in the same way as the output of <a href="#SphericalFunctions.D_matrices"><code>D_matrices</code></a>.  And similarly, we can iterate over the individual matrices using a <a href="#SphericalFunctions.d_iterator"><code>d_iterator</code></a>.</p><h2 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.D_matrices" href="#SphericalFunctions.D_matrices"><code>SphericalFunctions.D_matrices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">D_matrices(R, ℓₘₐₓ)
D_matrices(α, β, γ, ℓₘₐₓ)</code></pre><p>Compute Wigner&#39;s 𝔇 matrices <span>$\mathfrak{D}^{(\ell)}_{m&#39;,m}(\beta)$</span> for all <span>$\ell \leq \ell_\mathrm{max}$</span>.</p><p>See <a href="#SphericalFunctions.D_matrices!"><code>D_matrices!</code></a> for details about the input and output values.</p><p>This function only appropriate when you need to evaluate the matrices for a single value of <code>R</code> or <code>α, β, γ</code> because it allocates large arrays and performs many calculations that could be reused.  If you need to evaluate the matrices for many values of <code>R</code> or <code>α, β, γ</code>, you should pre-allocate the storage with <a href="#SphericalFunctions.D_prep"><code>D_prep</code></a>, and then call <a href="#SphericalFunctions.D_matrices!"><code>D_matrices!</code></a> with the result instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/57891a4b6c263f2ac064ae00111382dba686c6c7/src/evaluate.jl#L184-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.D_matrices!" href="#SphericalFunctions.D_matrices!"><code>SphericalFunctions.D_matrices!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">D_matrices!(D_storage, R)
D_matrices!(D_storage, α, β, γ)
D_matrices!(D, R, ℓₘₐₓ)
D_matrices!(D, α, β, γ, ℓₘₐₓ)</code></pre><p>Compute Wigner&#39;s 𝔇 matrices <span>$\mathfrak{D}^{(\ell)}_{m&#39;,m}(\beta)$</span> for all <span>$\ell \leq \ell_\mathrm{max}$</span>.</p><p>In all cases, the result is returned in a 1-dimensional array ordered as</p><pre><code class="nohighlight hljs">[
    𝔇ˡₘₚ,ₘ(R)
    for ℓ ∈ 0:ℓₘₐₓ
    for mp ∈ -ℓ:ℓ
    for m ∈ -ℓ:ℓ
]</code></pre><p>When the first argument is <code>D</code>, it will be modified, so it must be at least as large as that array. When the first argument is <code>D_storage</code>, it should be the quantity returned by <a href="#SphericalFunctions.D_prep"><code>D_prep</code></a>, and the result will be written into the <code>D</code> field of that tuple.  Both of these options — especially the latter — reduce the number of allocations needed on each call to the corresponding functions, which should increase the speed significantly.  Note that the <code>D</code> or <code>D_storage</code> arguments must have types compatible with the type of <code>R</code> or <code>α, β, γ</code>.</p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>When using the <code>D_storage</code> argument (which is recommended), the returned quantity <code>D</code> will be an alias of <code>D_storage[1]</code>.  If you want to retain that data after the next call to <a href="#SphericalFunctions.D_matrices!"><code>D_matrices!</code></a>, you should copy it with <code>copy(D)</code>.</p></div></div><p>The <code>α, β, γ</code> arguments are Euler angles as described in the documentation of <a href="https://moble.github.io/Quaternionic.jl/dev/manual/#Quaternionic.from_euler_angles-Tuple{Any,%20Any,%20Any}"><code>Quaternionic.from_euler_angles</code></a>.</p><p>See also <a href="#SphericalFunctions.D_matrices"><code>D_matrices</code></a> for a simpler function call when you only need to evaluate the matrices for a single value of <code>R</code> or <code>α, β, γ</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Quaternionic, SphericalFunctions
ℓₘₐₓ = 8
T = Float64
R = Rotor{T}(1, 2, 3, 4)  # Will be normalized automatically
D_storage = D_prep(ℓₘₐₓ, T)
D = D_matrices!(D_storage, R)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/57891a4b6c263f2ac064ae00111382dba686c6c7/src/evaluate.jl#L212-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.D_prep" href="#SphericalFunctions.D_prep"><code>SphericalFunctions.D_prep</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">D_prep(ℓₘₐₓ, [T=Float64])</code></pre><p>Construct storage space and pre-compute recursion coefficients to compute Wigner&#39;s <span>$\mathfrak{D}$</span> matrix in place.</p><p>This returns the <code>D_storage</code> arguments needed by <a href="#SphericalFunctions.D_matrices!"><code>D_matrices!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/57891a4b6c263f2ac064ae00111382dba686c6c7/src/evaluate.jl#L282-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.D_iterator" href="#SphericalFunctions.D_iterator"><code>SphericalFunctions.D_iterator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">D_iterator(D, ℓₘₐₓ, [ℓₘᵢₙ])</code></pre><p>Construct an Iterator that returns sub-matrices of <code>D</code>, each of which consists of elements <span>$(ℓ,-ℓ,-ℓ)$</span> through <span>$(ℓ,ℓ,ℓ)$</span>, for <span>$ℓ$</span> from <code>ℓₘᵢₙ</code> through <code>ℓₘₐₓ</code>.  By default, <code>ℓₘᵢₙ</code> is 0.</p><div class="admonition is-danger"><header class="admonition-header">Incorrect behavior</header><div class="admonition-body"><p>This iterator mistakenly returns the transpose of the result implied by the documentation.  To avoid breaking code that relies on this behavior, this is a final release in this major version of the package.  On the other hand, to avoid silent bugs, this version is being released with this warning.  The next major version of the package will likely provide the expected behavior, though with inefficient performance; and the major version after that will likely provide the expected behavior with efficient performance.</p></div></div><p>Note that the returned objects are <em>views</em> into the original <code>D</code> data — meaning that you may alter their values.</p><p>Because the result is a matrix restricted to a particular <span>$ℓ$</span> value, you can index the <span>$(ℓ, m′, m)$</span> element as <code>[ℓ+m′+1, ℓ+m+1]</code>.  For example, you might use this as something like</p><pre><code class="nohighlight hljs">for (ℓ, Dˡ) in zip(ℓₘᵢₙ:ℓₘₐₓ, D_iterator(D, ℓₘₐₓ))
    for m′ in -ℓ:ℓ
        for m in -ℓ:ℓ
            Dˡ[ℓ+m′+1, ℓ+m+1]  # ... do something with Dˡ
        end
    end
end</code></pre><p>Also note that no bounds checking is done, either at instantiation time or during iteration.  You are responsible for ensuring that the size of <code>D</code> and the values of <code>ℓₘₐₓ</code> and <code>ℓₘᵢₙ</code> make sense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/57891a4b6c263f2ac064ae00111382dba686c6c7/src/iterators.jl#L12-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.d_matrices" href="#SphericalFunctions.d_matrices"><code>SphericalFunctions.d_matrices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">d_matrices(β, ℓₘₐₓ)
d_matrices(expiβ, ℓₘₐₓ)</code></pre><p>Compute Wigner&#39;s <span>$d^{(\ell)}$</span> matrices with elements <span>$d^{(\ell)}_{m&#39;,m}(\beta)$</span> for all <span>$\ell \leq \ell_\mathrm{max}$</span>.  The <span>$d$</span> matrices are sometimes called the &quot;reduced&quot; Wigner matrices, in contrast to the full <span>$\mathfrak{D}$</span> matrices.</p><p>See <a href="#SphericalFunctions.d_matrices!"><code>d_matrices!</code></a> for details about the input and output values.</p><p>This function only appropriate when you need to evaluate the matrices for a single value of <code>β</code> or <code>expiβ</code> because it allocates large arrays and performs many calculations that could be reused.  If you need to evaluate the matrices for many values of <code>β</code> or <code>expiβ</code>, you should pre-allocate the storage with <a href="#SphericalFunctions.d_prep"><code>d_prep</code></a>, and then call <a href="#SphericalFunctions.d_matrices!"><code>d_matrices!</code></a> with the result instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/57891a4b6c263f2ac064ae00111382dba686c6c7/src/evaluate.jl#L13-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.d_matrices!" href="#SphericalFunctions.d_matrices!"><code>SphericalFunctions.d_matrices!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">d_matrices!(d_storage, β)
d_matrices!(d_storage, expiβ)
d_matrices!(d, β, ℓₘₐₓ)
d_matrices!(d, expiβ, ℓₘₐₓ)</code></pre><p>Compute Wigner&#39;s <span>$d^{(\ell)}$</span> matrices with elements <span>$d^{(\ell)}_{m&#39;,m}(\beta)$</span> for all <span>$\ell \leq \ell_\mathrm{max}$</span>.  The <span>$d$</span> matrices are sometimes called the &quot;reduced&quot; Wigner matrices, in contrast to the full <span>$\mathfrak{D}$</span> matrices.</p><p>In all cases, the result is returned in a 1-dimensional array ordered as</p><pre><code class="nohighlight hljs">[
    dˡₘₚ,ₘ(β)
    for ℓ ∈ 0:ℓₘₐₓ
    for mp ∈ -ℓ:ℓ
    for m ∈ -ℓ:ℓ
]</code></pre><p>When the first argument is <code>d</code>, it will be modified, so it must be at least as large as that array.  When the first argument is <code>d_storage</code>, it should be the quantity returned by <a href="#SphericalFunctions.d_prep"><code>d_prep</code></a>, and the result will be written into the <code>d</code> field of that tuple.  Both of these options — especially the latter — reduce the number of allocations needed on each call to the corresponding functions, which should increase the speed significantly.</p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>When using the <code>d_storage</code> argument (which is recommended), the returned quantity <code>d</code> will be an alias of <code>d_storage[1]</code>.  If you want to retain that data after the next call to <a href="#SphericalFunctions.d_matrices!"><code>d_matrices!</code></a>, you should copy it with <code>copy(d)</code>.</p></div></div><p>See also <a href="#SphericalFunctions.d_matrices"><code>d_matrices</code></a> for a simpler function call when you only need to evaluate the matrices for a single value of <code>β</code> or <code>expiβ</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SphericalFunctions
ℓₘₐₓ = 8
T = Float64
β = T(1)/8
d_storage = d_prep(ℓₘₐₓ, T)
d = d_matrices!(d_storage, β)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/57891a4b6c263f2ac064ae00111382dba686c6c7/src/evaluate.jl#L33-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.d_prep" href="#SphericalFunctions.d_prep"><code>SphericalFunctions.d_prep</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">d_prep(ℓₘₐₓ, [T=Float64])</code></pre><p>Construct space and pre-compute recursion coefficients to compute Wigner&#39;s <span>$d$</span> matrix in place.</p><p>This returns the <code>d_storage</code> arguments needed by <a href="#SphericalFunctions.d_matrices!"><code>d_matrices!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/57891a4b6c263f2ac064ae00111382dba686c6c7/src/evaluate.jl#L99-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.d_iterator" href="#SphericalFunctions.d_iterator"><code>SphericalFunctions.d_iterator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">d_iterator(d, ℓₘₐₓ, [ℓₘᵢₙ])</code></pre><p>Construct an Iterator that returns sub-matrices of <code>d</code>, each of which consists of elements <span>$(ℓ,-ℓ,-ℓ)$</span> through <span>$(ℓ,ℓ,ℓ)$</span>, for <span>$ℓ$</span> from <code>ℓₘᵢₙ</code> through <code>ℓₘₐₓ</code>.  By default, <code>ℓₘᵢₙ</code> is 0.</p><div class="admonition is-danger"><header class="admonition-header">Incorrect behavior</header><div class="admonition-body"><p>This iterator mistakenly returns the transpose of the result implied by the documentation.  To avoid breaking code that relies on this behavior, this is a final release in this major version of the package.  On the other hand, to avoid silent bugs, this version is being released with this warning.  The next major version of the package will likely provide the expected behavior, though with inefficient performance; and the major version after that will likely provide the expected behavior with efficient performance.</p></div></div><p>Note that the returned objects are <em>views</em> into the original <code>d</code> data — meaning that you may alter their values.</p><p>Because the result is a matrix restricted to a particular <span>$ℓ$</span> value, you can index the <span>$(ℓ, m′, m)$</span> element as <code>[ℓ+m′+1, ℓ+m+1]</code>.  For example, you might use this as something like</p><pre><code class="nohighlight hljs">for (ℓ, dˡ) in zip(ℓₘᵢₙ:ℓₘₐₓ, d_iterator(d, ℓₘₐₓ))
    for m′ in -ℓ:ℓ
        for m in -ℓ:ℓ
            dˡ[ℓ+m′+1, ℓ+m+1]  # ... do something with dˡ
        end
    end
end</code></pre><p>Also note that no bounds checking is done, either at instantiation time or during iteration.  You are responsible for ensuring that the size of <code>d</code> and the values of <code>ℓₘₐₓ</code> and <code>ℓₘᵢₙ</code> make sense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/57891a4b6c263f2ac064ae00111382dba686c6c7/src/iterators.jl#L83-L118">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../transformations/">« <span>$s$</span>-SHT Transformations</a><a class="docs-footer-nextpage" href="../sYlm/"><span>${}_{s}Y_{\ell,m}$</span> functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 4 December 2024 15:43">Wednesday 4 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
