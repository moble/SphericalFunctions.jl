<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Differential operators ¬∑ SphericalFunctions.jl</title><meta name="title" content="Differential operators ¬∑ SphericalFunctions.jl"/><meta property="og:title" content="Differential operators ¬∑ SphericalFunctions.jl"/><meta property="twitter:title" content="Differential operators ¬∑ SphericalFunctions.jl"/><meta name="description" content="Documentation for SphericalFunctions.jl."/><meta property="og:description" content="Documentation for SphericalFunctions.jl."/><meta property="twitter:description" content="Documentation for SphericalFunctions.jl."/><meta property="og:url" content="https://moble.github.io/SphericalFunctions.jl/stable/operators/"/><meta property="twitter:url" content="https://moble.github.io/SphericalFunctions.jl/stable/operators/"/><link rel="canonical" href="https://moble.github.io/SphericalFunctions.jl/stable/operators/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SphericalFunctions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../transformations/"><span>$s$</span>-SHT Transformations</a></li><li><a class="tocitem" href="../wigner_matrices/">Wigner&#39;s <span>$ùîá$</span> and <span>$d$</span> matrices</a></li><li><a class="tocitem" href="../sYlm/"><span>${}_{s}Y_{\ell,m}$</span> functions</a></li><li class="is-active"><a class="tocitem" href>Differential operators</a><ul class="internal"><li><a class="tocitem" href="#Commutators"><span>Commutators</span></a></li><li><a class="tocitem" href="#Transformations-of-functions-vs.-mode-weights"><span>Transformations of functions vs. mode weights</span></a></li><li><a class="tocitem" href="#Docstrings"><span>Docstrings</span></a></li></ul></li><li><a class="tocitem" href="../utilities/">Utilities</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../internal/">Internal functions</a></li><li><a class="tocitem" href="../functions/">Complete function list</a></li></ul></li><li><span class="tocitem">Notes</span><ul><li><a class="tocitem" href="../notes/H_recursions/">Algorithm for computing <span>$H$</span></a></li><li><a class="tocitem" href="../notes/sampling_theorems/">Sampling theorems and transformations of spin-weighted spherical harmonics</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Differential operators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Differential operators</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/moble/SphericalFunctions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/moble/SphericalFunctions.jl/blob/main/docs/src/operators.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Differential-operators"><a class="docs-heading-anchor" href="#Differential-operators">Differential operators</a><a id="Differential-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Differential-operators" title="Permalink"></a></h1><p>Spin-weighted spherical functions <em>cannot</em> be defined on the sphere <span>$S^2$</span>, but are well defined on the group <span>$\mathrm{Spin}(3) \cong \mathrm{SU}(2)$</span> or the rotation group <span>$\mathrm{SO}(3)$</span>.  (See <a href="../references/#Boyle_2016">Boyle [1]</a> for the explanation.)  However, this also allows us to define a variety of differential operators acting on these functions, relating to infinitesimal motions in these groups, acting either from the left or the right on their arguments.  Right or left matters because the groups mentioned above are all non-commutative groups.</p><p>In general, the <em>left</em> Lie derivative of a function <span>$f(Q)$</span> over the unit quaternions with respect to a generator of rotation <span>$g$</span> is defined as</p><p class="math-container">\[L_g(f)\{Q\} := -\frac{i}{2}
    \left. \frac{df\left(\exp(t\,g)\, Q\right)}{dt} \right|_{t=0}.\]</p><p>Note that the exponential multiplies <span>$Q$</span> <em>on the left</em> ‚Äî hence the name.  We will see below that this agrees with the usual definition of the angular-momentum from physics, except that in <em>quantum</em> physics a factor of <span>$\hbar$</span> is usually included.</p><p>So, for example, a rotation about the <span>$z$</span> axis has the quaternion <span>$z$</span> as its generator of rotation, and <span>$L_z$</span> defined in this way agrees with <a href="https://en.wikipedia.org/wiki/Angular_momentum_operator">the usual angular-momentum operator</a> <span>$L_z$</span> familiar from spherical-harmonic theory, and reduces to it when the function has spin weight 0, but also applies to functions of general spin weight.  Similarly, we can compute <span>$L_x$</span> and <span>$L_y$</span>, and take appropriate combinations to find <a href="https://en.wikipedia.org/wiki/Ladder_operator#Angular_momentum">the usual raising and lowering (ladder) operators</a> <span>$L_+$</span> and <span>$L_-$</span>.</p><p>In just the same way, we can define the <em>right</em> Lie derivative of a function <span>$f(Q)$</span> over the unit quaternions with respect to a generator of rotation <span>$g$</span> as</p><p class="math-container">\[R_g(f)\{Q\} := -\frac{i}{2}
    \left. \frac{df\left(Q\, \exp(t\,g)\right)}{dt} \right|_{t=0}.\]</p><p>Note that the exponential multiplies <span>$Q$</span> <em>on the right</em> ‚Äî hence the name.</p><p>This operator is less common in physics, because it represents the dependence of the function on the choice of frame (or coordinate system), which is not usually of interest. Multiplication on the left represents a rotation of the physical system, while rotation on the right represents a rotation of the coordinate system.  However, this dependence on coordinate system is precisely what defines the <em>spin weight</em> of a function, so this class of operators is relevant in discussions of spin-weighted spherical functions.  In particular, the operators <span>$R_\pm$</span> correspond (up to a sign) to the spin-raising and -lowering operators <span>$\eth$</span> and <span>$\bar{\eth}$</span> originally introduced by <a href="../references/#Newman_1966">Newman and Penrose [5]</a>, as explained in greater detail by <a href="../references/#Boyle_2016">Boyle [1]</a>.</p><p>Note that these definitions are <em>extremely</em> general, in that they can be used for <em>any</em> Lie group, and for any complex-valued function on that group.  And in full generality, we have the useful properties of linearity:</p><p class="math-container">\[L_{s\mathbf{a}} = sL_{\mathbf{a}}
\qquad \text{and} \qquad
R_{s\mathbf{a}} = sR_{\mathbf{a}},\]</p><p>and</p><p class="math-container">\[L_{\mathbf{a}+\mathbf{b}} = L_{\mathbf{a}} + L_{\mathbf{b}}
\qquad \text{and} \qquad
R_{\mathbf{a}+\mathbf{b}} = R_{\mathbf{a}} + R_{\mathbf{b}},\]</p><p>for any scalar <span>$s$</span> and any elements of the Lie algebra <span>$\mathbf{a}$</span> and <span>$\mathbf{b}$</span>.  In particular, if the Lie algebra has a basis <span>$\mathbf{e}_{(j)}$</span>, we use the shorthand <span>$L_j$</span> and <span>$R_j$</span> for <span>$L_{\mathbf{e}_{(j)}}$</span> and <span>$R_{\mathbf{e}_{(j)}}$</span>, respectively, and we can expand any operator in terms of these basis operators:</p><p class="math-container">\[L_{\mathbf{a}} = \sum_{j} a_j L_j
\qquad \text{and} \qquad
R_{\mathbf{a}} = \sum_{j} a_j R_j.\]</p><h2 id="Commutators"><a class="docs-heading-anchor" href="#Commutators">Commutators</a><a id="Commutators-1"></a><a class="docs-heading-anchor-permalink" href="#Commutators" title="Permalink"></a></h2><p>In general, for generators <span>$a$</span> and <span>$b$</span>, we have the commutator relations</p><p class="math-container">\[\left[ L_a, L_b \right] = \frac{i}{2} L_{[a,b]}
\qquad
\left[ R_a, R_b \right] = -\frac{i}{2} R_{[a,b]},\]</p><p>where <span>$[a,b]$</span> is the commutator of the two generators, which can be obtained directly as the commutator of the corresponding quaternions.  Note the sign difference between these two equations.  The factors of <span>$\pm i/2$</span> are inherited directly from the definitions of <span>$L_g$</span> and <span>$R_g$</span> given above, but they appear there with the <em>same</em> sign.  The sign difference between these two commutator equations results from the fact that the quaternions are multiplied in opposite orders in the two cases.  It <em>could</em> be absorbed by defining the operators with opposite signs.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>  The arbitrary sign choices used above are purely for historical reasons.</p><p>Again, these results are valid for general (finite-dimensional) Lie groups, but a particularly interesting case is in application to the three-dimensional rotation group.  In the following, we will apply our results to this group.</p><p>The commutator relations for <span>$L$</span> are consistent ‚Äî except for the differing use of <span>$\hbar$</span> ‚Äî with the usual relations from quantum mechanics:</p><p class="math-container">\[\left[ L_j, L_k \right] = i \hbar \sum_{l=1}^{3} \varepsilon_{jkl} L_l.\]</p><p>Here, <span>$j$</span>, <span>$k$</span>, and <span>$l$</span> are indices that run from 1 to 3, and index the set of basis vectors <span>$(\hat{x}, \hat{y}, \hat{z})$</span>.  If we represent an arbitrary basis vector as <span>$\hat{e}_j$</span>, then the quaternion commutator <span>$[a,b]$</span> in the expression for <span>$[L_a, L_b]$</span> becomes</p><p class="math-container">\[[\hat{e}_j, \hat{e}_k] = 2 \sum_{l=1}^{3} \varepsilon_{jkl} \hat{e}_l.\]</p><p>Plugging this into the general expression <span>$[L_a, L_b] = \frac{i}{2} L_{[a,b]}$</span>, we obtain (up to the factor of <span>$\hbar$</span>) the version frequently seen in quantum physics.</p><p>The raising and lowering operators relative to <span>$L_z$</span> and <span>$R_z$</span> satisfy ‚Äî by definition of raising and lowering operators ‚Äî the relations</p><p class="math-container">\[[L_z, L_\pm] = \pm L_\pm
\qquad
[R_z, R_\pm] = \pm R_\pm.\]</p><p>These allow us to solve ‚Äî up to an overall factor ‚Äî for those operators in terms of the basic generators (again, noting the sign difference):</p><p class="math-container">\[L_\pm = L_x \pm i L_y
\qquad
R_\pm = R_x \mp i R_y.\]</p><p>(Interestingly, this procedure also shows that rasing and lowering operators can only exist if the factor in front of the derivatives in the definitions of <span>$L_g$</span> and <span>$R_g$</span> are pure imaginary numbers.)  In particular, this results in the commutator relations</p><p class="math-container">\[[L_+, L_-] = 2L_z
\qquad
[R_+, R_-] = 2R_z.\]</p><p>Here, the signs are <em>similar</em> because the two sign differences noted above essentially cancel each other out.</p><p>In the functions <a href="#Module-functions">listed below</a>, these operators are returned as matrices acting on vectors of mode weights.  As such, we can actually evaluate these commutators as given to cross-validate the expressions and those functions.</p><h2 id="Transformations-of-functions-vs.-mode-weights"><a class="docs-heading-anchor" href="#Transformations-of-functions-vs.-mode-weights">Transformations of functions vs. mode weights</a><a id="Transformations-of-functions-vs.-mode-weights-1"></a><a class="docs-heading-anchor-permalink" href="#Transformations-of-functions-vs.-mode-weights" title="Permalink"></a></h2><p>One important point to note is that mode weights transform &quot;contravariantly&quot; (very loosely speaking) relative to the spin-weighted spherical functions under some operators.  For example, take the action of the <span>$L_+$</span> operator, which acts on a SWSH as</p><p class="math-container">\[L_+ \left\{{}_{s}Y_{\ell,m}\right\} (R) = \sqrt{(\ell-m)(\ell+m+1)} {}_{s}Y_{\ell,m+1}(R).\]</p><p>We can use this to derive the mode weights of a general spin-weighted function <span>$f$</span> under the action of this operator:<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></p><p class="math-container">\[\begin{aligned}
\left\{L_+ f\right\}_{\ell,m}
&amp;=
\int \left\{L_+ f(R)\right\}\, {}_{s}\bar{Y}_{\ell,m}(R)\, dR \\
&amp;=
\int \left\{L_+ \sum_{\ell&#39;,m&#39;}f_{\ell&#39;,m&#39;}\, {}_{s}Y_{\ell&#39;,m&#39;}(R)\right\}\, {}_{s}\bar{Y}_{\ell,m}(R)\, dR \\
&amp;=
\int \sum_{\ell&#39;,m&#39;} f_{\ell&#39;,m&#39;}\, \left\{L_+ {}_{s}Y_{\ell&#39;,m&#39;}(R)\right\}\, {}_{s}\bar{Y}_{\ell,m}(R)\, dR \\
&amp;=
\sum_{\ell&#39;,m&#39;} f_{\ell&#39;,m&#39;}\, \int \left\{L_+ {}_{s}Y_{\ell&#39;,m&#39;}(R)\right\}\, {}_{s}\bar{Y}_{\ell,m}(R)\, dR \\
&amp;=
\sum_{\ell&#39;,m&#39;} f_{\ell&#39;,m&#39;}\, \int \left\{\sqrt{(\ell&#39;-m&#39;)(\ell&#39;+m&#39;+1)} {}_{s}Y_{\ell&#39;,m&#39;+1}(R)\right\}\, {}_{s}\bar{Y}_{\ell,m}(R)\, dR \\
&amp;=
\sum_{\ell&#39;,m&#39;} f_{\ell&#39;,m&#39;}\, \sqrt{(\ell&#39;-m&#39;)(\ell&#39;+m&#39;+1)} \int {}_{s}Y_{\ell&#39;,m&#39;+1}(R)\, {}_{s}\bar{Y}_{\ell,m}(R)\, dR \\
&amp;=
\sum_{\ell&#39;,m&#39;} f_{\ell&#39;,m&#39;}\, \sqrt{(\ell&#39;-m&#39;)(\ell&#39;+m&#39;+1)} \delta_{\ell,\ell&#39;} \delta_{m,m&#39;+1} \\
&amp;=
f_{\ell,m-1}\, \sqrt{(\ell-m+1)(\ell+m)}
\end{aligned}\]</p><p>Note that this expression (and in particular its signs) more resembles the expression for <span>$L_- \left\{{}_{s}Y_{\ell,m}\right\}$</span> than for <span>$L_+ \left\{{}_{s}Y_{\ell,m}\right\}$</span>.  Similar relations hold for the action of <span>$L_-$</span>.</p><p>However, it is important to note that the same &quot;contravariance&quot; is not present for the spin-raising and -lowering operators:</p><p class="math-container">\[\begin{aligned}
\left\{\eth f\right\}_{\ell,m}
&amp;=
\int \left\{\eth f(R)\right\}\, {}_{s+1}\bar{Y}_{\ell,m}(R)\, dR \\
&amp;=
\int \left\{\eth \sum_{\ell&#39;,m&#39;}f_{\ell&#39;,m&#39;}\, {}_{s}Y_{\ell&#39;,m&#39;}(R)\right\}\, {}_{s+1}\bar{Y}_{\ell,m}(R)\, dR \\
&amp;=
\sum_{\ell&#39;,m&#39;} f_{\ell&#39;,m&#39;}\, \int \left\{\eth {}_{s}Y_{\ell&#39;,m&#39;}(R)\right\}\, {}_{s+1}\bar{Y}_{\ell,m}(R)\, dR \\
&amp;=
\sum_{\ell&#39;,m&#39;} f_{\ell&#39;,m&#39;}\, \sqrt{(\ell&#39;-s)(\ell&#39;+s+1)} \int {}_{s+1}Y_{\ell&#39;,m&#39;}(R)\, {}_{s+1}\bar{Y}_{\ell,m}(R)\, dR \\
&amp;=
\sum_{\ell&#39;,m&#39;} f_{\ell&#39;,m&#39;}\, \sqrt{(\ell&#39;-s)(\ell&#39;+s+1)} \delta_{\ell,\ell&#39;} \delta_{m,m&#39;} \\
&amp;=
f_{\ell,m}\, \sqrt{(\ell-s)(\ell+s+1)}
\end{aligned}\]</p><p>Similarly <span>$\bar{\eth}$</span> ‚Äî and <span>$R_\pm$</span> of course ‚Äî obey this more &quot;covariant&quot; form of transformation.</p><h2 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.Lz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T" href="#SphericalFunctions.Lz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>SphericalFunctions.Lz</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Lz(s, ‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì, [T])</code></pre><p>Compute the angular-momentum operator associated with the <span>$z$</span> direction.  This is the standard <span>$L_z$</span> operator, familiar from basic physics, extended to work with SWSHs.  Note that this is the left Lie derivative; see <a href="#SphericalFunctions.Rz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Rz</code></a> for the equivalent right Lie derivative.  See <a href="#Differential-operators">the documentation</a> or <a href="../references/#Boyle_2016">Boyle</a> for more details.</p><p>In terms of the SWSHs, we can write the action of <span>$L_z$</span> as</p><p class="math-container">\[L_z {}_{s}Y_{\ell,m} = m\, {}_{s}Y_{\ell,m}\]</p><p>See also <a href="#SphericalFunctions.L¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L¬≤</code></a>, <a href="#SphericalFunctions.L‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çä</code></a>, <a href="#SphericalFunctions.L‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çã</code></a>, <a href="#SphericalFunctions.R¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R¬≤</code></a>, <a href="#SphericalFunctions.Rz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Rz</code></a>, <a href="#SphericalFunctions.R‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çä</code></a>, <a href="#SphericalFunctions.R‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çã</code></a>, <a href="#SphericalFunctions.√∞-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>√∞</code></a>, <a href="#SphericalFunctions.√∞ÃÑ-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>√∞ÃÑ</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/8a5711af0f96a74ca90837b9fba3ee99a6b6e67f/src/operators.jl#L30-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.L¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T" href="#SphericalFunctions.L¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>SphericalFunctions.L¬≤</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">L¬≤(s, ‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì, [T])</code></pre><p>Compute the total angular-momentum operator from <code>‚Ñì‚Çò·µ¢‚Çô</code> up to <code>‚Ñì‚Çò‚Çê‚Çì</code>.  If not present, <code>‚Ñì‚Çò·µ¢‚Çô</code> is assumed to be <code>abs(s)</code>.  The argument <code>s</code> is ignored; it is present only for consistency with other operators, and is assumed to be 0 if not present.</p><p>This is the standard <span>$L¬≤$</span> operator, familiar from basic physics, extended to work with SWSHs.  It is also known as the Casimir operator, and is equal to</p><p class="math-container">\[L^2 = L_x^2 + L_y^2 + L_z^2 = \frac{L_+L_- + L_-L_+ + 2L_zL_z}{2}.\]</p><p>Note that these are the left Lie derivatives, but <span>$L^2 = R^2$</span>, where <code>R</code> is the right Lie derivative.  See <a href="#Differential-operators">the documentation</a> or <a href="../references/#Boyle_2016">Boyle</a> for more details.</p><p>In terms of the SWSHs, we can write the action of <span>$L^2$</span> as</p><p class="math-container">\[L^2 {}_{s}Y_{\ell,m} = \ell\,(\ell+1) {}_{s}Y_{\ell,m}\]</p><p>See also <a href="#SphericalFunctions.Lz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Lz</code></a>, <a href="#SphericalFunctions.L‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çä</code></a>, <a href="#SphericalFunctions.L‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çã</code></a>, <a href="#SphericalFunctions.R¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R¬≤</code></a>, <a href="#SphericalFunctions.Rz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Rz</code></a>, <a href="#SphericalFunctions.R‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çä</code></a>, <a href="#SphericalFunctions.R‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çã</code></a>, <a href="#SphericalFunctions.√∞-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>√∞</code></a>, <a href="#SphericalFunctions.√∞ÃÑ-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>√∞ÃÑ</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/8a5711af0f96a74ca90837b9fba3ee99a6b6e67f/src/operators.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.L‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T" href="#SphericalFunctions.L‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>SphericalFunctions.L‚Çä</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">L‚Çä(s, ‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì, [T])</code></pre><p>Compute the angular-momentum raising operator.  This is the standard <span>$L_+$</span> operator, familiar from basic physics, extended to work with SWSHs.  Note that this is the left Lie derivative; see <a href="#SphericalFunctions.R‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çä</code></a> for the equivalent right Lie derivative.  See <a href="#Differential-operators">the documentation</a> or <a href="../references/#Boyle_2016">Boyle</a> for more details.</p><p>We define <span>$L_+$</span> to be the raising operator for the left Lie derivative with respect to rotation about <span>$z$</span>: <span>$L_z$</span>.  By definition, this implies the commutator relation <span>$[L_z, L_+] = L_+$</span>, which allows us to derive <span>$L_+ = L_x + i\, L_y.$</span></p><p>In terms of the SWSHs, we can write the action of <span>$L_+$</span> as</p><p class="math-container">\[L_+ {}_{s}Y_{\ell,m} = \sqrt{(\ell-m)(\ell+m+1)}\, {}_{s}Y_{\ell,m+1}.\]</p><p>Consequently, the <em>mode weights</em> of a function are affected as</p><p class="math-container">\[\left\{L_+(f)\right\}_{s,\ell,m} = \sqrt{(\ell+m)(\ell-m+1)}\,\left\{f\right\}_{s,\ell,m-1}.\]</p><p>See also <a href="#SphericalFunctions.L¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L¬≤</code></a>, <a href="#SphericalFunctions.Lz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Lz</code></a>, <a href="#SphericalFunctions.L‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çã</code></a>, <a href="#SphericalFunctions.R¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R¬≤</code></a>, <a href="#SphericalFunctions.Rz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Rz</code></a>, <a href="#SphericalFunctions.R‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çä</code></a>, <a href="#SphericalFunctions.R‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çã</code></a>, <a href="#SphericalFunctions.√∞-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>√∞</code></a>, <a href="#SphericalFunctions.√∞ÃÑ-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>√∞ÃÑ</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/8a5711af0f96a74ca90837b9fba3ee99a6b6e67f/src/operators.jl#L52-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.L‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T" href="#SphericalFunctions.L‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>SphericalFunctions.L‚Çã</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">L‚Çã(s, ‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì, [T])</code></pre><p>Compute the angular-momentum lowering operator.  This is the standard <span>$L_-$</span> operator, familiar from basic physics, extended to work with SWSHs.  Note that this is the left Lie derivative; see <a href="#SphericalFunctions.R‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çã</code></a> for the equivalent right Lie derivative.  See <a href="#Differential-operators">the documentation</a> or <a href="../references/#Boyle_2016">Boyle</a> for more details.</p><p>We define <span>$L_-$</span> to be the lowering operator for the left Lie derivative with respect to rotation about <span>$z$</span>: <span>$L_z$</span>.  By definition, this implies the commutator relation <span>$[L_z, L_-] = -L_-$</span>, which allows us to derive <span>$L_- = L_x - i\, L_y.$</span></p><p>In terms of the SWSHs, we can write the action of <span>$L_-$</span> as</p><p class="math-container">\[L_- {}_{s}Y_{\ell,m} = \sqrt{(\ell+m)(\ell-m+1)}\, {}_{s}Y_{\ell,m-1}.\]</p><p>Consequently, the <em>mode weights</em> of a function are affected as</p><p class="math-container">\[\left\{L_-(f)\right\}_{s,\ell,m} = \sqrt{(\ell-m)(\ell+m+1)}\,\left\{f\right\}_{s,\ell,m+1}.\]</p><p>See also <a href="#SphericalFunctions.L¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L¬≤</code></a>, <a href="#SphericalFunctions.Lz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Lz</code></a>, <a href="#SphericalFunctions.L‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çä</code></a>, <a href="#SphericalFunctions.L‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çã</code></a>, <a href="#SphericalFunctions.R¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R¬≤</code></a>, <a href="#SphericalFunctions.Rz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Rz</code></a>, <a href="#SphericalFunctions.R‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çä</code></a>, <a href="#SphericalFunctions.R‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çã</code></a>, <a href="#SphericalFunctions.√∞-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>√∞</code></a>, <a href="#SphericalFunctions.√∞ÃÑ-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>√∞ÃÑ</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/8a5711af0f96a74ca90837b9fba3ee99a6b6e67f/src/operators.jl#L88-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.Rz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T" href="#SphericalFunctions.Rz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>SphericalFunctions.Rz</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Rz(s, ‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì, [T])</code></pre><p>Compute the <em>right</em> angular-momentum operator associated with the <span>$z$</span> direction.</p><p>This is the <span>$R_z$</span> operator, much like the <span>$L_z$</span> operator familiar from basic physics, but in terms of the right Lie derivative, and extended to work with SWSHs.  See <a href="#SphericalFunctions.Lz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Lz</code></a> for the equivalent left Lie derivative.  See <a href="#Differential-operators">the documentation</a> or <a href="../references/#Boyle_2016">Boyle</a> for more details.</p><p>In terms of the SWSHs, we can write the action of <span>$R_z$</span> as</p><p class="math-container">\[R_z {}_{s}Y_{\ell,m} = -s\, {}_{s}Y_{\ell,m}\]</p><p>Note the unfortunate sign of <span>$s$</span>, which seems to be opposite to what we expect, and arises from the choice of definition of <span>$s$</span> in the original paper by <a href="../references/#Newman_1966">Newman and Penrose</a>.</p><p>See also <a href="#SphericalFunctions.L¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L¬≤</code></a>, <a href="#SphericalFunctions.Lz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Lz</code></a>, <a href="#SphericalFunctions.L‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çä</code></a>, <a href="#SphericalFunctions.L‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çã</code></a>, <a href="#SphericalFunctions.R¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R¬≤</code></a>, <a href="#SphericalFunctions.R‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çä</code></a>, <a href="#SphericalFunctions.R‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çã</code></a>, <a href="#SphericalFunctions.√∞-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>√∞</code></a>, <a href="#SphericalFunctions.√∞ÃÑ-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>√∞ÃÑ</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/8a5711af0f96a74ca90837b9fba3ee99a6b6e67f/src/operators.jl#L155-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.R¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T" href="#SphericalFunctions.R¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>SphericalFunctions.R¬≤</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">R¬≤(s, ‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì, [T])</code></pre><p>Compute the total angular-momentum operator from <code>‚Ñì‚Çò·µ¢‚Çô</code> up to <code>‚Ñì‚Çò‚Çê‚Çì</code>.  If not present, <code>‚Ñì‚Çò·µ¢‚Çô</code> is assumed to be <code>abs(s)</code>.  The argument <code>s</code> is ignored; it is present only for consistency with other operators, and is assumed to be 0 if not present.</p><p>This is the <span>$R^2$</span> operator, much like the <span>$L^2$</span> operator familiar from basic physics, but in terms of the right Lie derivative, and extended to work with SWSHs.  It is also known as the Casimir operator, and is equal to</p><p class="math-container">\[R^2 = R_x^2 + R_y^2 + R_z^2 = \frac{R_+R_- + R_-R_+ + 2R_zR_z}{2}.\]</p><p>Note that these are the right Lie derivatives, but <span>$L^2 = R^2$</span>, where <code>L</code> is the left Lie derivative.  See <a href="#Differential-operators">the documentation</a> or <a href="../references/#Boyle_2016">Boyle</a> for more details.</p><p>In terms of the SWSHs, we can write the action of <span>$R^2$</span> as</p><p class="math-container">\[R^2 {}_{s}Y_{\ell,m} = \ell\,(\ell+1) {}_{s}Y_{\ell,m}\]</p><p>See also <a href="#SphericalFunctions.L¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L¬≤</code></a>, <a href="#SphericalFunctions.Lz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Lz</code></a>, <a href="#SphericalFunctions.L‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çä</code></a>, <a href="#SphericalFunctions.L‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çã</code></a>, <a href="#SphericalFunctions.Rz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Rz</code></a>, <a href="#SphericalFunctions.R‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çä</code></a>, <a href="#SphericalFunctions.R‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çã</code></a>, <a href="#SphericalFunctions.√∞-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>√∞</code></a>, <a href="#SphericalFunctions.√∞ÃÑ-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>√∞ÃÑ</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/8a5711af0f96a74ca90837b9fba3ee99a6b6e67f/src/operators.jl#L125-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.R‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T" href="#SphericalFunctions.R‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>SphericalFunctions.R‚Çä</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">R‚Çä(s, ‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì, [T])</code></pre><p>Compute the <em>right</em> angular-momentum raising operator.</p><p>This is the <span>$R_+$</span> operator, much like the <span>$L_+$</span> operator familiar from basic physics, but in terms of the right Lie derivative, and extended to work with SWSHs.  See <a href="#SphericalFunctions.L‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çä</code></a> for the equivalent left Lie derivative.  See <a href="#Differential-operators">the documentation</a> or <a href="../references/#Boyle_2016">Boyle</a> for more details.</p><p>We define <span>$R_+$</span> to be the raising operator for the right Lie derivative with respect to rotation about <span>$z$</span>: <span>$R_z$</span>.  By definition, this implies the commutator relation <span>$[R_z, R_+] = R_+$</span>, which allows us to derive <span>$R_+ = R_x - i\, R_y.$</span></p><p>In terms of the SWSHs, we can write the action of <span>$R_+$</span> as</p><p class="math-container">\[R_+ {}_{s}Y_{\ell,m} = \sqrt{(\ell+s)(\ell-s+1)}\, {}_{s-1}Y_{\ell,m}\]</p><p>Consequently, the <em>mode weights</em> of a function are affected as</p><p class="math-container">\[\left\{R_+(f)\right\}_{s,\ell,m} = \sqrt{(\ell+s)(\ell-s+1)}\,\left\{f\right\}_{s-1,\ell,m}.\]</p><p>Because of the unfortunate sign of <span>$s$</span> arising from the choice of definition of <span>$s$</span> in the original paper by <a href="../references/#Newman_1966">Newman and Penrose</a>, this is a <em>lowering</em> operator for <span>$s$</span>, though it really is a <em>raising</em> operator for <span>$R_z$</span>, and raises the eigenvalue of the corresponding Wigner matrix.</p><p>See also <a href="#SphericalFunctions.L¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L¬≤</code></a>, <a href="#SphericalFunctions.Lz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Lz</code></a>, <a href="#SphericalFunctions.L‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çä</code></a>, <a href="#SphericalFunctions.L‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çã</code></a>, <a href="#SphericalFunctions.R¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R¬≤</code></a>, <a href="#SphericalFunctions.Rz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Rz</code></a>, <a href="#SphericalFunctions.R‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çã</code></a>, <a href="#SphericalFunctions.√∞-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>√∞</code></a>, <a href="#SphericalFunctions.√∞ÃÑ-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>√∞ÃÑ</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/8a5711af0f96a74ca90837b9fba3ee99a6b6e67f/src/operators.jl#L181-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.R‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T" href="#SphericalFunctions.R‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>SphericalFunctions.R‚Çã</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">R‚Çã(s, ‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì, [T])</code></pre><p>Compute the <em>right</em> angular-momentum lowering operator.</p><p>This is the <span>$R_-$</span> operator, much like the <span>$L_-$</span> operator familiar from basic physics, but in terms of the right Lie derivative, and extended to work with SWSHs.  See <a href="#SphericalFunctions.L‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çã</code></a> for the equivalent left Lie derivative.  See <a href="#Differential-operators">the documentation</a> or <a href="../references/#Boyle_2016">Boyle</a> for more details.</p><p>We define <span>$R_-$</span> to be the raising operator for the right Lie derivative with respect to rotation about <span>$z$</span>: <span>$R_z$</span>.  By definition, this implies the commutator relation <span>$[R_z, R_-] = -R_-$</span>, which allows us to derive <span>$R_- = R_x + i\, R_y.$</span></p><p>In terms of the SWSHs, we can write the action of <span>$R_-$</span> as</p><p class="math-container">\[R_- {}_{s}Y_{\ell,m} = \sqrt{(\ell-s)(\ell+s+1)}\, {}_{s+1}Y_{\ell,m}\]</p><p>Consequently, the <em>mode weights</em> of a function are affected as</p><p class="math-container">\[\left\{R_-(f)\right\}_{s,\ell,m} = \sqrt{(\ell-s)(\ell+s+1)}\,\left\{f\right\}_{s+1,\ell,m}.\]</p><p>Because of the unfortunate sign of <span>$s$</span> arising from the choice of definition of <span>$s$</span> in the original paper by <a href="../references/#Newman_1966">Newman and Penrose</a>, this is a <em>raising</em> operator for <span>$s$</span>, though it really is a <em>lowering</em> operator for <span>$R_z$</span>, and lowers the eigenvalue of the corresponding Wigner matrix - though that raises the eigenvalue of the corresponding Wigner matrix.</p><p>See also <a href="#SphericalFunctions.L¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L¬≤</code></a>, <a href="#SphericalFunctions.Lz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Lz</code></a>, <a href="#SphericalFunctions.L‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çä</code></a>, <a href="#SphericalFunctions.L‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çã</code></a>, <a href="#SphericalFunctions.R¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R¬≤</code></a>, <a href="#SphericalFunctions.Rz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Rz</code></a>, <a href="#SphericalFunctions.R‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çä</code></a>, <a href="#SphericalFunctions.√∞-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>√∞</code></a>, <a href="#SphericalFunctions.√∞ÃÑ-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>√∞ÃÑ</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/8a5711af0f96a74ca90837b9fba3ee99a6b6e67f/src/operators.jl#L222-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.√∞-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T" href="#SphericalFunctions.√∞-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>SphericalFunctions.√∞</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">√∞(s, ‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì, [T])</code></pre><p>Compute coefficients for the spin-raising operator <span>$\eth$</span>.</p><p>This operator was originally defined by <a href="../references/#Newman_1966">Newman and Penrose</a>, but is more completely defined by <a href="../references/#Boyle_2016">Boyle</a>.  It is identical to <a href="#SphericalFunctions.R‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çã</code></a>.  Refer to that function&#39;s documentation for more details.</p><p>By definition, the spin-raising operator satisfies the commutator relation <span>$[S, \eth] = \eth$</span> (where <span>$S$</span> is the spin operator, which just multiplies the function by its spin). In terms of the SWSHs, we can write the action of <span>$\eth$</span> as</p><p class="math-container">\[    \eth {}_{s}Y_{\ell,m} = \sqrt{(\ell-s)(\ell+s+1)} {}_{s+1}Y_{\ell,m}.\]</p><p>Consequently, the <em>mode weights</em> of a function are affected as</p><p class="math-container">\[\left\{\eth f\right\}_{s,\ell,m} = \sqrt{(\ell-s)(\ell+s+1)}\,\left\{f\right\}_{s+1,\ell,m}.\]</p><p>See also <a href="#SphericalFunctions.√∞ÃÑ-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>√∞ÃÑ</code></a>,  <a href="#SphericalFunctions.L¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L¬≤</code></a>, <a href="#SphericalFunctions.Lz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Lz</code></a>, <a href="#SphericalFunctions.L‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çä</code></a>, <a href="#SphericalFunctions.L‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çã</code></a>, <a href="#SphericalFunctions.R¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R¬≤</code></a>, <a href="#SphericalFunctions.Rz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Rz</code></a>, <a href="#SphericalFunctions.R‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çä</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/8a5711af0f96a74ca90837b9fba3ee99a6b6e67f/src/operators.jl#L265-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.√∞ÃÑ-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T" href="#SphericalFunctions.√∞ÃÑ-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>SphericalFunctions.√∞ÃÑ</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">√∞ÃÑ(s, ‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì, [T])</code></pre><p>Compute coefficients for the spin-lowering operator <span>$\bar{\eth}$</span>.</p><p>This operator was originally defined by <a href="../references/#Newman_1966">Newman and Penrose</a>, but is more completely defined by <a href="../references/#Boyle_2016">Boyle</a>.  It is opposite to <a href="#SphericalFunctions.R‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çä</code></a> ‚Äî meaning that <span>$\bar{\eth} = -R‚Çä$</span>.  Refer to that function&#39;s documentation for more details.</p><p>By definition, the spin-lowering operator satisfies the commutator relation <span>$[S, \bar{\eth}] = -\bar{\eth}$</span> (where <span>$S$</span> is the spin operator, which just multiplies the function by its spin).  In terms of the SWSHs, we can write the action of <span>$\bar{\eth}$</span> as</p><p class="math-container">\[\bar{\eth} {}_{s}Y_{\ell,m} = -\sqrt{(\ell+s)(\ell-s+1)} {}_{s-1}Y_{\ell,m}.\]</p><p>Consequently, the <em>mode weights</em> of a function are affected as</p><p class="math-container">\[\left\{\bar{\eth} f\right\}_{s,\ell,m}
= -\sqrt{(\ell-s)(\ell+s+1)}\,\left\{f\right\}_{s+1,\ell,m}.\]</p><p>See also <a href="#SphericalFunctions.√∞-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>√∞</code></a>,  <a href="#SphericalFunctions.L¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L¬≤</code></a>, <a href="#SphericalFunctions.Lz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Lz</code></a>, <a href="#SphericalFunctions.L‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çä</code></a>, <a href="#SphericalFunctions.L‚Çã-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>L‚Çã</code></a>, <a href="#SphericalFunctions.R¬≤-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R¬≤</code></a>, <a href="#SphericalFunctions.Rz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>Rz</code></a>, <a href="#SphericalFunctions.R‚Çä-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>R‚Çä</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/8a5711af0f96a74ca90837b9fba3ee99a6b6e67f/src/operators.jl#L294-L318">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>In fact, we can define the left and right Lie derivative operators quite generally, for functions on <em>any</em> Lie group and for the corresponding Lie algebra.  And in all cases (at least for finite-dimensional Lie algebras) we obtain the same commutator relations. The only potential difference is that it may not make sense to use the coefficient <span>$i/2$</span> in general; it was chosen here for consistency with the standard angular-momentum operators. If that coefficient is changed in the definitions of the Lie derivatives, the only change to the commutator relations would the substitution of that coefficient.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>A technical note about the integrals above: the integrals should be taken over the appropriate space and with the appropriate weight such that the SWSHs are orthonormal.  In general, this integral should be over <span>$\mathrm{Spin}(3)$</span> and weighted by <span>$1/2\pi$</span> so that the result will be either <span>$0$</span> or <span>$1$</span>; in general the SWSHs are not truly orthonormal when integrated over an <span>$S^2$</span> subspace (nor even is the integral invariant). However, if we know that the spins are the same in both cases, it <em>is</em> possible to integrate over an <span>$S^2$</span> subspace.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sYlm/">¬´ <span>${}_{s}Y_{\ell,m}$</span> functions</a><a class="docs-footer-nextpage" href="../utilities/">Utilities ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Monday 11 March 2024 17:07">Monday 11 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
