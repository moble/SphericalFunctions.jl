<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>s-SHT Transformations · SphericalFunctions.jl</title><meta name="title" content="s-SHT Transformations · SphericalFunctions.jl"/><meta property="og:title" content="s-SHT Transformations · SphericalFunctions.jl"/><meta property="twitter:title" content="s-SHT Transformations · SphericalFunctions.jl"/><meta name="description" content="Documentation for SphericalFunctions.jl."/><meta property="og:description" content="Documentation for SphericalFunctions.jl."/><meta property="twitter:description" content="Documentation for SphericalFunctions.jl."/><meta property="og:url" content="https://moble.github.io/SphericalFunctions.jl/stable/transformations/"/><meta property="twitter:url" content="https://moble.github.io/SphericalFunctions.jl/stable/transformations/"/><link rel="canonical" href="https://moble.github.io/SphericalFunctions.jl/stable/transformations/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../assets/extras.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SphericalFunctions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href><span>$s$</span>-SHT Transformations</a><ul class="internal"><li><a class="tocitem" href="#SSHT-objects"><span><code>SSHT</code> objects</span></a></li><li><a class="tocitem" href="#Pixelizations"><span>Pixelizations</span></a></li><li><a class="tocitem" href="#Quadrature-weights"><span>Quadrature weights</span></a></li></ul></li><li><a class="tocitem" href="../wigner_matrices/">Wigner&#39;s <span>$𝔇$</span> and <span>$d$</span> matrices</a></li><li><a class="tocitem" href="../sYlm/"><span>${}_{s}Y_{\ell,m}$</span> functions</a></li><li><a class="tocitem" href="../operators/">Differential operators</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../internal/">Internal functions</a></li><li><a class="tocitem" href="../functions/">Complete function list</a></li></ul></li><li><span class="tocitem">Conventions</span><ul><li><a class="tocitem" href="../conventions/conventions/">Conventions</a></li><li><a class="tocitem" href="../conventions/comparisons/">Comparisons</a></li></ul></li><li><span class="tocitem">Notes</span><ul><li><a class="tocitem" href="../notes/H_recursions/">Algorithm for computing <span>$H$</span></a></li><li><a class="tocitem" href="../notes/sampling_theorems/">Sampling theorems and transformations of spin-weighted spherical harmonics</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href><span>$s$</span>-SHT Transformations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href><span>$s$</span>-SHT Transformations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/moble/SphericalFunctions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/moble/SphericalFunctions.jl/blob/main/docs/src/transformations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="s-SHT-Transformations"><a class="docs-heading-anchor" href="#s-SHT-Transformations"><span>$s$</span>-SHT Transformations</a><a id="s-SHT-Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#s-SHT-Transformations" title="Permalink"></a></h1><p>One important capability of this package is the transformation between the two representations of a spin-weighted spherical function:</p><ol><li>Values <code>f</code> of the function evaluated on a set of points or &quot;pixels&quot; in the domain of the function.</li><li>Values <code>f̃</code> of the mode weights (coefficients) of an expansion in the standard spin-weighted spherical-harmonic basis.</li></ol><p>In the literature, the transformation <code>f</code> ↦ <code>f̃</code> is usually called &quot;analysis&quot; or <code>map2salm</code>, while the inverse transformation <code>f</code> ↦ <code>f̃</code> is called &quot;synthesis&quot; or <code>salm2map</code>.  These are both referred to as spin-spherical-harmonic transforms, or <span>$s$</span>-SHTs.</p><p>To describe the values of a spin-<span>$s$</span> function up to some maximum angular resolution <span>$\ell_\mathrm{max}$</span>, we need <span>$(\ell_\mathrm{max}+1)^2 - s^2$</span> mode weights.  We assume throughout that the values <code>f̃</code> are stored as</p><pre><code class="language-julia hljs">f̃ = [mode_weight(ℓ, m) for ℓ ∈ abs(s):ℓₘₐₓ for m ∈ -ℓ:ℓ]</code></pre><p>(Here, <code>mode_weight</code> is a made-up function intended to provide a schematic.)  In particular, the <span>$m$</span> index varies most rapidly, and the <span>$\ell$</span> index varies most slowly.  Correspondingly, there must be <em>at least</em> <span>$(\ell_\mathrm{max}+1)^2 - s^2$</span> function values <code>f</code>.  However, some <span>$s$</span>-SHT algorithms require more function values — usually by a factor of 2 or 4 — trading off between speed and memory usage.</p><p>The <code>SSHT</code> object implements these transformations, storing pre-computed constants and pre-allocated workspace for the transformations.  The interface is designed to be similar to that of <code>FFTW.jl</code>, whereby an <code>SSHT</code> object <code>𝒯</code> can be used to perform the transformation as either</p><pre><code class="language-julia hljs">f = 𝒯 * f̃</code></pre><p>or</p><pre><code class="language-julia hljs">f̃ = 𝒯 \ f</code></pre><p>Currently, there are three algorithms implemented, each having different advantages and disadvantages:</p><ol><li>The &quot;Direct&quot; algorithm (introduced here for the first time), which is the default, but should only be used up to <span>$\ell_\mathrm{max} \lesssim 50$</span> because its intermediate storage requirements scale as <span>$\ell_\mathrm{max}^4$</span>.  This algorithm is the fastest for small <span>$\ell_\mathrm{max}$</span>, it can be used with arbitrary (non-degenerate) pixelizations, and achieves optimal dimensionality.</li><li>The &quot;Minimal&quot; algorithm due to <a href="../references/#Elahi_2018">Elahi <em>et al.</em> [2]</a>, with some minor improvements.  This algorithm is fast and — as the name implies — also achieves optimal dimensionality, and its storage scales as <span>$\ell_\mathrm{max}^3$</span>.  However, its pixelization is restricted, and its accuracy at very high <span>$\ell_\mathrm{max}$</span> is not as good as the &quot;RS&quot; algorithm.  The algorithm itself is not actually fully specified by Elahi et al., and leaves out some relatively simple improvements, so I have had to take some liberties with my interpretation.</li><li>The &quot;RS&quot; algorithm due to <a href="../references/#Reinecke_2013">Reinecke and Seljebotn [3]</a>.  This forms the basis for the <a href="https://gitlab.mpcdf.mpg.de/mtr/libsharp"><code>libsharp</code></a> and <a href="https://gitlab.mpcdf.mpg.de/mtr/ducc#duccsht"><code>ducc.sht</code></a> packages.  It requires pixelizations on &quot;iso-latitude rings&quot;, and does not achieve optimal dimensionality.  However, it is very fast, and its accuracy is excellent at extremely high <span>$\ell_\mathrm{max}$</span>.</li></ol><h2 id="SSHT-objects"><a class="docs-heading-anchor" href="#SSHT-objects"><code>SSHT</code> objects</a><a id="SSHT-objects-1"></a><a class="docs-heading-anchor-permalink" href="#SSHT-objects" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.SSHT" href="#SphericalFunctions.SSHT"><code>SphericalFunctions.SSHT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Supertype of storage for spin-spherical-harmonic transforms</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/ssht.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.SSHT-Tuple{Any, Any}" href="#SphericalFunctions.SSHT-Tuple{Any, Any}"><code>SphericalFunctions.SSHT</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SSHT(s, ℓₘₐₓ; [method=&quot;Direct&quot;], [T=Float64], [kwargs...])</code></pre><p>Construct an <code>SSHT</code> object to transform between spin-weighted spherical-harmonic mode weights and function values — performing an <span>$s$</span>-SHT.</p><p>This object behaves similarly to an <code>AbstractFFTs.Plan</code> object — specifically in the ability to use the semantics of algebra to perform transforms.  For example, if the function values are stored as a vector <code>f</code>, the mode weights as <code>f̃</code>, and the <code>SSHT</code> as <code>𝒯</code>, then we can compute the function values from the mode weights as</p><pre><code class="nohighlight hljs">f = 𝒯 * f̃</code></pre><p>or solve for the mode weights from the function values as</p><pre><code class="nohighlight hljs">f̃ = 𝒯 \ f</code></pre><p>The first dimensions of <code>f̃</code> must index the mode weights (as usual, for <code>ℓ∈abs(s):ℓₘₐₓ</code> and <code>m∈-ℓ:ℓ</code>) and the first index of <code>f</code> must index the locations at which the function is evaluated.  Any following dimensions will be broadcast over.  Note that certain types will broadcast using Julia threads, while others will broadcast using BLAS threads.  The relevant number of threads must be set appropriately.</p><p>Certain <code>SSHT</code> types (currently, only <code>Minimal</code> and <code>Direct</code>) also have an option to <em>always</em> act in place — meaning that they simply re-use the input storage, even when used in an expression like <code>𝒯 \ f</code>.  The option must be passed as the <code>inplace</code> argument to the constructors, and is part of the type of the resulting object.  Regardless of the value of that option, for those types where the option exists, it is also possible to use <code>mul!</code> and <code>ldiv!</code> from the <code>LinearAlgebra</code> package to force operation in place.</p><p>Note that different algorithms require different &quot;pixelizations&quot;, or sets of <code>Rotor</code>s on which to evaluate the function.  These can be obtained from the <code>SSHT</code> object using the <a href="#SphericalFunctions.pixels"><code>pixels</code></a> and <a href="#SphericalFunctions.rotors"><code>rotors</code></a> functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/ssht.jl#L5-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.pixels" href="#SphericalFunctions.pixels"><code>SphericalFunctions.pixels</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pixels(𝒯)</code></pre><p>Return the spherical coordinates (θ, ϕ) on which the spin-weighted spherical harmonics are evaluated.  See also <a href="#SphericalFunctions.rotors"><code>rotors</code></a>, which provides the actual <code>Rotor</code>s on which they are evaluated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/ssht.jl#L53-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.rotors" href="#SphericalFunctions.rotors"><code>SphericalFunctions.rotors</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotors(𝒯)</code></pre><p>Return the <code>Rotor</code>s on which the spin-weighted spherical harmonics are evaluated.  See also <a href="#SphericalFunctions.pixels"><code>pixels</code></a>, which provides the corresponding spherical coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/ssht.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.SSHTDirect" href="#SphericalFunctions.SSHTDirect"><code>SphericalFunctions.SSHTDirect</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SSHTDirect(s, ℓₘₐₓ; decomposition=LinearAlgebra.qr, T=Float64, Rθϕ=golden_ratio_spiral_rotors(s, ℓₘₐₓ, T), inplace=true)</code></pre><p>Construct an <span>$s$</span>-SHT object that uses the &quot;Direct&quot; method; see <a href="../internal/#ₛ𝐘"><code>ₛ𝐘</code></a> for details about the method and optional arguments.  Also see <a href="#SphericalFunctions.SSHT"><code>SSHT</code></a> for general information about how to use these objects.</p><p>By default, this uses precisely optimal sampling — meaning that the number of points on which the function is evaluated, represented by <code>Rθϕ</code>, is <em>equal to</em> the number of modes.  However, it is equally possible to evaluate on <em>more</em> points than there are modes.  This can be useful, for example, when processing multiple fields with different spin weights; the function could be evaluated on points appropriate for the lowest value of <span>$|s|$</span>, and therefore could also be used to solve for fields of all other spin weights.</p><p>Note that in-place operation is possible for this type when the length of the input <code>Rθϕ</code> is equal to the number of modes given <code>s</code> and <code>ℓₘₐₓ</code> — and is the default behavior when possible.  See <a href="#SphericalFunctions.SSHT"><code>SSHT</code></a> for description of in-place operation.</p><p>This method is typically better than other current implementations for <span>$ℓₘₐₓ ≲ 24$</span>, both in terms of speed and accuracy.  However, this advantage quickly falls away.  A warning will be issued if <code>ℓₘₐₓ</code> is greater than about 64, because this method is not likely to be the most efficient or most accurate choice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/ssht/direct.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.SSHTMinimal" href="#SphericalFunctions.SSHTMinimal"><code>SphericalFunctions.SSHTMinimal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Storage for Minimal spin-spherical-harmonic transform</p><p>The Minimal algorithm was described by <a href="../references/#Elahi_2018">Elahi et al.</a>, and allows for the minimal number of function samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/ssht/minimal.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.SSHTMinimal-Union{Tuple{TT}, Tuple{Any, Any}} where TT" href="#SphericalFunctions.SSHTMinimal-Union{Tuple{TT}, Tuple{Any, Any}} where TT"><code>SphericalFunctions.SSHTMinimal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SSHTMinimal(s, ℓₘₐₓ; kwargs...)</code></pre><p>Construct a <code>SSHTMinimal</code> object directly.  This may also be achieved by calling the main <code>SSHT</code> function with the same keywords, along with <code>method=&quot;Minimal&quot;</code>.</p><p>This object uses the algorithm described by <a href="../references/#Elahi_2018">Elahi et al</a>.</p><p>The basic floating-point number type may be adjusted with the keyword argument <code>T</code>, which defaults to <code>Float64</code>.</p><p>The SSHs are evaluated on a series of &quot;rings&quot; at constant colatitude.  Their locations are specified by the <code>θ</code> keyword argument, which defaults to <a href="#SphericalFunctions.sorted_rings-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>sorted_rings(s, ℓₘₐₓ, T)</code></a>.  The first element of <code>θ</code> is the colatitude of the smallest ring (containing <span>$2s+1$</span> elements), and so on to the last element of <code>θ</code>, which is the colatitude of the largest ring (containing <span>$2ℓₘₐₓ+1$</span> elements).</p><p>Whenever <code>T</code> is either <code>Float64</code> or <code>Float32</code>, the keyword arguments <code>plan_fft_flags</code> and <code>plan_fft_timelimit</code> may also be useful for obtaining more efficient FFTs.  They default to <code>FFTW.ESTIMATE</code> and <code>Inf</code>, respectively.  They are passed to <a href="https://juliamath.github.io/AbstractFFTs.jl/stable/api/#AbstractFFTs.plan_fft"><code>AbstractFFTs.plan_fft</code></a>.</p><p>Note that, because this algorithm achieves optimal dimensionality, the transformation will be performed in place by default.  If this is not desired, pass the keyword argument <code>inplace=false</code>.  This will cause the algorithm to copy the input and perform in-place transformation on that copy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/ssht/minimal.jl#L72-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.SSHTRS" href="#SphericalFunctions.SSHTRS"><code>SphericalFunctions.SSHTRS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Storage for  spin-spherical-harmonic transform</p><p>The algorithm was described in by <a href="../references/#Reinecke_2013">Reinecke and Seljebotn</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/ssht/rs.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.SSHTRS-Union{Tuple{TT}, Tuple{Any, Any}} where TT" href="#SphericalFunctions.SSHTRS-Union{Tuple{TT}, Tuple{Any, Any}} where TT"><code>SphericalFunctions.SSHTRS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SSHTRS(s, ℓₘₐₓ; kwargs...)</code></pre><p>Construct a <code>SSHTRS</code> object directly.  This may also be achieved by calling the main <code>SSHT</code> function with the same keywords, along with <code>method=&quot;RS&quot;</code>.</p><p>This object uses the algorithm described by <a href="../references/#Reinecke_2013">Reinecke and Seljebotn</a>.</p><p>The basic floating-point number type may be adjusted with the keyword argument <code>T</code>, which defaults to <code>Float64</code>.</p><p>The SSHs are evaluated on a series of &quot;rings&quot; at constant colatitude.  Their locations are specified by the <code>θ</code> keyword argument, which defaults to <code>fejer1_rings(2ℓₘₐₓ+1, T)</code>.  If this is changed, the user should also provide the corresponding <code>quadrature_weights</code> argument — the default being <code>fejer1(length(θ), T)</code>.</p><p>On each of these rings, an FFT is performed.  To reach the band limit of <span>$m = ± ℓₘₐₓ$</span>, the number of points along each ring must therefore be <em>at least</em> <span>$2ℓₘₐₓ+1$</span>, but may be greater.  For example, if <span>$2ℓₘₐₓ+1$</span> does not factorize neatly into a product of small primes, it may be preferable to use <span>$2ℓₘₐₓ+2$</span> points along each ring.  (In that case, whenever <code>ℓₘₐₓ</code> is 1 less than a power of 2, the number of points will be exactly a power of 2, which is usually particularly efficient.)  The number of points on each ring can be modified independently, if given as a vector with the same length as <code>θ</code>, or as a single number which is assumed to be the same for all rings.</p><p>Whenever <code>T</code> is either <code>Float64</code> or <code>Float32</code>, the keyword arguments <code>plan_fft_flags</code> and <code>plan_fft_timelimit</code> may also be useful for obtaining more efficient FFTs.  They default to <code>FFTW.ESTIMATE</code> and <code>Inf</code>, respectively.  They are passed to <a href="https://juliamath.github.io/AbstractFFTs.jl/stable/api/#AbstractFFTs.plan_fft"><code>AbstractFFTs.plan_fft</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/ssht/rs.jl#L43-L77">source</a></section></article><h2 id="Pixelizations"><a class="docs-heading-anchor" href="#Pixelizations">Pixelizations</a><a id="Pixelizations-1"></a><a class="docs-heading-anchor-permalink" href="#Pixelizations" title="Permalink"></a></h2><p>The algorithms implemented here require pixelizations.  While the &quot;Direct&quot; algorithm can be used with arbitrary pixelizations, the &quot;Minimal&quot; and &quot;RS&quot; algorithms require more specific choices, as noted in their docstrings.</p><p>Typically, &quot;pixelization&quot; refers exclusively to a choice of points on the sphere 𝕊² at which to compute function values.  Of course, as mentioned <a href="../references/#Boyle_2016">elsewhere</a>, it is not <em>technically possible</em> to define spin-weighted functions as functions of a point on 𝕊² alone; we also need some sense of reference direction in the tangent space.  Quite generally, we can define spin-weighted functions on the group 𝐒𝐎(3) or 𝐒𝐩𝐢𝐧(3), so we will also refer to a choice of a set of points in 𝐒𝐩𝐢𝐧(3) (which is essentially the group of unit quaternions) as a &quot;pixelization&quot;.  However, assuming spherical coordinates, a choice of <em>coordinates</em> on the sphere almost everywhere induces a choice of the reference direction in the tangent space, so it is <em>almost</em> possible to define pixelizations just in terms of points on 𝕊².  But using spherical coordinates is actually enough to fully specify the pixelization, because the degeneracies at the poles also allow us to define the reference direction.</p><p>In principle, we could be concerned about the choice of reference direction in the tangent space.  That is, we might expect to care about pixelizations over 𝕊³.  However, we are dealing with spin-weighted functions, which are eigenfunctions of a final rotation about the reference direction.  This means that once we choose any reference direction at each point, we know the function values for any other reference direction at those points.  In particular, an important property of a pixelization is the condition number of the transformation matrix between the function values and the mode weights.  If we rotate the reference direction at a single point, this is equivalent to multiplying the matrix by a diagonal matrix with entries of 1 everywhere except the entry corresponding to that point, where the entry is some complex phase.  This does not change the condition number of the matrix, so we can ignore the choice of reference direction at every point.  For other situations, where we might care about the choice of reference direction, it might be interesting to consider <a href="https://github.com/moble/superfibonacci">this work by Marc Alexa</a>, and references therein.</p><p>Interesting discussions of various pixelizations and metrics can be found in <a href="../references/#SaffKuijlaars_1997">Saff and Kuijlaars (1997)</a> and <a href="../references/#BrauchartGrabner_2015">Brauchart and Grabner (2015)</a>, as well as blog posts <a href="https://web.archive.org/web/20220303150307/https://www.maths.unsw.edu.au/about/distributing-points-sphere">here</a> and <a href="https://extremelearning.com.au/how-to-evenly-distribute-points-on-a-sphere-more-effectively-than-the-canonical-fibonacci-lattice/">here</a>. Note that the &quot;equal-area&quot; pixelizations of <a href="https://healpix.sourceforge.io/">Healpix</a> are very restrictive—only being available for very specific numbers of points—and do not provide any obvious advantages over the more flexible pixelizations available here.</p><p>The various pixelizations may be computed as follows:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.clenshaw_curtis_rings-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T" href="#SphericalFunctions.clenshaw_curtis_rings-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T"><code>SphericalFunctions.clenshaw_curtis_rings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clenshaw_curtis_rings(N, [T=Float64])</code></pre><p>Values of the colatitude coordinate (<span>$θ$</span>) appropriate for quadrature by the Clenshaw-Curtis rule, using weights provided by <a href="#SphericalFunctions.clenshaw_curtis-Union{Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:AbstractFloat"><code>clenshaw_curtis</code></a>.</p><p>Note that the first argument to this function is <code>N</code>, rather than the <code>ℓₘₐₓ</code> used in some other functions.  For spin-weighted spherical harmonics, you may want to use <code>N=2ℓₘₐₓ+1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/pixelizations.jl#L140-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.fejer1_rings-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T" href="#SphericalFunctions.fejer1_rings-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T"><code>SphericalFunctions.fejer1_rings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fejer1_rings(N, [T=Float64])</code></pre><p>Values of the colatitude coordinate (<span>$θ$</span>) appropriate for quadrature by Fejér&#39;s first rule, using weights provided by <a href="#SphericalFunctions.fejer1-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:AbstractFloat"><code>fejer1</code></a>.</p><p>Note that the first argument to this function is <code>N</code>, rather than the <code>ℓₘₐₓ</code> used in some other functions.  For spin-weighted spherical harmonics, you may want to use <code>N=2ℓₘₐₓ+1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/pixelizations.jl#L106-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.fejer2_rings-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T" href="#SphericalFunctions.fejer2_rings-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T"><code>SphericalFunctions.fejer2_rings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fejer2_rings(N, [T=Float64])</code></pre><p>Values of the colatitude coordinate (<span>$θ$</span>) appropriate for quadrature by Fejér&#39;s second rule, using weights provided by <a href="#SphericalFunctions.fejer2-Union{Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:AbstractFloat"><code>fejer2</code></a>.</p><p>Note that the first argument to this function is <code>N</code>, rather than the <code>ℓₘₐₓ</code> used in some other functions.  For spin-weighted spherical harmonics, you may want to use <code>N=2ℓₘₐₓ+1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/pixelizations.jl#L123-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.golden_ratio_spiral_pixels-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T" href="#SphericalFunctions.golden_ratio_spiral_pixels-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>SphericalFunctions.golden_ratio_spiral_pixels</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">golden_ratio_spiral_pixels(s, ℓₘₐₓ, [T=Float64])</code></pre><p>Cover the sphere 𝕊² with pixels generated by the golden-ratio spiral. Successive pixels are separated by the azimuthal angle <span>$Δϕ = 2π(2-φ)$</span>, and are uniformly distributed in <span>$\cos θ$</span>.</p><p>This is also known as the &quot;Fibonacci sphere&quot; or &quot;Fibonacci lattice&quot;.</p><p>Visually, this is a very reasonable-looking pixelization, with fairly uniform distance between neighbors, and approximate isotropy.  No two pixels will share the same values of either <span>$θ$</span> or <span>$ϕ$</span>.  Also note that no point is present on either the North or South poles.</p><p>The returned quantity is a vector of 2-SVectors providing the spherical coordinates of each pixel.  See also <a href="#SphericalFunctions.golden_ratio_spiral_rotors-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>golden_ratio_spiral_rotors</code></a> for the corresponding <code>Rotor</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/pixelizations.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.golden_ratio_spiral_rotors-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T" href="#SphericalFunctions.golden_ratio_spiral_rotors-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>SphericalFunctions.golden_ratio_spiral_rotors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">golden_ratio_spiral_rotors(s, ℓₘₐₓ, [T=Float64])</code></pre><p>Cover the sphere 𝕊² with pixels generated by the golden-ratio spiral.</p><p>See <a href="#SphericalFunctions.golden_ratio_spiral_pixels-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>golden_ratio_spiral_pixels</code></a> for more detailed explanation.  The quantity returned by this function is a vector of <code>Rotor</code>s providing each pixel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/pixelizations.jl#L31-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.sorted_ring_pixels-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T" href="#SphericalFunctions.sorted_ring_pixels-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>SphericalFunctions.sorted_ring_pixels</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sorted_ring_pixels(s, ℓₘₐₓ, [T=Float64])</code></pre><p>Cover the sphere 𝕊² with <span>$(ℓₘₐₓ+1)²-s²$</span> pixels distributed in rings provided by <a href="#SphericalFunctions.sorted_rings-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>sorted_rings</code></a>; see that function&#39;s documentation for more description.</p><p>The returned quantity is a vector of 2-SVectors containing the spherical coordinates of each pixel.  See also <a href="#SphericalFunctions.sorted_ring_rotors-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>sorted_ring_rotors</code></a> for the corresponding <code>Rotor</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/pixelizations.jl#L72-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.sorted_ring_rotors-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T" href="#SphericalFunctions.sorted_ring_rotors-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>SphericalFunctions.sorted_ring_rotors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sorted_ring_rotors(s, ℓₘₐₓ, [T=Float64])</code></pre><p>Cover the sphere 𝕊² with <span>$(ℓₘₐₓ+1)²-s²$</span> pixels distributed in rings provided by <a href="#SphericalFunctions.sorted_rings-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>sorted_rings</code></a>; see that function&#39;s documentation for more description.</p><p>The returned quantity is a vector of <code>Rotor</code>s.  See also <a href="#SphericalFunctions.sorted_ring_rotors-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>sorted_ring_rotors</code></a> for the corresponding spherical coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/pixelizations.jl#L92-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.sorted_rings-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T" href="#SphericalFunctions.sorted_rings-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>SphericalFunctions.sorted_rings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sorted_rings(s, ℓₘₐₓ, [T=Float64])</code></pre><p>Compute locations of a series of rings labelled by <span>$j ∈ |s|:ℓₘₐₓ$</span> (analogous to <span>$ℓ$</span>), where each ring will contain <span>$k = 2j+1$</span> (analogous to <span>$m$</span>) pixels distributed evenly around the ring.  These rings are then sorted, so that the ring with the most pixels (<span>$j = ℓₘₐₓ$</span>) is closest to the equator, and the next-largest ring is placed just above or below the equator (depending on the sign of <span>$s$</span>), the next just below or above, and so on.  This is generally a fairly good first guess when minimizing the condition number of matrices used to solve for mode weights from function values.  In particular, I use this to initialize the Minimal algorithm, which is then fed into an optimizer to fine-tune the positions of the rings.</p><p>This function does not provide the individual pixels; it just provides the colatitude values of the rings on which the pixels will be placed.  The pixels themselves are provided by <a href="#SphericalFunctions.sorted_ring_pixels-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>sorted_ring_pixels</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/pixelizations.jl#L43-L60">source</a></section></article><h2 id="Quadrature-weights"><a class="docs-heading-anchor" href="#Quadrature-weights">Quadrature weights</a><a id="Quadrature-weights-1"></a><a class="docs-heading-anchor-permalink" href="#Quadrature-weights" title="Permalink"></a></h2><p>The &quot;RS&quot; algorithm requires quadrature weights corresponding to the input pixelization.  Though there is a working default choice, it is possible to use others.  There are several that are currently implemented, along with their corresponding pixelizations:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.clenshaw_curtis-Union{Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:AbstractFloat" href="#SphericalFunctions.clenshaw_curtis-Union{Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:AbstractFloat"><code>SphericalFunctions.clenshaw_curtis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clenshaw_curtis(n, [T])</code></pre><p>Compute <code>n</code> weights for the Clenshaw-Curtis rule, corresponding to <code>n</code> evenly spaced nodes from 0 to π inclusive.  That is, the nodes are located at</p><p class="math-container">\[\theta_k = k \frac{\pi}{n-1} \quad k=0, \ldots, n-1.\]</p><p>This function uses <a href="../references/#Waldvogel_2006">Waldvogel&#39;s method</a>.</p><p>The type <code>T</code> may be any <code>AbstractFloat</code>, but defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/weights.jl#L88-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.fejer1-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:AbstractFloat" href="#SphericalFunctions.fejer1-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:AbstractFloat"><code>SphericalFunctions.fejer1</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fejer1(n, [T])</code></pre><p>Compute <code>n</code> weights for Fejér&#39;s first rule, corresponding to <code>n</code> evenly spaced nodes from 0 to π inclusive.  That is, the nodes are located at</p><p class="math-container">\[\theta_k = k \frac{\pi}{n-1} \quad k=0, \ldots, n-1.\]</p><p>This function uses <a href="../references/#Waldvogel_2006">Waldvogel&#39;s method</a>.</p><p>The type <code>T</code> may be any <code>AbstractFloat</code>, but defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/weights.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.fejer2-Union{Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:AbstractFloat" href="#SphericalFunctions.fejer2-Union{Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:AbstractFloat"><code>SphericalFunctions.fejer2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fejer2(n, [T])</code></pre><p>Compute <code>n</code> weights for Fejér&#39;s second rule, corresponding to <code>n</code> evenly spaced nodes between 0 and π exclusive.  That is, the nodes are located at</p><p class="math-container">\[\theta_k = k \frac{\pi}{n+1} \quad k=1, \ldots, n.\]</p><p>This function uses <a href="../references/#Waldvogel_2006">Waldvogel&#39;s method</a>.  However, contrary to Waldvogel&#39;s notation, this routine <em>does not</em> include the weight corresponding to the ϑ=0 or π nodes, which both have weight 0.</p><p>The type <code>T</code> may be any <code>AbstractFloat</code>, but defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/7c9edabaac1d41114284bf52d920530a8de097f3/src/weights.jl#L36-L51">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../wigner_matrices/">Wigner&#39;s <span>$𝔇$</span> and <span>$d$</span> matrices »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 15 January 2025 04:06">Wednesday 15 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
