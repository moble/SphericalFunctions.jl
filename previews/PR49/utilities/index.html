<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Utilities ¬∑ SphericalFunctions.jl</title><meta name="title" content="Utilities ¬∑ SphericalFunctions.jl"/><meta property="og:title" content="Utilities ¬∑ SphericalFunctions.jl"/><meta property="twitter:title" content="Utilities ¬∑ SphericalFunctions.jl"/><meta name="description" content="Documentation for SphericalFunctions.jl."/><meta property="og:description" content="Documentation for SphericalFunctions.jl."/><meta property="twitter:description" content="Documentation for SphericalFunctions.jl."/><meta property="og:url" content="https://moble.github.io/SphericalFunctions.jl/stable/utilities/"/><meta property="twitter:url" content="https://moble.github.io/SphericalFunctions.jl/stable/utilities/"/><link rel="canonical" href="https://moble.github.io/SphericalFunctions.jl/stable/utilities/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SphericalFunctions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../transformations/"><span>$s$</span>-SHT Transformations</a></li><li><a class="tocitem" href="../wigner_matrices/">Wigner&#39;s <span>$ùîá$</span> and <span>$d$</span> matrices</a></li><li><a class="tocitem" href="../sYlm/"><span>${}_{s}Y_{\ell,m}$</span> functions</a></li><li><a class="tocitem" href="../operators/">Differential operators</a></li><li class="is-active"><a class="tocitem" href>Utilities</a><ul class="internal"><li><a class="tocitem" href="#Complex-powers"><span>Complex powers</span></a></li><li><a class="tocitem" href="#Sizes-of-and-indexing-into-ùîá,-d,-and-Y-data"><span>Sizes of and indexing into <span>$ùîá$</span>, <span>$d$</span>, and <span>$Y$</span> data</span></a></li><li><a class="tocitem" href="#Combinatorics"><span>Combinatorics</span></a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../internal/">Internal functions</a></li><li><a class="tocitem" href="../functions/">Complete function list</a></li></ul></li><li><span class="tocitem">Notes</span><ul><li><a class="tocitem" href="../notes/H_recursions/">Algorithm for computing <span>$H$</span></a></li><li><a class="tocitem" href="../notes/sampling_theorems/">Sampling theorems and transformations of spin-weighted spherical harmonics</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Utilities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Utilities</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/moble/SphericalFunctions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/moble/SphericalFunctions.jl/blob/main/docs/src/utilities.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h1><p>While not usually the star of the show, the following utilities can be quite helpful for actually using the rest of the code.</p><h2 id="Complex-powers"><a class="docs-heading-anchor" href="#Complex-powers">Complex powers</a><a id="Complex-powers-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-powers" title="Permalink"></a></h2><p>One common task we find when working with spherical functions is the computation of a range of integer powers of some complex number ‚Äî so much so that it can be best to pre-compute the powers and cache their values.  While a naive approach is generally quite accurate, and reasonably fast, we can do a little better with a specialized routine.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.complex_powers!-Tuple{Any, Any}" href="#SphericalFunctions.complex_powers!-Tuple{Any, Any}"><code>SphericalFunctions.complex_powers!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">complex_powers!(zpowers, z)</code></pre><p>Compute integer powers of <code>z</code> from <code>z^0</code> through <code>z^m</code>, recursively, where <code>m</code> is one less than the length of the input <code>zpowers</code> vector.</p><p>Note that <code>z</code> is assumed to be normalized, with complex amplitude approximately 1.</p><p>See also: <a href="#SphericalFunctions.complex_powers-Tuple{Any, Int64}"><code>complex_powers</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/20a80611e25a5503503a904584d3bcbefe7482e7/src/complex_powers.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.complex_powers-Tuple{Any, Int64}" href="#SphericalFunctions.complex_powers-Tuple{Any, Int64}"><code>SphericalFunctions.complex_powers</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">complex_powers(z, m)</code></pre><p>Compute integer powers of <code>z</code> from <code>z^0</code> through <code>z^m</code>, recursively.</p><p>Note that <code>z</code> is assumed to be normalized, with complex amplitude approximately 1.</p><p>This algorithm is mostly due to Stoer and Bulirsch in &quot;Introduction to Numerical Analysis&quot; (page 24) ‚Äî with a little help from de Moivre&#39;s formula, which is essentially exp(iŒ∏)‚Åø = exp(inŒ∏), as well as my own alterations to deal with different behaviors in different quadrants.</p><p>There isn&#39;t usually a huge advantage to using this specialized function.  If you just need a particular power, it will generally be far more efficient and just as accurate to compute either exp(iŒ∏)‚Åø or exp(inŒ∏) explicitly.  However, if you need all powers from 0 to m, this function is about 10 or 5 times faster than those options, respectively, for large m.  Like those options, this function is numerically stable, in the sense that its errors are usually smaller than <code>m</code> times the error from machine-precision errors in the input argument ‚Äî or at worst about 50% larger, which occurs as the phase approaches multiples of œÄ/2.</p><p>See also: <a href="#SphericalFunctions.complex_powers!-Tuple{Any, Any}"><code>complex_powers!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/20a80611e25a5503503a904584d3bcbefe7482e7/src/complex_powers.jl#L49-L71">source</a></section></article><h2 id="Sizes-of-and-indexing-into-ùîá,-d,-and-Y-data"><a class="docs-heading-anchor" href="#Sizes-of-and-indexing-into-ùîá,-d,-and-Y-data">Sizes of and indexing into <span>$ùîá$</span>, <span>$d$</span>, and <span>$Y$</span> data</a><a id="Sizes-of-and-indexing-into-ùîá,-d,-and-Y-data-1"></a><a class="docs-heading-anchor-permalink" href="#Sizes-of-and-indexing-into-ùîá,-d,-and-Y-data" title="Permalink"></a></h2><p>By <span>$Y$</span> data, we mean anything indexed like <span>$Y_{\ell, m}$</span> modes; by <span>$D$</span> data, we mean anything indexed like Wigner&#39;s <span>$\mathfrak{D}$</span> matrices, or special subsets of them, like the <span>$H$</span> matrices.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.WignerDindex" href="#SphericalFunctions.WignerDindex"><code>SphericalFunctions.WignerDindex</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WignerDindex(‚Ñì, m‚Ä≤, m, m‚Ä≤‚Çò‚Çê‚Çì=‚Ñì)</code></pre><p>Compute index into Wigner ùîá matrix</p><p>See also <a href="#SphericalFunctions.WignerDrange"><code>WignerDrange</code></a> and <a href="#SphericalFunctions.WignerDsize-Tuple{Any}"><code>WignerDsize</code></a>.</p><p><strong>Notes</strong></p><p>This assumes that the Wigner ùîá matrix is arranged as</p><pre><code class="nohighlight hljs">[
    ùîá(‚Ñì, m‚Ä≤, m)
    for ‚Ñì ‚àà ‚Ñì‚Çò·µ¢‚Çô:‚Ñì‚Çò‚Çê‚Çì
    for m‚Ä≤ ‚àà -min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì):min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì)
    for m ‚àà -‚Ñì:‚Ñì
]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/20a80611e25a5503503a904584d3bcbefe7482e7/src/indexing.jl#L468-L486">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.WignerDrange" href="#SphericalFunctions.WignerDrange"><code>SphericalFunctions.WignerDrange</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WignerDrange(‚Ñì‚Çò‚Çê‚Çì, m‚Ä≤‚Çò‚Çê‚Çì=‚Ñì‚Çò‚Çê‚Çì)</code></pre><p>Create an array of (‚Ñì, m&#39;, m) indices as in ùîá array</p><p>See also <a href="#SphericalFunctions.WignerDsize-Tuple{Any}"><code>WignerDsize</code></a> and <a href="#SphericalFunctions.WignerDindex"><code>WignerDindex</code></a>.</p><p><strong>Notes</strong></p><p>This assumes that the Wigner ùîá matrix is arranged as</p><pre><code class="nohighlight hljs">[
    ùîá(‚Ñì, m‚Ä≤, m)
    for ‚Ñì ‚àà ‚Ñì‚Çò·µ¢‚Çô:‚Ñì‚Çò‚Çê‚Çì
    for m‚Ä≤ ‚àà -min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì):min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì)
    for m ‚àà -‚Ñì:‚Ñì
]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/20a80611e25a5503503a904584d3bcbefe7482e7/src/indexing.jl#L432-L450">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.WignerDsize-Tuple{Any}" href="#SphericalFunctions.WignerDsize-Tuple{Any}"><code>SphericalFunctions.WignerDsize</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WignerDsize(‚Ñì‚Çò‚Çê‚Çì, m‚Ä≤‚Çò‚Çê‚Çì=‚Ñì‚Çò‚Çê‚Çì)</code></pre><p>Compute total size of Wigner ùîá matrix</p><p>See also <a href="#SphericalFunctions.WignerDrange"><code>WignerDrange</code></a> and <a href="#SphericalFunctions.WignerDindex"><code>WignerDindex</code></a>.</p><p><strong>Notes</strong></p><p>This assumes that the Wigner ùîá matrix is arranged as</p><pre><code class="nohighlight hljs">[
    ùîá(‚Ñì, m‚Ä≤, m)
    for ‚Ñì ‚àà ‚Ñì‚Çò·µ¢‚Çô:‚Ñì‚Çò‚Çê‚Çì
    for m‚Ä≤ ‚àà -min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì):min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì)
    for m ‚àà -‚Ñì:‚Ñì
]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/20a80611e25a5503503a904584d3bcbefe7482e7/src/indexing.jl#L348-L366">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.WignerHindex" href="#SphericalFunctions.WignerHindex"><code>SphericalFunctions.WignerHindex</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WignerHindex(‚Ñì, m‚Ä≤, m, m‚Ä≤‚Çò‚Çê‚Çì)</code></pre><p>Index to &quot;wedge&quot; arrays.</p><p>See also <a href="#SphericalFunctions.WignerHsize-Tuple{Any}"><code>WignerHsize</code></a> and <a href="#SphericalFunctions.WignerHrange"><code>WignerHrange</code></a>.</p><p><strong>Notes</strong></p><p>Here, it is assumed that only data with m‚â•|m&#39;| are stored, and only corresponding values are passed.  We also assume |m|‚â§‚Ñì and |m&#39;|‚â§‚Ñì.  Neither of these are checked.  The wedge array that this function indexes is ordered as</p><pre><code class="nohighlight hljs">[
    H(‚Ñì, m‚Ä≤, m) for ‚Ñì ‚àà 0:‚Ñì‚Çò‚Çê‚Çì
    for m‚Ä≤ ‚àà -min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì):min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì)
    for m ‚àà abs(m‚Ä≤):‚Ñì
]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/20a80611e25a5503503a904584d3bcbefe7482e7/src/indexing.jl#L307-L326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.WignerHrange" href="#SphericalFunctions.WignerHrange"><code>SphericalFunctions.WignerHrange</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WignerHrange(‚Ñì‚Çò‚Çê‚Çì, m‚Ä≤‚Çò‚Çê‚Çì=‚Ñì‚Çò‚Çê‚Çì)</code></pre><p>Create an array of (‚Ñì, m&#39;, m) indices as in H array</p><p>See also <a href="#SphericalFunctions.WignerHsize-Tuple{Any}"><code>WignerHsize</code></a> and <a href="#SphericalFunctions.WignerHindex"><code>WignerHindex</code></a></p><p><strong>Notes</strong></p><p>Here, it is assumed that only data with m‚â•|m&#39;| are stored, and only corresponding values are passed.  We also assume |m|‚â§‚Ñì and |m&#39;|‚â§‚Ñì.  Neither of these are checked.  The wedge array that this function indexes is ordered as</p><pre><code class="nohighlight hljs">[
    H(‚Ñì, m‚Ä≤, m) for ‚Ñì ‚àà 0:‚Ñì‚Çò‚Çê‚Çì
    for m‚Ä≤ ‚àà -min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì):min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì)
    for m ‚àà abs(m‚Ä≤):‚Ñì
]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/20a80611e25a5503503a904584d3bcbefe7482e7/src/indexing.jl#L246-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.WignerHsize-Tuple{Any}" href="#SphericalFunctions.WignerHsize-Tuple{Any}"><code>SphericalFunctions.WignerHsize</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WignerHsize(‚Ñì‚Çò‚Çê‚Çì, m‚Ä≤‚Çò‚Çê‚Çì=‚Ñì‚Çò‚Çê‚Çì)</code></pre><p>Total size of array of wedges of width m‚Ä≤‚Çò‚Çê‚Çì up to ‚Ñì‚Çò‚Çê‚Çì.  If m‚Ä≤‚Çò‚Çê‚Çì is not given, it defaults to ‚Ñì‚Çò‚Çê‚Çì.</p><p>See also <a href="#SphericalFunctions.WignerHrange"><code>WignerHrange</code></a> and <a href="#SphericalFunctions.WignerHindex"><code>WignerHindex</code></a>.</p><p><strong>Notes</strong></p><p>Here, it is assumed that only data with m‚â•|m‚Ä≤| are stored, and only corresponding values are passed.  We also assume |m|‚â§‚Ñì and |m‚Ä≤|‚â§‚Ñì.  Neither of these are checked.  The wedge array that this function indexes is ordered as</p><pre><code class="nohighlight hljs">[
    H(‚Ñì, m‚Ä≤, m) for ‚Ñì ‚àà 0:‚Ñì‚Çò‚Çê‚Çì
    for m‚Ä≤ ‚àà -min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì):min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì)
    for m ‚àà abs(m‚Ä≤):‚Ñì
]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/20a80611e25a5503503a904584d3bcbefe7482e7/src/indexing.jl#L205-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.Yindex" href="#SphericalFunctions.Yindex"><code>SphericalFunctions.Yindex</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Yindex(‚Ñì, m, ‚Ñì‚Çò·µ¢‚Çô=0)</code></pre><p>Compute index into array of mode weights</p><p><strong>Parameters</strong></p><p>‚Ñì : int     Integer satisfying ‚Ñì‚Çò·µ¢‚Çô &lt;= ‚Ñì &lt;= ‚Ñì‚Çò‚Çê‚Çì m : int     Integer satisfying -‚Ñì &lt;= m &lt;= ‚Ñì ‚Ñì‚Çò·µ¢‚Çô : int, optional     Integer satisfying 0 &lt;= ‚Ñì‚Çò·µ¢‚Çô.  Defaults to 0.</p><p><strong>Returns</strong></p><p>i : int     Index of a particular element of the mode-weight array as described below</p><p><strong>See Also</strong></p><p>Ysize : Total size of array of mode weights Yrange : Array of (‚Ñì, m) indices corresponding to this array</p><p><strong>Notes</strong></p><p>This assumes that the modes are arranged (with fixed s value) as</p><pre><code class="nohighlight hljs">[
    Y(s, ‚Ñì, m)
    for ‚Ñì ‚àà ‚Ñì‚Çò·µ¢‚Çô:‚Ñì‚Çò‚Çê‚Çì
    for m ‚àà -‚Ñì:‚Ñì
]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/20a80611e25a5503503a904584d3bcbefe7482e7/src/indexing.jl#L118-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.Yrange-Tuple{Any}" href="#SphericalFunctions.Yrange-Tuple{Any}"><code>SphericalFunctions.Yrange</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Yrange(‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì)</code></pre><p>Create an array of (‚Ñì, m) indices as in Y array</p><p><strong>Parameters</strong></p><p>‚Ñì‚Çò·µ¢‚Çô : int     Integer satisfying 0 &lt;= ‚Ñì‚Çò·µ¢‚Çô &lt;= ‚Ñì‚Çò‚Çê‚Çì ‚Ñì‚Çò‚Çê‚Çì : int     Integer satisfying 0 &lt;= ‚Ñì‚Çò·µ¢‚Çô &lt;= ‚Ñì‚Çò‚Çê‚Çì</p><p><strong>Returns</strong></p><p>i : int     Total size of array of mode weights arranged as described below</p><p><strong>See Also</strong></p><p>Ysize : Total size of array of mode weights Yindex : Index of a particular element of the mode weight array</p><p><strong>Notes</strong></p><p>This assumes that the modes are arranged (with fixed s value) as</p><pre><code class="nohighlight hljs">[
    Y(s, ‚Ñì, m)
    for ‚Ñì ‚àà ‚Ñì‚Çò·µ¢‚Çô:‚Ñì‚Çò‚Çê‚Çì
    for m ‚àà -‚Ñì:‚Ñì
]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/20a80611e25a5503503a904584d3bcbefe7482e7/src/indexing.jl#L70-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.Ysize-Tuple{Any}" href="#SphericalFunctions.Ysize-Tuple{Any}"><code>SphericalFunctions.Ysize</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Ysize(‚Ñì‚Çò‚Çê‚Çì)</code></pre><p>Compute total size of array of mode weights</p><p><strong>See Also</strong></p><p>Yrange : Array of (‚Ñì, m) indices corresponding to this array Yindex : Index of a particular element of the mode weight array</p><p><strong>Notes</strong></p><p>This assumes that the modes are arranged (with fixed s value) as</p><pre><code class="nohighlight hljs">[
    Y(s, ‚Ñì, m)
    for ‚Ñì ‚àà ‚Ñì‚Çò·µ¢‚Çô:‚Ñì‚Çò‚Çê‚Çì
    for m ‚àà -‚Ñì:‚Ñì
]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/20a80611e25a5503503a904584d3bcbefe7482e7/src/indexing.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions._WignerHindex-NTuple{4, Any}" href="#SphericalFunctions._WignerHindex-NTuple{4, Any}"><code>SphericalFunctions._WignerHindex</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>WignerHindex(‚Ñì, m‚Ä≤, m, m‚Ä≤‚Çò‚Çê‚Çì)</p><p>Helper function for <a href="#SphericalFunctions.WignerHindex"><code>WignerHindex</code></a>, with more constraints.</p><p>This function assumes that <code>m ‚â• |m‚Ä≤|</code>.  The main <a href="#SphericalFunctions.WignerHindex"><code>WignerHindex</code></a> function uses symmetries of the H array to account for cases that violate this assumption.  (But note that both that function and this one assume that <code>|m| ‚â§ ‚Ñì</code> and <code>|m‚Ä≤| ‚â§ ‚Ñì</code>.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/20a80611e25a5503503a904584d3bcbefe7482e7/src/indexing.jl#L283-L292">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.deduce_limits" href="#SphericalFunctions.deduce_limits"><code>SphericalFunctions.deduce_limits</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deduce_limits(ysize, [‚Ñìmin])</code></pre><p>Deduce the value of <code>(‚Ñìmin, ‚Ñìmax)</code> that produces <span>$Y$</span> arrays of the given size.</p><p>If <code>‚Ñìmin</code> is not given, it is assumed to be 0.  If it is set to <code>nothing</code>, the smallest possible value of <code>‚Ñìmin</code> will be used.  However, note that this is not a well-posed problem; multiple combinations of <code>(‚Ñìmin, ‚Ñìmax)</code> can give rise to <span>$Y$</span> arrays of the same size.</p><p>See also <a href="#SphericalFunctions.Ysize-Tuple{Any}"><code>Ysize</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/20a80611e25a5503503a904584d3bcbefe7482e7/src/indexing.jl#L41-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.phi_theta-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T" href="#SphericalFunctions.phi_theta-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>SphericalFunctions.phi_theta</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phi_theta(Nœï, NŒ∏, [T=Float64])</code></pre><p>Construct (phi, theta) grid in order expected by this package.</p><p>See also <a href="#SphericalFunctions.theta_phi-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>theta_phi</code></a> for the opposite ordering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/20a80611e25a5503503a904584d3bcbefe7482e7/src/indexing.jl#L187-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.theta_phi-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T" href="#SphericalFunctions.theta_phi-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>SphericalFunctions.theta_phi</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">theta_phi(NŒ∏, Nœï, [T=Float64])</code></pre><p>Construct (theta, phi) grid in <code>spinsfast</code> order.</p><p>Note that this order is different from the one assumed by this package; use <a href="#SphericalFunctions.phi_theta-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>phi_theta</code></a> for the opposite ordering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/20a80611e25a5503503a904584d3bcbefe7482e7/src/indexing.jl#L169-L177">source</a></section></article><h2 id="Combinatorics"><a class="docs-heading-anchor" href="#Combinatorics">Combinatorics</a><a id="Combinatorics-1"></a><a class="docs-heading-anchor-permalink" href="#Combinatorics" title="Permalink"></a></h2><p>Spherical functions frequently involve binomial coefficients and similar terms, with arguments proportional to <span>$‚Ñì$</span>, which we aim to allow to be very large ‚Äî of order 1,000 or more. Unfortunately, due to combinatorical explosions, this is frequently infeasible with naive methods.  Here, we collect any specialized methods that help us beat the limits.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.sqrtbinomial-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T" href="#SphericalFunctions.sqrtbinomial-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>SphericalFunctions.sqrtbinomial</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sqrtbinomial(n, k, [T])</code></pre><p>Evaluate the square-root of the binomial coefficient <code>binomial(n,k)</code> for large coefficients.</p><p>Ordinarily, when <code>n</code> and <code>k</code> are standard <code>Int</code> arguments, the built-in <code>binomial</code> function will overflow around <code>n=66</code>, because it results in <code>Int</code>s.  We need much larger values. This function, which is based on <a href="https://specialfunctions.juliamath.org/latest/functions_list/#SpecialFunctions.logabsbinomial"><code>a related one in SpecialFunctions.jl</code></a>, returns reasonably accurate results up to <code>n ‚âà 1026</code> when <code>k ‚âà n/2</code> (which is the case of interest in many applications in this package).</p><p>Computations are carried out (and returned) in type <code>T</code>, which defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/20a80611e25a5503503a904584d3bcbefe7482e7/src/utils.jl#L45-L58">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../operators/">¬´ Differential operators</a><a class="docs-footer-nextpage" href="../internal/">Internal functions ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Saturday 7 December 2024 04:07">Saturday 7 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
