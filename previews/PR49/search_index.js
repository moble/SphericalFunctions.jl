var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"The most important routine in this package is the computation of the 𝔇 matrices — or more specifically, of terms proportional to parts of the 𝔇 matrices.  This mostly follows the treatment of Gumerov and Duraiswami [8] (with minor modifications to account for errors in their presentation, as described here).  To seed the recursions they present, we also need to calculate the associated Legendre functions.  This is now done using the \"fully normalized column-wise recurrence formula\" (fnCWF) given by Eqs. (12)—(14) of Xing et al. [31].  This improves significantly over the older implementation using the \"modified forward row method\" of Holmes and Featherstone [35], for which the results would fail to be finite starting at ℓ=22 for Float16, ℓ=183 for Float32, and ℓ=1474 for Float64. Another approach that was never precisely implemented in this package was due to Fukushima [36], who showed that using \"X-numbers\", wherein the exponent is stored as a separate integer, (implemented in this package) in the core of the recursion could increase the range to ℓ≈2³².  Xing et al. showed that Fukushima's results exhibited increased error for certain angles, whereas their Eqs. (12)—(14) could be used directly to obtain results with greater accuracy for those certain angles, and comparable accuracy for other angles.","category":"page"},{"location":"references/","page":"References","title":"References","text":"The other major functionality of this package is map2salm / salm2map, which decomposes function values on regular grids into mode weights (coefficients), and vice versa.  The approach used here is taken from Reinecke and Seljebotn [3], with weights based on the method by Waldvogel [6].  However, this interface has been superseded by the SSHT object, which implements several approaches, including the Reinecke-Seljebotn-Waldvogel method, as well as the optimal-dimensionality method due to Elahi et al. [2], as well as a new unpublished optimal-dimensionality method I (Mike Boyle) created.","category":"page"},{"location":"references/#Bibliography","page":"References","title":"Bibliography","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"M. Boyle. How should spin-weighted spherical functions be defined? Journal of Mathematical Physics 57 (2016), arXiv:1604.08140 [gr-qc].\n\n\n\nU. Elahi, Z. Khalid, R. A. Kennedy and J. D. McEwen. An Optimal-Dimensionality Sampling for Spin-s Functions on the Sphere. IEEE Signal Processing Letters 25, 1470–1474 (2018), arXiv:1809.01321 [astro-ph.IM].\n\n\n\nM. Reinecke and D. S. Seljebotn. Libsharp—spherical harmonic transforms revisited. Astronomy & Astrophysics 554, A112 (2013), arXiv:1303.4945 [physics.comp-ph].\n\n\n\nE. B. Saff and A. B. Kuijlaars. Distributing many points on a sphere. The Mathematical Intelligencer 19, 5–11 (1997).\n\n\n\nJ. S. Brauchart and P. J. Grabner. Distributing many points on spheres: Minimal energy and designs. Journal of Complexity 31, 293–326 (2015).\n\n\n\nJ. Waldvogel. Fast Construction of the Fejér and Clenshaw–Curtis Quadrature Rules. BIT Numerical Mathematics 46, 195–202 (2006).\n\n\n\nE. T. Newman and R. Penrose. Note on the Bondi-Metzner-Sachs Group. Journal of Mathematical Physics 7, 863–870 (1966).\n\n\n\nN. A. Gumerov and R. Duraiswami. Recursive Computation of Spherical Harmonic Rotation Coefficients of Large Degree. In: Excursions in Harmonic Analysis, Volume 3 (Springer International Publishing, 2015); pp. 105–141, arXiv:1403.7698 [math.NA].\n\n\n\nP. J. Kostelec and D. N. Rockmore. FFTs on the Rotation Group. Journal of Fourier Analysis and Applications 14, 145–179 (2008).\n\n\n\nC. Doran and A. Lasenby. Geometric Algebra for Physicists (Cambridge University Press, Cambridge, 2003).\n\n\n\nH. Sommer, I. Gilitschenski, M. Bloesch, S. Weiss, R. Siegwart and J. Nieto. Why and How to Avoid the Flipped Quaternion Multiplication (Jan 2018), arXiv:1801.07478 [cs.RO].\n\n\n\nM. Bander and C. Itzykson. Group Theory and the Hydrogen Atom (I). Reviews of Modern Physics 38, 330–345 (1966).\n\n\n\nJ. M. Lee. Introduction to Smooth Manifolds. Vol. 218 of Graduate Texts in Mathematics (Springer, New York, NY, 2012).\n\n\n\nJ. P. Boyd and R. Petschek. The Relationships Between Chebyshev, Legendre and Jacobi Polynomials: The                   Generic Superiority of Chebyshev Polynomials and Three Important Exceptions. Journal of Scientific Computing 59, 1–27 (2014).\n\n\n\nJ. J. Sakurai. Modern Quantum Mechanics. Revised Edition (Addison Wesley, New York, 1994).\n\n\n\nG. B. Folland. A Course in Abstract Harmonic Analysis. 2nd Edition (Chapman and Hall/CRC, New York, 2016).\n\n\n\nG. W. Hanson and A. B. Yakovlev. Operator Theory for Electromagnetics (Springer, New York, NY, 2002).\n\n\n\nN. A. Gumerov and R. Duraiswami. Fast, Exact, and Stable Computation of Multipole Translation and Rotation                   Coefficients for the 3-D Helmholtz Equation. Technical Report UMIACS TR 2001-44 (University of Maryland, College Park, MD, 2001).\n\n\n\nC. Cohen-Tannoudji, B. Diu and F. Laloe. Quantum Mechanics. 1st Edition (Wiley, New York, 1991).\n\n\n\nA. R. Edmonds. Angular Momentum in Quantum Mechanics. 2nd Edition (Princeton University Press, 1960).\n\n\n\nJ. N. Goldberg, A. J. Macfarlane, E. T. Newman, F. Rohrlich and E. C. Sudarshan. Spin‐s Spherical Harmonics and ð. Journal of Mathematical Physics 8, 2155–2161 (1967).\n\n\n\nD. J. Griffiths. Introduction to quantum mechanics. 1st Edition (Prentice Hall, Upper Saddle River, NJ, 1995).\n\n\n\nM. Le Bellac. Quantum Physics (Cambridge University Press, Cambridge, 2006).\n\n\n\nR. Shankar. Principles of Quantum Mechanics. 2nd Edition (Plenum Press, New York, 1994).\n\n\n\nG. F. Torres Del Castillo. 3-D Spinors, Spin-Weighted Functions and their Applications. Vol. 52 no. 2 (Birkhäuser, Boston, MA, 2003); p. 299.\n\n\n\nD. A. Varshalovich, A. N. Moskalev and V. K. Khersonskiĭ. Quantum theory of angular momentum: Irreducible tensors, spherical harmonics,                   vector coupling coefficients, 3nj symbols (World Scientific Pub, Singapore ; Teaneck, NJ, USA, 1988).\n\n\n\nN. Zettili. Quantum Mechanics: Concepts and Applications. 2nd Edition (John Wiley & Sons, New York, NY, 2009).\n\n\n\nE. U. Condon and G. H. Shortley. The Theory Of Atomic Spectra. 1st Edition (Cambridge University Press, London, 1935).\n\n\n\nLIGO Scientific Collaboration, Virgo Collaboration and KAGRA Collaboration. LVK Algorithm Library - LALSuite. Free software (GPL) (2018).\n\n\n\nP. Ajith, M. Boyle, D. A. Brown, S. Fairhurst, M. Hannam, I. Hinder, S. Husa, B. Krishnan, R. A. Mercer, F. Ohme, C. D. Ott, J. S. Read, L. Santamaria and J. T. Whelan. Data formats for numerical relativity waves (2007), arXiv:0709.0093 [gr-qc]. There was a serious error in the original version of this paper.  The error was corrected in version 2.\n\n\n\nZ. Xing, S. Li, M. Tian, D. Fan and C. Zhang. Numerical experiments on column-wise recurrence formula to compute fully                   normalized associated Legendre functions of ultra-high degree and order. Journal of Geodesy 94 (2019).\n\n\n\nStrakhov. On synthesis of the outer gravitational potential in spherical harmonic series. Doklady Akademii nauk SSSR 254, 839–841 (1980).\n\n\n\nM. V. Belikov. Spherical harmonic analysis and synthesis with the use of column-wise recurrence                   relations, manuscripta geodaetica 16, 384–410 (1991).\n\n\n\nJ. D. McEwen and Y. Wiaux. A Novel Sampling Theorem on the Sphere. IEEE Transactions on Signal Processing 59, 5876–5887 (2011), arXiv:1110.6298 [cs.IT].\n\n\n\nS. A. Holmes and W. E. Featherstone. A unified approach to the Clenshaw summation and the recursive computation of very                   high degree and order normalised associated Legendre functions. Journal of Geodesy 76, 279–299 (2002).\n\n\n\nT. Fukushima. Numerical computation of spherical harmonics of arbitrary degree and order by                   extending exponent of floating point numbers. Journal of Geodesy 86, 271–285 (2011).\n\n\n\nC. W. Ufford and G. H. Shortley. Atomic Eigenfunctions and Energies. Physical Review 42, 167–175 (1932).\n\n\n\nJ. van Neerven. Functional Analysis. Cambridge Studies in Advanced Mathematics (Cambridge University Press, Cambridge, 2022).\n\n\n\nW. Fulton and J. Harris. Representation Theory. Vol. 129 of Graduate Texts in Mathematics (Springer, New York, NY, 2004).\n\n\n\nN. A. Gumerov and R. Duraiswami. Recursions for the Computation of Multipole Translation and Rotation Coefficients                   for the 3-D Helmholtz Equation. SIAM Journal on Scientific Computing 25, 1344–1381 (2004).\n\n\n\nNIST Digital Library of Mathematical Functions, https://dlmf.nist.gov/, Release 1.2.3 of 2024-12-15. F. W. J. Olver, A. B. Olde Daalhuis, D. W. Lozier, B. I. Schneider,                   R. F. Boisvert, C. W. Clark, B. R. Miller, B. V. Saunders, H. S. Cohl, and                   M. A. McClain, eds.\n\n\n\nK. S. Thorne. Multipole expansions of gravitational radiation. Reviews of Modern Physics 52, 299 (1980).\n\n\n\nE. P. Wigner. Group Theory and Its Application to the Quantum Mechanics of Atomic Spectra (Academic Press, New York, NY, 1959).\n\n\n\n","category":"page"},{"location":"wigner_matrices/#Wigner's-𝔇-and-d-matrices","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"","category":"section"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"Wigner's 𝔇 matrices — and to a lesser extent, the related d matrices — are extremely important in the theory of rotations.  Each element is, itself, a special function of the rotation group: in particular, an eigenfunction of the left- and right-Lie derivatives, and thus a spin-weighted spherical function.  Collectively, they describe how spin-weighted spherical functions transform under rotation.  But their accurate and efficient computation is surprisingly subtle.  This package implements the current state-of-the-art techniques for their fast and accurate computation, based on the H recursion.","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"The actual computations can be done with the D_matrices function:","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"using Quaternionic\nusing SphericalFunctions\n\nR = randn(RotorF64)\nℓₘₐₓ = 8\n𝔇 = D_matrices(R, ℓₘₐₓ)","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"However, the matrices can take up a lot of memory.  So for maximum efficiency when calling this function repeatedly with different R values, it is best to pre-allocate the necessary memory with the D_prep function, and the pass that in as an argument to D_matrices!:","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"D_storage = D_prep(ℓₘₐₓ)\n𝔇 = D_matrices!(D_storage, R)","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"(Beware that, as noted in the documentation for D_matrices!, the output 𝔇 is just a reference to part of the D_storage object, so you should not reuse D_storage until you have copied or otherwise finished using 𝔇.)","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"The output 𝔇 is a (linear!) vector of Complex numbers with the same base type as R.  The ordering of the elements is described in the documentation for D_matrices.  It is also possible to efficiently view slices of this vector as a series of individual matrices using a D_iterator:","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"for (ℓ, Dˡ) in zip(0:ℓₘₐₓ, D_iterator(𝔇, ℓₘₐₓ))\n    # Do something with the matrix Dˡ[ℓ+m′+1, ℓ+m+1]\nend","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"For the d matrices, we have almost the same interface, except that instead of the input quaternion R we only need the angle β (or its complex angle expiβ, which can be computed directly in some cases), and the output is real-valued:","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"using Quaternionic\nusing SphericalFunctions\n\nβ = π * rand(Float64)\nℓₘₐₓ = 8\nd = d_matrices(β, ℓₘₐₓ)","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"Again, for repeated calls, it is best to pre-allocate storage:","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"d_storage = d_prep(ℓₘₐₓ)\nd = d_matrices!(d_storage, β)","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"The output d is a vector of numbers of the same type as β, ordered in the same way as the output of D_matrices.  And similarly, we can iterate over the individual matrices using a d_iterator.","category":"page"},{"location":"wigner_matrices/#Docstrings","page":"Wigner's 𝔇 and d matrices","title":"Docstrings","text":"","category":"section"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"D_matrices\nD_matrices!\nD_prep\nD_iterator\nd_matrices\nd_matrices!\nd_prep\nd_iterator","category":"page"},{"location":"wigner_matrices/#SphericalFunctions.D_matrices","page":"Wigner's 𝔇 and d matrices","title":"SphericalFunctions.D_matrices","text":"D_matrices(R, ℓₘₐₓ)\nD_matrices(α, β, γ, ℓₘₐₓ)\n\nCompute Wigner's 𝔇 matrices mathfrakD^(ell)_mm(beta) for all ell leq ell_mathrmmax.\n\nSee D_matrices! for details about the input and output values.\n\nThis function only appropriate when you need to evaluate the matrices for a single value of R or α, β, γ because it allocates large arrays and performs many calculations that could be reused.  If you need to evaluate the matrices for many values of R or α, β, γ, you should pre-allocate the storage with D_prep, and then call D_matrices! with the result instead.\n\n\n\n\n\n","category":"function"},{"location":"wigner_matrices/#SphericalFunctions.D_matrices!","page":"Wigner's 𝔇 and d matrices","title":"SphericalFunctions.D_matrices!","text":"D_matrices!(D_storage, R)\nD_matrices!(D_storage, α, β, γ)\nD_matrices!(D, R, ℓₘₐₓ)\nD_matrices!(D, α, β, γ, ℓₘₐₓ)\n\nCompute Wigner's 𝔇 matrices mathfrakD^(ell)_mm(beta) for all ell leq ell_mathrmmax.\n\nIn all cases, the result is returned in a 1-dimensional array ordered as\n\n[\n    𝔇ˡₘₚ,ₘ(R)\n    for ℓ ∈ 0:ℓₘₐₓ\n    for mp ∈ -ℓ:ℓ\n    for m ∈ -ℓ:ℓ\n]\n\nWhen the first argument is D, it will be modified, so it must be at least as large as that array. When the first argument is D_storage, it should be the quantity returned by D_prep, and the result will be written into the D field of that tuple.  Both of these options — especially the latter — reduce the number of allocations needed on each call to the corresponding functions, which should increase the speed significantly.  Note that the D or D_storage arguments must have types compatible with the type of R or α, β, γ.\n\nwarn: Warn\nWhen using the D_storage argument (which is recommended), the returned quantity D will be an alias of D_storage[1].  If you want to retain that data after the next call to D_matrices!, you should copy it with copy(D).\n\nThe α, β, γ arguments are Euler angles as described in the documentation of Quaternionic.from_euler_angles.\n\nSee also D_matrices for a simpler function call when you only need to evaluate the matrices for a single value of R or α, β, γ.\n\nExamples\n\nusing Quaternionic, SphericalFunctions\nℓₘₐₓ = 8\nT = Float64\nR = Rotor{T}(1, 2, 3, 4)  # Will be normalized automatically\nD_storage = D_prep(ℓₘₐₓ, T)\nD = D_matrices!(D_storage, R)\n\n\n\n\n\n","category":"function"},{"location":"wigner_matrices/#SphericalFunctions.D_prep","page":"Wigner's 𝔇 and d matrices","title":"SphericalFunctions.D_prep","text":"D_prep(ℓₘₐₓ, [T=Float64])\n\nConstruct storage space and pre-compute recursion coefficients to compute Wigner's mathfrakD matrix in place.\n\nThis returns the D_storage arguments needed by D_matrices!.\n\n\n\n\n\n","category":"function"},{"location":"wigner_matrices/#SphericalFunctions.D_iterator","page":"Wigner's 𝔇 and d matrices","title":"SphericalFunctions.D_iterator","text":"D_iterator(D, ℓₘₐₓ, [ℓₘᵢₙ])\n\nConstruct an Iterator that returns sub-matrices of D, each of which consists of elements (ℓ-ℓ-ℓ) through (ℓℓℓ), for ℓ from ℓₘᵢₙ through ℓₘₐₓ.  By default, ℓₘᵢₙ is 0.\n\ndanger: Inconsistent behavior\nThis iterator mistakenly returns the transpose of the result implied by this documentation.  As a result, a warning is issued every time this function is called. Rather than actually fixing this bug in this minor/patch version — which would be a breaking change — this is a final release in this major version of the package to notify users of this function (and d_iterator) that there is a problem.  The next major version of the package will likely change the actual behavior to the one implied by this docstring.  To quiet these warnings, you can temporarily pass the keyword argument warn=false, though this will probably be removed in the next major version. Alternatively, use Dit = with_logger(NullLogger()) do D_iterator(...) end to catch any warnings.\n\nNote that the returned objects are views into the original D data — meaning that you may alter their values.\n\nBecause the result is a matrix restricted to a particular ℓ value, you can index the (ℓ m m) element as [ℓ+m′+1, ℓ+m+1].  For example, you might use this as something like\n\nfor (ℓ, Dˡ) in zip(ℓₘᵢₙ:ℓₘₐₓ, D_iterator(D, ℓₘₐₓ))\n    for m′ in -ℓ:ℓ\n        for m in -ℓ:ℓ\n            Dˡ[ℓ+m′+1, ℓ+m+1]  # ... do something with Dˡ\n        end\n    end\nend\n\nAlso note that no bounds checking is done, either at instantiation time or during iteration. You are responsible for ensuring that the size of D and the values of ℓₘₐₓ and ℓₘᵢₙ make sense.\n\n\n\n\n\n","category":"type"},{"location":"wigner_matrices/#SphericalFunctions.d_matrices","page":"Wigner's 𝔇 and d matrices","title":"SphericalFunctions.d_matrices","text":"d_matrices(β, ℓₘₐₓ)\nd_matrices(expiβ, ℓₘₐₓ)\n\nCompute Wigner's d^(ell) matrices with elements d^(ell)_mm(beta) for all ell leq ell_mathrmmax.  The d matrices are sometimes called the \"reduced\" Wigner matrices, in contrast to the full mathfrakD matrices.\n\nSee d_matrices! for details about the input and output values.\n\nThis function only appropriate when you need to evaluate the matrices for a single value of β or expiβ because it allocates large arrays and performs many calculations that could be reused.  If you need to evaluate the matrices for many values of β or expiβ, you should pre-allocate the storage with d_prep, and then call d_matrices! with the result instead.\n\n\n\n\n\n","category":"function"},{"location":"wigner_matrices/#SphericalFunctions.d_matrices!","page":"Wigner's 𝔇 and d matrices","title":"SphericalFunctions.d_matrices!","text":"d_matrices!(d_storage, β)\nd_matrices!(d_storage, expiβ)\nd_matrices!(d, β, ℓₘₐₓ)\nd_matrices!(d, expiβ, ℓₘₐₓ)\n\nCompute Wigner's d^(ell) matrices with elements d^(ell)_mm(beta) for all ell leq ell_mathrmmax.  The d matrices are sometimes called the \"reduced\" Wigner matrices, in contrast to the full mathfrakD matrices.\n\nIn all cases, the result is returned in a 1-dimensional array ordered as\n\n[\n    dˡₘₚ,ₘ(β)\n    for ℓ ∈ 0:ℓₘₐₓ\n    for mp ∈ -ℓ:ℓ\n    for m ∈ -ℓ:ℓ\n]\n\nWhen the first argument is d, it will be modified, so it must be at least as large as that array.  When the first argument is d_storage, it should be the quantity returned by d_prep, and the result will be written into the d field of that tuple.  Both of these options — especially the latter — reduce the number of allocations needed on each call to the corresponding functions, which should increase the speed significantly.\n\nwarn: Warn\nWhen using the d_storage argument (which is recommended), the returned quantity d will be an alias of d_storage[1].  If you want to retain that data after the next call to d_matrices!, you should copy it with copy(d).\n\nSee also d_matrices for a simpler function call when you only need to evaluate the matrices for a single value of β or expiβ.\n\nExamples\n\nusing SphericalFunctions\nℓₘₐₓ = 8\nT = Float64\nβ = T(1)/8\nd_storage = d_prep(ℓₘₐₓ, T)\nd = d_matrices!(d_storage, β)\n\n\n\n\n\n","category":"function"},{"location":"wigner_matrices/#SphericalFunctions.d_prep","page":"Wigner's 𝔇 and d matrices","title":"SphericalFunctions.d_prep","text":"d_prep(ℓₘₐₓ, [T=Float64])\n\nConstruct space and pre-compute recursion coefficients to compute Wigner's d matrix in place.\n\nThis returns the d_storage arguments needed by d_matrices!.\n\n\n\n\n\n","category":"function"},{"location":"wigner_matrices/#SphericalFunctions.d_iterator","page":"Wigner's 𝔇 and d matrices","title":"SphericalFunctions.d_iterator","text":"d_iterator(d, ℓₘₐₓ, [ℓₘᵢₙ])\n\nConstruct an Iterator that returns sub-matrices of d, each of which consists of elements (ℓ-ℓ-ℓ) through (ℓℓℓ), for ℓ from ℓₘᵢₙ through ℓₘₐₓ.  By default, ℓₘᵢₙ is 0.\n\ndanger: Inconsistent behavior\nThis iterator mistakenly returns the transpose of the result implied by this documentation.  As a result, a warning is issued every time this function is called. Rather than actually fixing this bug in this minor/patch version — which would be a breaking change — this is a final release in this major version of the package to notify users of this function (and D_iterator) that there is a problem.  The next major version of the package will likely change the actual behavior to the one implied by this docstring.  To quiet these warnings, you can temporarily pass the keyword argument warn=false, though this will probably be removed in the next major version. Alternatively, use Dit = with_logger(NullLogger()) do D_iterator(...) end to catch any warnings.\n\nNote that the returned objects are views into the original d data — meaning that you may alter their values.\n\nBecause the result is a matrix restricted to a particular ℓ value, you can index the (ℓ m m) element as [ℓ+m′+1, ℓ+m+1].  For example, you might use this as something like\n\nfor (ℓ, dˡ) in zip(ℓₘᵢₙ:ℓₘₐₓ, d_iterator(d, ℓₘₐₓ))\n    for m′ in -ℓ:ℓ\n        for m in -ℓ:ℓ\n            dˡ[ℓ+m′+1, ℓ+m+1]  # ... do something with dˡ\n        end\n    end\nend\n\nAlso note that no bounds checking is done, either at instantiation time or during iteration. You are responsible for ensuring that the size of d and the values of ℓₘₐₓ and ℓₘᵢₙ make sense.\n\n\n\n\n\n","category":"type"},{"location":"conventions/comparisons/#Comparisons","page":"Comparisons","title":"Comparisons","text":"","category":"section"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Here, we compare our conventions to other sources, including references in the literature as well as other software that implements some of these.  Each of these comparisons is also performed explicitly in this package's test suite.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Among the items that would be good to compare are the following, when actually used by any of these sources:","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Quaternions\nOrder of components\nBasis and multiplication table\nOperation as rotations\nEuler angles\nSpherical coordinates\nAngular momentum operators\nFundamental definitions\nExpression in terms of spherical coordinates\nExpression in terms of Euler angles\nRight-derivative form\nSpherical harmonics\nCondon-Shortley phase\nFormula\nSpin-weighted spherical harmonics\nBehavior under rotation\nWigner D-matrices\nRepresentation à la langle ell m  e^-i alpha J_z e^-i beta J_y e^-i gamma J_z  ell m rangle\nRotation of spherical harmonics\nOrder of indices\nConjugation\nFunction of rotation or inverse rotation\nFormula","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"One major result of this is that almost everyone since 1935 has used the same exact expression for the (scalar) spherical harmonics.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"When choosing my conventions, I intend to prioritize consistency (to the extent that any of these references actually have anything to say about the above items) with the following sources, in order:","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"LALSuite\nNINJA\nNewman-Penrose\nGoldberg\nThorne / MTW\nWikipedia\nSakurai\nShankar\nZettili","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"I think that should be sufficient to find a consensus on conventions for each of the above — with the possible exception of quaternions, for which I have my own strong opinions.","category":"page"},{"location":"conventions/comparisons/#Cohen-Tannoudji-(1991)","page":"Comparisons","title":"Cohen-Tannoudji (1991)","text":"","category":"section"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Cohen-Tannoudji et al. [19] define spherical coordinates in the usual (physicist's) way in Chapter VI.  They then compute the angular-momentum operators as [Eqs. (D-5)]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"beginaligned\nL_x = i hbar left(\n    sinphi fracpartial partial theta\n    + fraccosphitantheta fracpartial partial phi\nright)\n\nL_y = i hbar left(\n    -cosphi fracpartial partial theta\n    + fracsinphitantheta fracpartial partial phi\nright)\n\nL_z = frachbari fracpartial partial phi\nendaligned","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"They derives the spherical harmonics in two ways and gets two different, but equivalent, expressions in Complement mathrmA_mathrmVI.  The first is Eq. (26)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Y_l^m(theta phi)\n=\nfrac(-1)^l2^l l sqrtfrac(2l+1)4pi frac(l+m)(l-m)\ne^i m phi (sin theta)^-m\nfracd^l-md(cos theta)^l-m (sin theta)^2l","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"while the second is Eq. (30)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Y_l^m(theta phi)\n=\nfrac(-1)^l+m2^l l sqrtfrac(2l+1)4pi frac(l-m)(l+m)\ne^i m phi (sin theta)^m\nfracd^l+md(cos theta)^l+m (sin theta)^2l","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"In Complement mathrmB_mathrmVI they define a rotation operator R as acting on a state such that [Eq. (21)]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"langle mathbfr  R  psi rangle\n=\nlangle mathscrR^-1 mathbfr  psi rangle","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"For an infinitesimal rotation through angle dalpha about the axis mathbfu, he shows [Eq. (49)]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"R_mathbfu(dalpha) = 1 - fracihbar dalpha mathbfLmathbfu","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"They do not appear to define the Wigner D-matrices.","category":"page"},{"location":"conventions/comparisons/#Condon-Shortley-(1935)","page":"Comparisons","title":"Condon-Shortley (1935)","text":"","category":"section"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"(moved)","category":"page"},{"location":"conventions/comparisons/#Edmonds-(1960)","page":"Comparisons","title":"Edmonds (1960)","text":"","category":"section"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Edmonds [20] is a standard reference for the theory of angular momentum.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"In Sec. 1.3 he actually does a fair job of defining the Euler angles. The upshot is that his definition agrees with ours, though he uses the \"active\" definition style.  That is, the rotations are to be performed successively in order:","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"A rotation alpha(0 leq alpha  2pi) about the z-axis, bringing the frame of axes from the initial position S into the position S.  The axis of this rotation is commonly called the vertical.\nA rotation beta(0 leq beta  pi) about the y-axis of the frame S, called the line of nodes.  Note that its position is in general different from the initial position of the y-axis of the frame S. The resulting position of the frame of axes is symbolized by S.\nA rotation gamma(0 leq gamma  2pi) about the z-axis of the frame of axes S, called the figure axis; the position of this axis depends on the previous rotations alpha and beta.  The final position of the frame is symbolized by S.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"I would simply write the \"y-axis of the frame S\" as y, and so on.  In quaternionic language, I would write these rotations as expgamma 𝐤2 expbeta 𝐣2 expalpha 𝐤2.  But we also have","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"expbeta 𝐣2 = expalpha 𝐤2 expbeta 𝐣2 exp-alpha 𝐤2","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"so we can just swap the alpha rotation with the beta rotation while dropping the prime from 𝐣.  We can do a similar trick swapping the alpha and beta rotations with the gamma rotation while dropping the double prime from 𝐤. That is, an easy calculation shows that","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"expgamma 𝐤2 expbeta 𝐣2 expalpha 𝐤2\n=\nexpalpha 𝐤2 expbeta 𝐣2 expgamma 𝐤2","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"which is precisely our definition.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"The spherical coordinates are implicitly defined by","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"It should be noted that the polar coordinates varphi theta with respect to the original frame S of the z-axis in its final position are identical with the Euler angles alpha beta respectively.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Again, this agrees with our definition.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"His expression for the angular-momentum operator in Euler angles — Eq. (2.2.2) — agrees with ours:","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"beginaligned\nL_x = -i hbar left\n    -fraccosalphatanbeta fracpartial partial alpha\n    - sinalpha fracpartial partial beta\n    + fraccosalphasinbeta fracpartial partial gamma\nright\n\nL_y = -i hbar left\n    -fracsinalphatanbeta fracpartial partial alpha\n    + cosalpha fracpartial partial beta\n    +fracsinalphasinbeta fracpartial partial gamma\nright\n\nL_z = -i hbar fracpartial partial alpha\nendaligned","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"(The corresponding restriction to spherical coordinates also precisely agrees with our results, with the extra factor of hbar.)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Unfortunately, there is disagreement over the definition of the Wigner D-matrices.  In Eq. (4.1.12) he defines","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"mathcalD_alpha beta gamma =\nexpbig( fracialphahbar J_zbig)\nexpbig( fracibetahbar J_ybig)\nexpbig( fracigammahbar J_zbig)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"which is the conjugate of most other definitions.","category":"page"},{"location":"conventions/comparisons/#Goldberg-et-al.-(1967)","page":"Comparisons","title":"Goldberg et al. (1967)","text":"","category":"section"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Goldberg et al. [21] presented the first paper specifically about spin-weighted spherical harmonics (after Newman and Penrose [7] introduced them), and the first to relate them to the Wigner D-matrices.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"If we relate two vectors by a rotation matrix as x^k = R^kl x^l, then Goldberg et al. define D by its action on spherical harmonics [Eq. (3.3)]:","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Y_ellm(x) = sum_m Y_ellm(x) D^ell_mmleft( R^-1 right)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"They then define the Euler angles as we do, and write [Eq. (3.4)]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"D^ell_m m(alpha beta gamma)\nequiv\nD^ell_m mleft( R(alpha beta gamma)^-1 right)\n=\ne^i m gamma d^ell_m m(beta) e^i m alpha","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Finally, they derive [Eq. (3.9)]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"D^j_m m(alpha beta gamma)\n=\nleftfrac(j+m)(j-m)(j+m)(j-m)right^12\n(sin frac12beta)^2j\nsum_r binomj+mr binomj-mr-m-m\n(-1)^j+m-r\ne^imalpha\n(cot tfrac12beta)^2r-m-m\ne^imgamma","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Equation (3.11) naturally extends to","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"  _sY_ell m(theta phi gamma)\n  =\n  left left(2ell+1right)  4pi right^12\n  D^ell_-sm(phi theta gamma)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"where Eq. (3.4) also shows that D^ell_m m(alpha beta gamma) = D^ell_m m(alpha beta 0) e^i m gamma, so we have","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"  _sY_ell m(theta phi gamma)\n  =\n  _sY_ell m(theta phi) e^-i s gamma","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"This is the most natural extension of the standard spin-weighted spherical harmonics to mathrmSpin(3).  In particular, the spin-weight operator is i partial_gamma, which suggests that it will be most natural to choose the sign of R_𝐮 so that R_z = i partial_gamma.","category":"page"},{"location":"conventions/comparisons/#Griffiths-(1995)","page":"Comparisons","title":"Griffiths (1995)","text":"","category":"section"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Griffiths' \"Introduction to Quantum Mechanics\" is probably the most common introductory text used in undergraduate physics programs, so it would be useful to compare.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Equation (4.27) gives the associated Legendre function as","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"P_ell^m(x)\n=\n(1-x^2)^m2 left(fracddxright)^m P_ell(x)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"and (4.28) gives the Legendre polynomial as","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"P_ell(x)\n=\nfrac12^ell ell left(fracddxright)^ell (x^2-1)^ell","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Then, (4.32) gives the spherical harmonics as","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Y_ell^m(theta phi)\n=\nepsilon\nsqrtfrac2ell+14pi frac(ell-m)(ell+m)\ne^imphi P_ell^m(costheta)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"where epsilon = (-1)^m for mgeq 0 and epsilon = 1 for mleq 0.  In Table 4.2, he explicitly lists the first few spherical harmonics:","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"beginaligned\n  Y_0^0 = left(frac14piright)^12\n  Y_1^0 = left(frac34piright)^12 costheta\n  Y_1^pm 1 = mp left(frac38piright)^12 sintheta e^pm iphi\n  Y_2^0 = left(frac516piright)^12 left(3cos^2theta - 1right)\n  Y_2^pm 1 = mp left(frac158piright)^12 sintheta costheta e^pm iphi\n  Y_2^pm 2 = left(frac1532piright)^12 sin^2theta e^pm 2iphi\n  Y_3^0 = left(frac716piright)^12 left(5cos^3theta - 3costhetaright)\n  Y_3^pm 1 = mp left(frac2164piright)^12 sintheta left(5cos^2theta - 1right) e^pm iphi\n  Y_3^pm 2 = left(frac10532piright)^12 sin^2theta costheta e^pm 2iphi\n  Y_3^pm 3 = mp left(frac3564piright)^12 sin^3theta e^pm 3iphi\nendaligned","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"In Eqs. (4.127)—(4.129), he gives the angular-momentum operators in terms of spherical coordinates:","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"beginaligned\nL_x = frachbari left(\n    -sinphi fracpartial partial theta\n    - cosphi cottheta fracpartial partial phi\nright) \nL_y = frachbari left(\n    cosphi fracpartial partial theta\n    - sinphi cottheta fracpartial partial phi\nright) \nL_z = -i hbar fracpartial partial phi\nendaligned","category":"page"},{"location":"conventions/comparisons/#LALSuite","page":"Comparisons","title":"LALSuite","text":"","category":"section"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"(moved)","category":"page"},{"location":"conventions/comparisons/#Le-Bellac-(2006)","page":"Comparisons","title":"Le Bellac (2006)","text":"","category":"section"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Le Bellac [23] (with Foreword by Cohen-Tannoudji) takes an odd approach, defining [Eq. (10.32)]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"D^(j)_m m left mathcalR(theta phi) right\n=\nlangle j m  e^-iphi J_z e^-itheta J_y  j m rangle","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"but later allowing that e^-i psi J_z usually goes on the right-hand side of the others, in which case D^(j)(theta phi) to D^(j)(phi theta psi).  Figure 10.1 shows that the spherical coordinates are standard (physicist's) coordinates.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Equation (10.65) shows the rotation law:","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Y_ell^mleft( mathcalR^-1 hatr right)\n=\nsum_m D^(ell)_m m(mathcalR) Y_ell^m(hatr)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"and Eq. (10.66) relates the spherical harmonics to the Wigner D-matrices:","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"D^(ell)_m 0(theta phi)\n=\nsqrtfrac4pi2ell+1 leftY_ell^m(theta phi)right^ast","category":"page"},{"location":"conventions/comparisons/#Mathematica","page":"Comparisons","title":"Mathematica","text":"","category":"section"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"The Euler angles are defined generally such that","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"EulerMatrix[{α,β,γ},{a,b,c}] is equivalent to R_αa R_βb R_γc, where R_αa=RotationMatrix[α,UnitVector[3,a]], etc.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"and","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"EulerMatrix[{α,β,γ}] is equivalent to EulerMatrix[{α,β,γ},{3,2,3}]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"(representing the z-y-z convention).","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Finally, we find that they say that EulerMatrix corresponds to three rotations:","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"rα = RotationMatrix[α, {0, 0, 1}];\nrβ = RotationMatrix[β, {0, 1, 0}];\nrγ = RotationMatrix[γ, {0, 0, 1}];\n\nSimplify[rα . rβ . rγ == EulerMatrix[{α, β, γ}]]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"This agrees with the conventions used in this package, so we can directly compare expressions in terms of Euler angles.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"We can find conventions at this page.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"The Wolfram Language uses phase conventions where D^j_m_1 m_2(psi theta phi) = exp(i m_1 psi + i m_2 phi) D^j_m_1 m_2(0 theta 0).","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"WignerD[{1, 0, 1}, ψ, θ, ϕ] = -sqrt2 e^i phi cosfractheta2 sinfractheta2","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"WignerD[{𝓁, 0, m}, θ, ϕ] == Sqrt[(4 π)/(2 𝓁 + 1)] SphericalHarmonicY[𝓁, m, θ, ϕ]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"WignerD[{j, m1, m2},ψ, θ, ϕ] == (-1)^(m1 - m2) Conjugate[WignerD[{j, -m1, -m2}, ψ, θ, ϕ]]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"For ell geq 0, Y_ell^m = sqrt(2ell+1)(4pi) sqrt(ell-m)  (ell+m)  P_ell^m(cos theta) e^imphi where P_ell^m is the associated Legendre function.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"The associated Legendre polynomials are defined by P_n^m(x) = (-1)^m (1-x^2)^m2(d^mdx^m)P_n(x) where P_n(x) is the Legendre polynomial.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"NIST (14.7.13) gives the Legendre polynomial for nonnegative integer n as","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"P_n(x) = frac12^n n fracd^ndx^n (x^2 - 1)^n","category":"page"},{"location":"conventions/comparisons/#Newman-Penrose","page":"Comparisons","title":"Newman-Penrose","text":"","category":"section"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"In their 1966 paper, Newman and Penrose [7], Newman and Penrose first introduced the spin-weighted spherical harmonics, _sY_ell m. They use the standard (physicists') convention for spherical coordinates and introduce the stereographic coordinate zeta = e^iphi cotfractheta2.  They define the spin-raising operator eth acting on a function of spin weight s as","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"eth eta\n=\n-left(sinthetaright)^s\nleft\n    fracpartialpartialtheta\n    + fracisintheta fracpartialpartialphi\nright leftleft(sinthetaright)^-s etaright","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"They then compute","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"_sY_ell m\npropto\nfrac1left(ell-s) (ell+s)right^12\nleft(1 + zeta barzetaright)^-ell\nsum_p zeta^p (-barzeta)^p+s-m\nbinomell-sp binomell+sp+s-m","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"where the sum is over all integers p such that the factorials are nonzero.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"They are a little ambiguous about the relationship of the complex basis vector m^mu to the coordinates.  ","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"The vectors Re(m^mu) and Im(m^mu) may be regarded as orthogonal tangent vectors (of length 2^-12) at each point of the surface. [...] If spherical polar coordinates are used, a natural choice for m^mu is to make Re(m^mu) and Im(m^mu) tangential, respectively, to the curves phi = mathrmconst and theta = mathrmconst","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"The ambiguity is in the sign implied by \"tangential\", but the natural choice is to assume they mean that the components are positive multiples of partial_theta and partial_phi respectively, in which case we have","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"m^mu = frac1sqrt2\nleft partial_theta + i csctheta partial_phi right","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"They define the spin weight in terms of behavior of a quantity under rotation of m^mu in its own plane as","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"(m^mu)\n=\ne^ipsi m^mu\n=\nfrac1sqrt2\nleft \n  left(cospsipartial_theta - sinpsicsctheta partial_phiright)\n  + i left(cospsicsctheta partial_phi + sinpsipartial_thetaright)\nright","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Raising the spherical coordinates (theta phi) to Euler angles (phi theta -psi), we see that the rotor R_phi theta -psi rotates the 𝐳 basis vector to the point (theta phi), and it rotates (𝐱 + i 𝐲)  sqrt2 onto (m^mu). Under this rotation, a quantity eta has spin weight s if it transforms as","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"eta = e^i s psi eta","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Now, supposing that these quantities are functions of Euler angles, we can write","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"eta(phi theta -psi) = e^i s psi eta(phi theta 0)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"or","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"eta(phi theta gamma) = e^-i s gamma eta(phi theta 0)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Thus, the operator with eigenvalue s is i partial_gamma.","category":"page"},{"location":"conventions/comparisons/#NINJA","page":"Comparisons","title":"NINJA","text":"","category":"section"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"(moved)","category":"page"},{"location":"conventions/comparisons/#Sakurai-(1994)","page":"Comparisons","title":"Sakurai (1994)","text":"","category":"section"},{"location":"conventions/comparisons/#Scipy","page":"Comparisons","title":"Scipy","text":"","category":"section"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"scipy.special.sph_harm_y","category":"page"},{"location":"conventions/comparisons/#Shankar-(1994)","page":"Comparisons","title":"Shankar (1994)","text":"","category":"section"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Shankar [24] writes in Eq. (12.5.35) the spherical harmonics as","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Y_ell^m(theta phi)\n=\n(-1)^ell\nleft frac(2ell+1)4pi right^12\nfrac12^ell ell\nleft frac(ell+m)(2ell)(ell-m) right^12\ne^i m phi\n(sin theta)^-m\nfracd^ell-md(costheta)^ell-m\n(sintheta)^2ell","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"for m geq 0, with (12.5.40) giving the expression","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Y_ell^-m(theta phi)\n=\n(-1)^m left( Y_ell^m(theta phi) right)^ast","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"The angular-momentum operators are given below (12.5.27) as","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"beginaligned\nL_x = i hbar left(\n    sinphi fracpartial partial theta\n    + cosphi cottheta fracpartial partial phi\nright)\n\nL_y = i hbar left(\n    -cosphi fracpartial partial theta\n    + sinphi cottheta fracpartial partial phi\nright)\n\nL_z = -i hbar fracpartial partial phi\nendaligned","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"In Exercise 12.5.7, the rotation operator is defined by","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Uleft R(alpha beta gamma) right\n=\ne^-i alpha J_zhbar\ne^-i beta J_yhbar\ne^-i gamma J_zhbar","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"That U becomes a D^(j) when the operator is acting on the states j mrangle for a given j.  Thus, while Shankar never actually uses notation like D^(j)_m m, he does talk about langle j m  D^(j)left R(alpha beta gamma) right  j m rangle.","category":"page"},{"location":"conventions/comparisons/#SymPy","page":"Comparisons","title":"SymPy","text":"","category":"section"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"There is no specific Euler angle convention in SymPy, however it is informative to see what the sympy.algebras.Quaternion.from_euler class method does.  You can specify ","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"SymPy uses what I would consider just a wrong expression for D. Specifically, the source cites Edmonds [20] when defining","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"mathcalD_alpha beta gamma =\nexpbig( fracialphahbar J_zbig)\nexpbig( fracibetahbar J_ybig)\nexpbig( fracigammahbar J_zbig)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"But that is an incorrect copy of Edmonds' Eq. (4.1.9), in which the alpha and gamma on the right-hand side are swapped.  The code also implements D in the wigner_d function as (essentially)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"exp(I*mprime*alpha)*d[i, j]*exp(I*m*gamma)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"even though the actual equation Eq. (4.1.12) of Edmonds says","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"mathscrD^(j)_m m(alpha beta gamma) =\nexp i m gamma d^(j)_m m(alpha beta) exp(i m alpha)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"The d matrix appears to be implemented consistently with Edmonds, and thus not affected.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Basically, it appears that SymPy just swapped the order of the Euler angles relative to Edmonds, who already introduced a conjugate to the definition of the D matrix.","category":"page"},{"location":"conventions/comparisons/#Thorne","page":"Comparisons","title":"Thorne","text":"","category":"section"},{"location":"conventions/comparisons/#Torres-del-Castillo-(2003)","page":"Comparisons","title":"Torres del Castillo (2003)","text":"","category":"section"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Torres Del Castillo [25] starts by defining a rotation mathcalR as transforming a point x_i into another point with coordinates x_i = a_ijx_j.  Under that rotation, any scalar function f transforms into another function f = mathcalR f defined by [Eq. (2.43)]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"fbig(x_ibig) = fbig( a^-1_ij x_j big)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"In particular, f(x_i) = f(x_i).  He then defines Wigner's D-matrix to satisfy [Eq. (2.45)]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"mathcalR Y_lm = sum_m D^l_mm(mathcalR) Y_lm","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Including the arguments to the spherical harmonics, this becomes","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Y_lmbig(mathcalR^-1 R_theta phibig)\n=\nsum_m D^l_mm(mathcalR) Y_lmbig(R_theta phibig)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"In this form, we have [Eq. (2.46)]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"D^l_mm(mathcalR_1 mathcalR_2)\n=\nsum_m D^l_mm(mathcalR_1) D^l_mm(mathcalR_2)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"He computes [Eq. (2.53)]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"D^l_mm(phi theta chi)\n=\ne^-i m phi d^l_mm(theta) e^-i m chi","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"where the d matrix is given by","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"d^l_mm(theta)\n=\nsqrt(l+m)(l-m)(l+m)(l-m)\nsum_k frac\n  (-1)^k\n  (sin tfrac12 theta)^m-m+2k\n  (cos tfrac12 theta)^2l-m+m-2k\n \n  k(l+m-k)(l-m-k)(m-m+k)\n","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"and the spin-weighted spherical harmonic is related to D by","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"_sY_jm(theta phi)\n=\n(-1)^m\nsqrtfrac2j+14pi\nd^j_-ms(theta)\ne^i m phi","category":"page"},{"location":"conventions/comparisons/#Varshalovich-et-al.-(1988)","page":"Comparisons","title":"Varshalovich et al. (1988)","text":"","category":"section"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Varshalovich et al. [26] has a fairly decent comparison of definitions related to the rotation matrix by previous authors.  ","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Eq. 1.4.(31) defines the operator","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"hatD(alpha beta gamma)\n=\ne^-ialpha hatJ_z\ne^-ibeta hatJ_y\ne^-igamma hatJ_z","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"where the hatJ operators are defined in ","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"In quantum mechanics the total angular momentum operator hatJ is defined as an operator which generates transformations of wave functions (state vectors) and quantum operators under infinitesimal rotations of the coordinate system (see Eqs. 2.1.(1) and 2.1.(2)).A transformation of an arbitrary wave function Psi under rotation of the coordinate system through an infinitesimal angle delta omega about an axis mathbfn may be written asPsi to Psi = left(1 - i delta omega mathbfn cdot hatJ right)Psiwhere hatJ is the total angular momentum operator.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Eq. 4.1.(1) defines the Wigner D-functions according to","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"langle J M  hatD(alpha beta gamma)  J M rangle\n=\ndelta_J J D^J_M M(alpha beta gamma)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Eq. 4.3.(1) states","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"D^J_M M(alpha beta gamma)\n=\ne^-i M alpha\nd^J_M M(beta)\ne^-i M gamma","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Page 155 has a table of values for ell leq 5","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Varshalovich et al. [26] distinguish in Sec. 1.1.3 between covariant and contravariant spherical coordinates and the corresponding basis vectors, which they define as","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"beginaligned\n  mathbfe_+1 = - frac1sqrt2 left( mathbfe_x + i mathbfe_yright)\n  \n  mathbfe^+1 = - frac1sqrt2 left( mathbfe_x - i mathbfe_yright) \n  mathbfe_0 = mathbfe_z  mathbfe^0 = mathbfe_z \n  mathbfe_-1 = frac1sqrt2 left( mathbfe_x - i mathbfe_yright)\n  \n  mathbfe^-1 = frac1sqrt2 left( mathbfe_x + i mathbfe_yright)\nendaligned","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Then, in Sec. 4.2 they define hatmathbfJ as the operator of angular momentum of the rigid symmetric top.  They then give in Eq. (6) the \"covariant spherical coordinates of hatmathbfJ in the non-rotating (lab-fixed) system\" as","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"begingather\n  hatJ_pm 1 = fracisqrt2 e^pm i alpha left\n    mp cotbeta fracpartialpartial alpha\n    + i fracpartialpartial beta\n    pm frac1sinbeta fracpartialpartial gamma\n  right \n  hatJ_0 = - i fracpartialpartial alpha\nendgather","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"and \"contravariant components of hatmathbfJ in the rotating (body-fixed) system\" as","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"begingather\n  hatJ^pm 1 = fracisqrt2 e^mp i gamma left\n    pm cotbeta fracpartialpartial gamma\n    + i fracpartialpartial beta\n    mp frac1sinbeta fracpartialpartial alpha\n  right \n  hatJ^0 = - i fracpartialpartial gamma\nendgather","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"(Note the prime in the last two equations.)  We can expand these in Cartesian components to compare to our expressions.  First the covariant components:","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"beginaligned\n  hatJ_x\n  = -frac1sqrt2 left( hatJ_+1 - hatJ_-1 right) \n   = -frac1sqrt2 left( \n     fracisqrt2 e^i alpha left\n       - cotbeta fracpartialpartial alpha\n       + i fracpartialpartial beta\n       + frac1sinbeta fracpartialpartial gamma\n     right\n     -\n     fracisqrt2 e^-i alpha left\n       + cotbeta fracpartialpartial alpha\n       + i fracpartialpartial beta\n       - frac1sinbeta fracpartialpartial gamma\n     right\n   right) \n  = ileft \n      fraccosalphatanbeta fracpartialpartial alpha\n      + sinalpha fracpartialpartial beta\n      - fraccosalphasinbeta fracpartialpartial gamma\n  right \n  hatJ_y\n  = -frac1isqrt2 left( hatJ_+1 + hatJ_-1 right) \n   = -frac1isqrt2 left( \n     fracisqrt2 e^i alpha left\n       - cotbeta fracpartialpartial alpha\n       + i fracpartialpartial beta\n       + frac1sinbeta fracpartialpartial gamma\n     right\n     +\n     fracisqrt2 e^-i alpha left\n       + cotbeta fracpartialpartial alpha\n       + i fracpartialpartial beta\n       - frac1sinbeta fracpartialpartial gamma\n     right\n   right) \n  = i left\n      fracsinalphatanbeta fracpartialpartial alpha\n      - cosalpha fracpartialpartial beta\n      - fracsinalphasinbeta fracpartialpartial gamma\n  right \n  hatJ_z\n  = hatJ_0 \n  = -i fracpartialpartial alpha\nendaligned","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"We can compare these to the Full expressions on S^3 @ref, and find that they are precisely equivalent to expressions for L_j computed in this package's conventions.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Next, the contravariant components:","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"beginaligned\n  hatJ_x\n  = -frac1sqrt2 left( hatJ^+1 - hatJ^-1 right) \n   = -frac1sqrt2 left(\n     fracisqrt2 e^- i gamma left\n       + cotbeta fracpartialpartial gamma\n       + i fracpartialpartial beta\n       - frac1sinbeta fracpartialpartial alpha\n     right\n     -\n     fracisqrt2 e^+ i gamma left\n       - cotbeta fracpartialpartial gamma\n       + i fracpartialpartial beta\n       + frac1sinbeta fracpartialpartial alpha\n     right\n   right) \n  = -i left(\n      fraccosgammatanbeta fracpartialpartial gamma\n      + singamma fracpartialpartial beta\n      - fraccosgammasinbeta fracpartialpartial alpha\n  right) \n  hatJ_y\n  = frac1isqrt2 left( hatJ^+1 + hatJ^-1 right) \n   = frac1isqrt2 left(\n     fracisqrt2 e^-i gamma left\n       + cotbeta fracpartialpartial gamma  \n       + i fracpartialpartial beta\n       - frac1sinbeta fracpartialpartial alpha\n     right\n     +\n     fracisqrt2 e^+ i gamma left\n       - cotbeta fracpartialpartial gamma\n       + i fracpartialpartial beta\n       + frac1sinbeta fracpartialpartial alpha\n     right\n   right) \n  = -i left(\n      fracsingammatanbeta fracpartialpartial gamma\n      - cosgamma fracpartialpartial beta\n      - fracsingammasinbeta fracpartialpartial alpha\n  right) \n  hatJ_z\n  = hatJ^0 \n  = -i fracpartialpartial gamma\nendaligned","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Unfortunately, while we have agreement on hatJ^y = R_y, we also have disagreement on hatJ^x = -R_x and hatJ^z = -R_z, as they have relative minus signs.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"It's very easy to check, for example, that hatJ^z hatJ^x = i hatJ^y, as expected from the general expression in their Eq. (12).  So these expressions are — at least — consistent with the claims of Varshalovich et al.  I wonder if there is some subtlety involving the order of operations and passing to the \"body-fixed\" frame.  I'm confident that my definitions are internally consistent, and fit in nicely with the spin-weighted function literature; maybe Varshalovich et al. are just doing something different.","category":"page"},{"location":"conventions/comparisons/#Wikipedia","page":"Comparisons","title":"Wikipedia","text":"","category":"section"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Defining the operator","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"mathcalR(alphabetagamma) = e^-ialpha J_ze^-ibeta J_ye^-igamma J_z","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Wikipedia defines the Wigner D-matrix as","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"D^j_mm(alphabetagamma) equiv langle jm  mathcalR(alphabetagamma) jm rangle =e^-imalpha  d^j_mm(beta)e^-i mgamma","category":"page"},{"location":"conventions/comparisons/#Wigner","page":"Comparisons","title":"Wigner","text":"","category":"section"},{"location":"conventions/comparisons/#Zettili-(2009)","page":"Comparisons","title":"Zettili (2009)","text":"","category":"section"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Zettili [27] is a relatively recent textbook that seems to be gaining popularity.  (Note that there is a 3rd edition from 2022, but I do not have access to it; all the references here are to the 2nd edition from 2009.)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"In Appendix B.1, we find that the spherical coordinates are related to Cartesian coordinates in the usual (physicist's) way.  Equation (5.132) gives the angular-momentum operator","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"hatL_z = -i hbar fracpartialpartial varphi","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"which agrees with our expression.  This is followed by equation (5.134):","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"hatL_pm\n=\nhatL_x pm i hatL_y\n=\npm hbar e^pm ivarphi left(\n  fracpartialpartial theta\n  pm i cottheta fracpartialpartial varphi\nright)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"which also agrees with our results.","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Equation (5.180) gives the spherical harmonics as","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Y_l m(theta varphi)\n=\nfrac(-1)^l2^l l\nsqrtfrac2l+14pi frac(l+m)(l-m)\ne^imvarphi\nfrac1sin^m theta\nfracd^l-md(costheta)^l-m\n(sin theta)^2l","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Section 7.2.1 denotes by hatR_z(delta phi) the","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"rotation of the coordinates of a spinless particle over an infinitesimal angle delta phi about the z-axis","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"and shows its action [Eq. (7.16)]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"hatR_z (delta phi) psi(r theta phi)\n=\npsi(r theta phi - delta phi)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"We may generalize this relation to a rotation of angle delta phi about an arbitrary axis whose direction is given by the unit vector vecn:","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"hatR(delta phi)\n=\n1 - fracihbar delta phi vecn cdot hatvecL","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"This extends to finite rotation by defining the operator [Eq. (7.48)]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"hatR(alpha beta gamma)\n=\ne^-ialpha J_z  hbar e^-ibeta J_y  hbar e^-igamma J_z  hbar","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Equation (7.52) then defines","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"D^(j)_m m(alpha beta gamma)\n=\nlangle j m  hatR(alpha beta gamma)  j m rangle","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"So that [Eq. (7.54)]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"D^(j)_m m(alpha beta gamma)\n=\ne^-i (m alpha + m gamma) d^(j)_m m(beta)","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"where [Eq. (7.55)]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"d^(j)_m m(beta)\n=\nlangle j m  e^-ibeta J_y  hbar  j m rangle","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"The explicit expression for d is [Eq. (7.56)]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"d^(j)_m m(beta)\n=\nsum_k (-1)^k+m-m\nfracsqrt(j+m)(j-m)(j+m)(j-m)\n(j-m-k)(j+m-k)(k+m-m)k\nleft(cosfracbeta2right)^2j+m-m-2k\nleft(sinfracbeta2right)^m-m+2k","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"In Sec. 7.2.6, we find that if the operator hatR(alpha beta gamma) rotates a vector pointing in the (theta phi) to a vector pointing in the (theta phi) direction, then the spherical harmonics transform as [Eq. (7.70)]","category":"page"},{"location":"conventions/comparisons/","page":"Comparisons","title":"Comparisons","text":"Y_ell m^ast (theta phi)\n=\nsum_m D^(ell)_m m(alpha beta gamma) Y_ell m^ast (theta phi)","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"EditURL = \"../../../literate_input/conventions_comparisons/condon_shortley_1935.jl\"","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/#Condon-Shortley-(1935)","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"","category":"section"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"info: Summary\nCondon and Shortley's definition of the spherical harmonics agrees with the definition used in the SphericalFunctions package.","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"Condon and Shortley's \"The Theory Of Atomic Spectra\" is the standard reference for the \"Condon-Shortley phase convention\".  Though some references are not very clear about precisely what they mean by that phrase, it seems clear that the original meaning included the idea that the angular-momentum raising and lowering operators have eigenvalues that are real and positive when acting on the spherical harmonics.  To avoid ambiguity, we can just look at the actual spherical harmonics they define.","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"The method we use here is as direct and explicit as possible.  In particular, Condon and Shortley provide a formula for the φ=0 part in terms of iterated derivatives of a power of sin(θ).  Rather than expressing these derivatives in terms of the Legendre polynomials — which would subject us to another round of ambiguity — the functions in this module use automatic differentiation to compute the derivatives explicitly.","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"Condon and Shortley are not very explicit about the meaning of the spherical coordinates, but they do describe them as \"spherical polar coordinates r theta varphi\". Immediately before equation (1) of section 4³ (page 50), they define the angular-momentum operator","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"L_z = -i hbar fracpartialpartial varphi","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"which agrees with our expression.  This is followed by equation (8):","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"beginaligned\nL_x + i L_y = hbar e^ivarphi left(\n  fracpartialpartial theta\n  + i cottheta fracpartialpartial varphi\nright) \nL_x - i L_y = hbar e^-ivarphi left(\n  -fracpartialpartial theta\n  + i cottheta fracpartialpartial varphi\nright)\nendaligned","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"which also agrees with our results. We can infer that the definitions of the spherical coordinates are consistent with ours.","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"The result is that the original Condon-Shortley spherical harmonics agree perfectly with the ones computed by this package.","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"(Condon and Shortley do not give an expression for the Wigner D-matrices.)","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/#Implementing-formulas","page":"Condon-Shortley (1935)","title":"Implementing formulas","text":"","category":"section"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"We begin by writing code that implements the formulas from Condon-Shortley.  We encapsulate the formulas in a module so that we can test them against the SphericalFunctions package.","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"using TestItems: @testitem  #hide\n@testitem \"Condon-Shortley conventions\" setup=[ConventionsUtilities, ConventionsSetup, Utilities] begin  #hide\n\nmodule CondonShortley\n\nimport ..ConventionsUtilities: 𝒾, ❗, dʲsin²ᵏθdcosθʲ","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"Equation (12) of section 4³ (page 51) writes the solution to the three-dimensional Laplace equation in spherical coordinates as","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"psi(gamma ell m_ell)\n=\nB(gamma ell) Theta(ell m_ell) Phi(m_ell)","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"where B is independent of theta and varphi, and gamma represents any number of eigenvalues required to specify the state.  More explicitly, below Eq. (5) of section 5⁵ (page 127), they specifically define the spherical harmonics as","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"phi(ell m_ell) = Theta(ell m_ell) Phi(m_ell)","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"One quirk of their notation is that the dependence on theta and varphi is implicit in their functions; we make it explicit, as Julia requires:","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"function 𝜙(ℓ, mₗ, 𝜃, φ)\n    Θ(ℓ, mₗ, 𝜃) * Φ(mₗ, φ)\nend","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"The varphi part is given by equation (5) of section 4³ (page 50):","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"Phi(m_ell)\n=\nfrac1sqrt2pi e^i m_ell varphi","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"Again, we make the dependence on varphi explicit, and we capture its type to ensure that we don't lose precision when converting π to a floating-point number.","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"function Φ(mₗ, φ::T) where {T}\n    1 / √(2T(π)) * exp(𝒾 * mₗ * φ)\nend","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"Equation (15) of section 4³ (page 52) gives the theta dependence as","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"Theta(ell m)\n=\n(-1)^ell\nsqrtfrac(2ell+1)2 frac(ell+m)(ell-m)\nfrac12^ell ell\nfrac1sin^m theta\nfracd^ell-md(costheta)^ell-m sin^2elltheta","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"Again, we make the dependence on theta explicit, and we capture its type to ensure that we don't lose precision when converting the factorials to a floating-point number.","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"function Θ(ℓ, m, 𝜃::T) where {T}\n    (-1)^ℓ * T(√(((2ℓ+1) * (ℓ+m)❗) / (2 * (ℓ - m)❗)) * (1 / (2^ℓ * (ℓ)❗))) *\n    (1 / sin(𝜃)^T(m)) * dʲsin²ᵏθdcosθʲ(j=ℓ-m, k=ℓ, θ=𝜃)\nend","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"It may be helpful to check some values against explicit formulas for the first few spherical harmonics as given by Condon-Shortley in the footnote to Eq. (15) of Sec. 4³ (page 52).  Note the subtle difference between the character Θ defining the function above and the character ϴ defining the function below.","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"ϴ(ℓ, m, 𝜃) = ϴ(Val(ℓ), Val(m), 𝜃)\nϴ(::Val{0}, ::Val{0}, 𝜃) = √(1/2)\nϴ(::Val{1}, ::Val{0}, 𝜃) = √(3/2) * cos(𝜃)\nϴ(::Val{2}, ::Val{0}, 𝜃) = √(5/8) * (2cos(𝜃)^2 - sin(𝜃)^2)\nϴ(::Val{3}, ::Val{0}, 𝜃) = √(7/8) * (2cos(𝜃)^3 - 3cos(𝜃)sin(𝜃)^2)\nϴ(::Val{1}, ::Val{+1}, 𝜃) = -√(3/4) * sin(𝜃)\nϴ(::Val{1}, ::Val{-1}, 𝜃) = +√(3/4) * sin(𝜃)\nϴ(::Val{2}, ::Val{+1}, 𝜃) = -√(15/4) * cos(𝜃) * sin(𝜃)\nϴ(::Val{2}, ::Val{-1}, 𝜃) = +√(15/4) * cos(𝜃) * sin(𝜃)\nϴ(::Val{3}, ::Val{+1}, 𝜃) = -√(21/32) * (4cos(𝜃)^2*sin(𝜃) - sin(𝜃)^3)\nϴ(::Val{3}, ::Val{-1}, 𝜃) = +√(21/32) * (4cos(𝜃)^2*sin(𝜃) - sin(𝜃)^3)\nϴ(::Val{2}, ::Val{+2}, 𝜃) = √(15/16) * sin(𝜃)^2\nϴ(::Val{2}, ::Val{-2}, 𝜃) = √(15/16) * sin(𝜃)^2\nϴ(::Val{3}, ::Val{+2}, 𝜃) = √(105/16) * cos(𝜃) * sin(𝜃)^2\nϴ(::Val{3}, ::Val{-2}, 𝜃) = √(105/16) * cos(𝜃) * sin(𝜃)^2\nϴ(::Val{3}, ::Val{+3}, 𝜃) = -√(35/32) * sin(𝜃)^3\nϴ(::Val{3}, ::Val{-3}, 𝜃) = +√(35/32) * sin(𝜃)^3","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"Condon and Shortley do not give an expression for the Wigner D-matrices, but the convention for spherical harmonics is what they are known for, so this will suffice.","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"end  # module CondonShortley","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/#Tests","page":"Condon-Shortley (1935)","title":"Tests","text":"","category":"section"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"We can now test the functions against the equivalent functions from the SphericalFunctions package.  We will need to test approximate floating-point equality, so we set absolute and relative tolerances (respectively) in terms of the machine epsilon:","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"ϵₐ = 100eps()\nϵᵣ = 1000eps()","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"The explicit formulas will be a good preliminary test.  In this case, the formulas are only given up to","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"ℓₘₐₓ = 3","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"so we test up to that point, and just compare the general form to the explicit formulas — again, noting the subtle difference between the characters Θ and ϴ.  Note that the 1sintheta factor in the general form will cause problems at the poles, so we avoid the poles by using βrange with a small offset:","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"for θ ∈ θrange(; avoid_poles=ϵₐ/10)\n    for (ℓ, m) ∈ eachrow(SphericalFunctions.Yrange(ℓₘₐₓ))\n        @test CondonShortley.ϴ(ℓ, m, θ) ≈ CondonShortley.Θ(ℓ, m, θ) atol=ϵₐ rtol=ϵᵣ\n    end\nend","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"Finally, we can test Condon-Shortley's full expressions for spherical harmonics against the SphericalFunctions package.  We will only test up to","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"ℓₘₐₓ = 4","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"because the formulas are very slow, and this will be sufficient to sort out any sign or normalization differences, which are the most likely source of error.","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"for (θ, ϕ) ∈ θϕrange(; avoid_poles=ϵₐ/40)\n    for (ℓ, m) ∈ ℓmrange(ℓₘₐₓ)\n        @test CondonShortley.𝜙(ℓ, m, θ, ϕ) ≈ SphericalFunctions.Y(ℓ, m, θ, ϕ) atol=ϵₐ rtol=ϵᵣ\n    end\nend","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"This successful test shows that the function phi defined by Condon and Shortley agrees with the spherical harmonics defined by the SphericalFunctions package.","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"end  #hide","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"","category":"page"},{"location":"literate_output/conventions_comparisons/condon_shortley_1935/","page":"Condon-Shortley (1935)","title":"Condon-Shortley (1935)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"While not usually the star of the show, the following utilities can be quite helpful for actually using the rest of the code.","category":"page"},{"location":"utilities/#Complex-powers","page":"Utilities","title":"Complex powers","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"One common task we find when working with spherical functions is the computation of a range of integer powers of some complex number — so much so that it can be best to pre-compute the powers and cache their values.  While a naive approach is generally quite accurate, and reasonably fast, we can do a little better with a specialized routine.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"complex_powers.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#SphericalFunctions.complex_powers!-Tuple{Any, Any}","page":"Utilities","title":"SphericalFunctions.complex_powers!","text":"complex_powers!(zpowers, z)\n\nCompute integer powers of z from z^0 through z^m, recursively, where m is one less than the length of the input zpowers vector.\n\nNote that z is assumed to be normalized, with complex amplitude approximately 1.\n\nSee also: complex_powers\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.complex_powers-Tuple{Any, Int64}","page":"Utilities","title":"SphericalFunctions.complex_powers","text":"complex_powers(z, m)\n\nCompute integer powers of z from z^0 through z^m, recursively.\n\nNote that z is assumed to be normalized, with complex amplitude approximately 1.\n\nThis algorithm is mostly due to Stoer and Bulirsch in \"Introduction to Numerical Analysis\" (page 24) — with a little help from de Moivre's formula, which is essentially exp(iθ)ⁿ = exp(inθ), as well as my own alterations to deal with different behaviors in different quadrants.\n\nThere isn't usually a huge advantage to using this specialized function.  If you just need a particular power, it will generally be far more efficient and just as accurate to compute either exp(iθ)ⁿ or exp(inθ) explicitly.  However, if you need all powers from 0 to m, this function is about 10 or 5 times faster than those options, respectively, for large m.  Like those options, this function is numerically stable, in the sense that its errors are usually smaller than m times the error from machine-precision errors in the input argument — or at worst about 50% larger, which occurs as the phase approaches multiples of π/2.\n\nSee also: complex_powers!\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Sizes-of-and-indexing-into-𝔇,-d,-and-Y-data","page":"Utilities","title":"Sizes of and indexing into 𝔇, d, and Y data","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"By Y data, we mean anything indexed like Y_ell m modes; by D data, we mean anything indexed like Wigner's mathfrakD matrices, or special subsets of them, like the H matrices.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"indexing.jl\", \"wigner_matrices/indexing.jl\", \"wigner_matrices/Hrecursions.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#SphericalFunctions.WignerDindex","page":"Utilities","title":"SphericalFunctions.WignerDindex","text":"WignerDindex(ℓ, m′, m, m′ₘₐₓ=ℓ)\n\nCompute index into Wigner 𝔇 matrix\n\nSee also WignerDrange and WignerDsize.\n\nNotes\n\nThis assumes that the Wigner 𝔇 matrix is arranged as\n\n[\n    𝔇(ℓ, m′, m)\n    for ℓ ∈ ℓₘᵢₙ:ℓₘₐₓ\n    for m′ ∈ -min(ℓ, m′ₘₐₓ):min(ℓ, m′ₘₐₓ)\n    for m ∈ -ℓ:ℓ\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerDrange","page":"Utilities","title":"SphericalFunctions.WignerDrange","text":"WignerDrange(ℓₘₐₓ, m′ₘₐₓ=ℓₘₐₓ)\n\nCreate an array of (ℓ, m', m) indices as in 𝔇 array\n\nSee also WignerDsize and WignerDindex.\n\nNotes\n\nThis assumes that the Wigner 𝔇 matrix is arranged as\n\n[\n    𝔇(ℓ, m′, m)\n    for ℓ ∈ ℓₘᵢₙ:ℓₘₐₓ\n    for m′ ∈ -min(ℓ, m′ₘₐₓ):min(ℓ, m′ₘₐₓ)\n    for m ∈ -ℓ:ℓ\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerDsize-Tuple{Any}","page":"Utilities","title":"SphericalFunctions.WignerDsize","text":"WignerDsize(ℓₘₐₓ, m′ₘₐₓ=ℓₘₐₓ)\n\nCompute total size of Wigner 𝔇 matrix\n\nSee also WignerDrange and WignerDindex.\n\nNotes\n\nThis assumes that the Wigner 𝔇 matrix is arranged as\n\n[\n    𝔇(ℓ, m′, m)\n    for ℓ ∈ ℓₘᵢₙ:ℓₘₐₓ\n    for m′ ∈ -min(ℓ, m′ₘₐₓ):min(ℓ, m′ₘₐₓ)\n    for m ∈ -ℓ:ℓ\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.WignerHindex","page":"Utilities","title":"SphericalFunctions.WignerHindex","text":"WignerHindex(ℓ, m′, m, m′ₘₐₓ)\n\nIndex to \"wedge\" arrays.\n\nSee also WignerHsize and WignerHrange.\n\nNotes\n\nHere, it is assumed that only data with m≥|m'| are stored, and only corresponding values are passed.  We also assume |m|≤ℓ and |m'|≤ℓ.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(ℓ, m′, m) for ℓ ∈ 0:ℓₘₐₓ\n    for m′ ∈ -min(ℓ, m′ₘₐₓ):min(ℓ, m′ₘₐₓ)\n    for m ∈ abs(m′):ℓ\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerHrange","page":"Utilities","title":"SphericalFunctions.WignerHrange","text":"WignerHrange(ℓₘₐₓ, m′ₘₐₓ=ℓₘₐₓ)\n\nCreate an array of (ℓ, m', m) indices as in H array\n\nSee also WignerHsize and WignerHindex\n\nNotes\n\nHere, it is assumed that only data with m≥|m'| are stored, and only corresponding values are passed.  We also assume |m|≤ℓ and |m'|≤ℓ.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(ℓ, m′, m) for ℓ ∈ 0:ℓₘₐₓ\n    for m′ ∈ -min(ℓ, m′ₘₐₓ):min(ℓ, m′ₘₐₓ)\n    for m ∈ abs(m′):ℓ\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerHsize-Tuple{Any}","page":"Utilities","title":"SphericalFunctions.WignerHsize","text":"WignerHsize(ℓₘₐₓ, m′ₘₐₓ=ℓₘₐₓ)\n\nTotal size of array of wedges of width m′ₘₐₓ up to ℓₘₐₓ.  If m′ₘₐₓ is not given, it defaults to ℓₘₐₓ.\n\nSee also WignerHrange and WignerHindex.\n\nNotes\n\nHere, it is assumed that only data with m≥|m′| are stored, and only corresponding values are passed.  We also assume |m|≤ℓ and |m′|≤ℓ.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(ℓ, m′, m) for ℓ ∈ 0:ℓₘₐₓ\n    for m′ ∈ -min(ℓ, m′ₘₐₓ):min(ℓ, m′ₘₐₓ)\n    for m ∈ abs(m′):ℓ\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.Yindex","page":"Utilities","title":"SphericalFunctions.Yindex","text":"Yindex(ℓ, m, ℓₘᵢₙ=0)\n\nCompute index into array of mode weights\n\nParameters\n\nℓ : int     Integer satisfying ℓₘᵢₙ <= ℓ <= ℓₘₐₓ m : int     Integer satisfying -ℓ <= m <= ℓ ℓₘᵢₙ : int, optional     Integer satisfying 0 <= ℓₘᵢₙ.  Defaults to 0.\n\nReturns\n\ni : int     Index of a particular element of the mode-weight array as described below\n\nSee Also\n\nYsize : Total size of array of mode weights Yrange : Array of (ℓ, m) indices corresponding to this array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ℓ, m)\n    for ℓ ∈ ℓₘᵢₙ:ℓₘₐₓ\n    for m ∈ -ℓ:ℓ\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.Yrange-Tuple{Any}","page":"Utilities","title":"SphericalFunctions.Yrange","text":"Yrange(ℓₘᵢₙ, ℓₘₐₓ)\n\nCreate an array of (ℓ, m) indices as in Y array\n\nParameters\n\nℓₘᵢₙ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ ℓₘₐₓ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ\n\nReturns\n\ni : int     Total size of array of mode weights arranged as described below\n\nSee Also\n\nYsize : Total size of array of mode weights Yindex : Index of a particular element of the mode weight array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ℓ, m)\n    for ℓ ∈ ℓₘᵢₙ:ℓₘₐₓ\n    for m ∈ -ℓ:ℓ\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.Ysize-Tuple{Any}","page":"Utilities","title":"SphericalFunctions.Ysize","text":"Ysize(ℓₘₐₓ)\n\nCompute total size of array of mode weights\n\nSee Also\n\nYrange : Array of (ℓ, m) indices corresponding to this array Yindex : Index of a particular element of the mode weight array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ℓ, m)\n    for ℓ ∈ ℓₘᵢₙ:ℓₘₐₓ\n    for m ∈ -ℓ:ℓ\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions._WignerHindex-NTuple{4, Any}","page":"Utilities","title":"SphericalFunctions._WignerHindex","text":"WignerHindex(ℓ, m′, m, m′ₘₐₓ)\n\nHelper function for WignerHindex, with more constraints.\n\nThis function assumes that m ≥ |m′|.  The main WignerHindex function uses symmetries of the H array to account for cases that violate this assumption.  (But note that both that function and this one assume that |m| ≤ ℓ and |m′| ≤ ℓ.)\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.deduce_limits","page":"Utilities","title":"SphericalFunctions.deduce_limits","text":"deduce_limits(ysize, [ℓmin])\n\nDeduce the value of (ℓmin, ℓmax) that produces Y arrays of the given size.\n\nIf ℓmin is not given, it is assumed to be 0.  If it is set to nothing, the smallest possible value of ℓmin will be used.  However, note that this is not a well-posed problem; multiple combinations of (ℓmin, ℓmax) can give rise to Y arrays of the same size.\n\nSee also Ysize\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.phi_theta-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"Utilities","title":"SphericalFunctions.phi_theta","text":"phi_theta(Nϕ, Nθ, [T=Float64])\n\nConstruct (phi, theta) grid in order expected by this package.\n\nSee also theta_phi for the opposite ordering.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.theta_phi-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"Utilities","title":"SphericalFunctions.theta_phi","text":"theta_phi(Nθ, Nϕ, [T=Float64])\n\nConstruct (theta, phi) grid in spinsfast order.\n\nNote that this order is different from the one assumed by this package; use phi_theta for the opposite ordering.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Combinatorics","page":"Utilities","title":"Combinatorics","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Spherical functions frequently involve binomial coefficients and similar terms, with arguments proportional to ℓ, which we aim to allow to be very large — of order 1,000 or more. Unfortunately, due to combinatorical explosions, this is frequently infeasible with naive methods.  Here, we collect any specialized methods that help us beat the limits.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"utils.jl\"]","category":"page"},{"location":"utilities/#SphericalFunctions.sqrtbinomial-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"Utilities","title":"SphericalFunctions.sqrtbinomial","text":"sqrtbinomial(n, k, [T])\n\nEvaluate the square-root of the binomial coefficient binomial(n,k) for large coefficients.\n\nOrdinarily, when n and k are standard Int arguments, the built-in binomial function will overflow around n=66, because it results in Ints.  We need much larger values. This function, which is based on a related one in SpecialFunctions.jl, returns reasonably accurate results up to n ≈ 1026 when k ≈ n/2 (which is the case of interest in many applications in this package).\n\nComputations are carried out (and returned) in type T, which defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"conventions/summary/#Summary","page":"Summary","title":"Summary","text":"","category":"section"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"This page lists the most important conventions used in this package. The following page derives all of these conventions from the very basics (i.e., starting from Cartesian coordinates of 3-dimensional space).","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"Note that we will use Euler angles and spherical coordinates here, but they are not used internally in this package — though conversion functions are available.  It is almost always a bad idea to use Euler angles in computing; quaternions are clearly the preferred representation for numerous reasons.  However, Euler angles are important for (a) comparing to other sources, and (b) performing analytic integrations.  These are the only two uses we will make of Euler angles.","category":"page"},{"location":"conventions/summary/#Fundamental-coordinates","page":"Summary","title":"Fundamental coordinates","text":"","category":"section"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"We use standard right-handed Cartesian coordinates (x y z) and unit basis vectors (𝐱 𝐲 𝐳).","category":"page"},{"location":"conventions/summary/#Spherical-coordinates","page":"Summary","title":"Spherical coordinates","text":"","category":"section"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"We define spherical coordinates (r theta phi) and unit basis vectors (𝐫 boldsymboltheta boldsymbolphi).  The \"polar angle\" theta in 0 pi measures the angle between the specified direction and the positive 𝐳 axis.  The \"azimuthal angle\" phi in 0 2pi) measures the angle between the projection of the specified direction onto the 𝐱-𝐲 plane and the positive 𝐱 axis, with the positive 𝐲 axis corresponding to the positive angle phi = pi2.","category":"page"},{"location":"conventions/summary/#Quaternions","page":"Summary","title":"Quaternions","text":"","category":"section"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"A quaternion is written 𝐐 = W + X𝐢 + Y𝐣 + Z𝐤, where 𝐢𝐣𝐤 = -1.  In software, this quaternion is represented by (W X Y Z).  We will depict a three-dimensional vector 𝐯 = v_x 𝐱 + v_y 𝐲 + v_z 𝐳 interchangeably as a quaternion v_x 𝐢 + v_y 𝐣 + v_z 𝐤.","category":"page"},{"location":"conventions/summary/#Quaternion-rotations","page":"Summary","title":"Quaternion rotations","text":"","category":"section"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"A rotation represented by the unit quaternion 𝐑 acts on a vector 𝐯 as 𝐑 𝐯 𝐑^-1.  Where relevant, rotations will be assumed to be right-handed, so that a quaternion characterizing the rotation through an angle vartheta about a unit vector 𝐮 can be expressed as 𝐑 = exp(vartheta 𝐮2).  Note that -𝐑 would deliver the same rotation, which makes the group of unit quaternions mathrmSpin(3) = mathrmSU(2) is a double cover of the group of rotations mathrmSO(3).  Nonetheless, 𝐑 and -𝐑 are distinct quaternions, and represent distinct \"spinors\".","category":"page"},{"location":"conventions/summary/#Euler-angles","page":"Summary","title":"Euler angles","text":"","category":"section"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"Euler angles parametrize a unit quaternion as 𝐑 = exp(alpha 𝐤2) exp(beta 𝐣2) exp(gamma 𝐤2).  The angles alpha and gamma take values in 0 2pi).  The angle beta takes values in 0 2pi to parametrize the group of unit quaternions mathrmSpin(3) = mathrmSU(2), or in 0 pi to parametrize the group of rotations mathrmSO(3).","category":"page"},{"location":"conventions/summary/#Spherical-coordinates-as-Euler-angles","page":"Summary","title":"Spherical coordinates as Euler angles","text":"","category":"section"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"A point on the unit sphere with spherical coordinates (theta phi) can be represented by Euler angles (alpha beta gamma) = (phi theta 0).  The rotation with these Euler angles takes the positive 𝐳 axis to the specified direction.  In particular, any function of spherical coordinates can be promoted to a function on Euler angles using this identification.","category":"page"},{"location":"conventions/summary/#Left-and-right-angular-momentum-operators","page":"Summary","title":"Left and right angular-momentum operators","text":"","category":"section"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"For a complex-valued function f(𝐑), we define two operators, the left and right angular-momentum operators:","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"L_𝐮 f(𝐑) = lefti fracddepsilonright_epsilon=0\nfleft(e^-epsilon 𝐮2 𝐑right)\nqquad textand qquad\nR_𝐮 f(𝐑) = -lefti fracddepsilonright_epsilon=0\nfleft(𝐑 e^-epsilon 𝐮2right)","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"where 𝐮 can be any quaternion, though unit pure-vector quaternions are the most common.  In particular, L represents the standard angular-momentum operators, and we can compute the expressions in Euler angles for the basis vectors:","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"beginaligned\nL_𝐢 = i left\n    fraccosalphatanbeta fracpartial partial alpha\n    + sinalpha fracpartial partial beta\n    - fraccosalphasinbeta fracpartial partial gamma\nright\n\nR_𝐢 = i left\n    -fraccosgammasinbeta fracpartial partial alpha\n    +singamma fracpartial partial beta\n    +fraccosgammatanbeta fracpartial partial gamma\nright\n\nL_𝐣 = i left\n    fracsinalphatanbeta fracpartial partial alpha\n    - cosalpha fracpartial partial beta\n    -fracsinalphasinbeta fracpartial partial gamma\nright\n\nR_𝐣 = i left\n    fracsingammasinbeta fracpartial partial alpha\n    +cosgamma fracpartial partial beta\n    -fracsingammatanbeta fracpartial partial gamma\nright\n\nL_𝐤 = -i fracpartial partial alpha\n\nR_𝐤 = i fracpartial partial gamma\nendaligned","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"These correspond precisely to the standard expressions for the angular-momentum operators, with 𝐢 leftrightarrow 𝐱, etc.  We also obtain a generalization of the usual commutator relations and find that","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"L_𝐮 L_𝐯 = fraci2 L_𝐮𝐯\nqquad\nR_𝐮 R_𝐯 = fraci2 R_𝐮𝐯\nqquad\nL_𝐮 R_𝐯 = 0","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"Restricting to just the basis vectors, indexed as abc, the first of these reduces to L_a L_b = i epsilon_abc L_c, which is precisely the standard result.  We can also lift any function on S^2 to a function on S^3 — or more precisely any function on spherical coordinates to a function on the space of Euler angles — by the correspondence (theta phi) mapsto (alpha beta gamma) = (phi theta 0).  We can then express the angular-momentum operators in their more common form, in terms of spherical coordinates:","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"L_x = i left\n    fraccosphitantheta fracpartial partial phi\n    + sinphi fracpartial partial theta\nright\nqquad\nL_y = i left\n    fracsinphitantheta fracpartial partial phi\n    - cosphi fracpartial partial theta\nright\nqquad\nL_z = -i fracpartial partial phi","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"The R operators make less sense for a function of spherical coordinates, because of their inherent dependence on gamma  We will come back to them, however, when we consider spin-weighted functions — which are inherently ill-defined on the 2-sphere, but can be interpreted as restrictions of functions on the 3-sphere with this special \"weight\" property.","category":"page"},{"location":"conventions/summary/#Spherical-harmonics","page":"Summary","title":"Spherical harmonics","text":"","category":"section"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"There is essentially no disagreement in the literature about the definitions of the spherical harmonics, so we adopt a function that is consistent with the standard expressions.  More specifically, this package defines the spherical harmonics in terms of Wigner's 𝔇 matrices, by way of the spin-weighted spherical harmonics, as a function of a quaternion.","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"For concreteness, however, we can write the standard expression in terms of spherical coordinates.  This is what our definition will reduce to for spin weight s=0, and transforming the spherical coordinates into a quaternion in the way given above.  Explicitly, in terms of spherical coordinates, that expression is","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"beginalign\n  Y_lm\n  =\n  sqrtfrac2ell+14pi e^imphi\n  sum_k = k_1^k_2\n  frac(-1)^k ell (ell+m)(ell-m)^12\n  (ell+m-k)(ell-k)k(k-m)\n   qquad times\n  left(cosleft(fraciota2right)right)^2ell+m-2k\n  left(sinleft(fraciota2right)right)^2k-m\nendalign","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"where k_1 = textrmmax(0 m) and k_2=textrmmin(ell+m ell).  Again, we must emphasize that this package does not actually use this form; it is just shown here to make it easier to compare to other sources.","category":"page"},{"location":"conventions/summary/#Spin-weighted-functions","page":"Summary","title":"Spin-weighted functions","text":"","category":"section"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"Newman and Penrose [7] define the spherical tangent basis vectors as","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"m^mu = frac1sqrt2 left(\n    boldsymboltheta + i boldsymbolphi\nright)","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"and discuss spin weight in terms of the rotation","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"(m^mu) = e^ipsi m^mu","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"where the tangent basis rotates but we are \"keeping the coordinates fixed\".   We find that we can emulate this using Euler angles (phi theta -psi).  Note the negative sign in the last angle.  As usual, this rotates the positive 𝐳 axis to the point (theta phi), and rotates (𝐱 + i 𝐲)  sqrt2 onto (m^mu).  They then define a function to have spin weight s if it transforms as","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"eta = e^ispsi eta","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"In our notation, we can realize this function as a function of Euler angles, and that equation becomes","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"eta(phi theta -psi) = e^ispsi eta(phi theta 0)","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"or","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"eta(alpha beta gamma) = e^-isgamma eta(alpha beta 0)","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"This is the crucial definition giving us the behavior of spin-weighted functions: they are eigenfunctions of the operator R_z = i partial_gamma with eigenvalue s.","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"We can make this a little less dependent on the choice of Euler angles by writing eta not as a function of Euler angles, but as a function of a quaternion.  We then have","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"eta(mathbfQ e^gamma 𝐤2) = e^-isgamma eta(mathbfQ)","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"which means that spin-weighted functions are eigenfunctions of the operator R_𝐤 with eigenvalue s.","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"We can also immediately find the spin-raising and -lowering operators — canonically denoted eth and bareth — from the commutator relations for R:","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"beginaligned\neth eta = left(R_x + i R_yright)eta\n    = -sin^s theta left\n        fracpartialpartial theta\n        + fracisintheta fracpartialpartial phi\n    right left(eta sin^-s thetaright) \nbareth eta = left(R_x - i R_yright)eta\n    = -sin^s theta left\n        fracpartialpartial theta\n        - fracisintheta fracpartialpartial phi\n    right left(eta sin^-s thetaright)\nendaligned","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"Here, we have used the full expressions for R_x and R_y given above in terms of Euler angles, replacing the derivatives with respect to gamma by a factor of -i s, and converting the remaining Euler angles to spherical coordinates.  This allows us to write them as if they were operators on the 2-sphere, even though this is mathematically ill-defined and spin-weighted functions really must be defined on the 3-sphere.","category":"page"},{"location":"conventions/summary/#Spin-weighted-spherical-harmonics","page":"Summary","title":"Spin-weighted spherical harmonics","text":"","category":"section"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"Given the (scalar) spherical harmonics, and the spin-raising and -lowering operators, we can now define the spin-weighted spherical harmonics.  These are obtained by applying the relevant operator to the scalar spherical harmonics the specified number of times, and normalizing.  Again, this results in a function of a quaternion, but we can write it in terms of spherical coordinates purely for the sake of comparison with other sources.  The expression is","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"beginalign\n  _sY_lm\n  =\n  (-1)^ssqrtfrac2ell+14pi e^imphi\n  sum_k = k_1^k_2\n  frac(-1)^k(ell+m)(ell-m)(ell-s)(ell+s)^12\n  (ell+m-k)(ell+s-k)k(k-s-m)\n   qquad times\n  left(cosleft(fraciota2right)right)^2ell+m+s-2k\n  left(sinleft(fraciota2right)right)^2k-s-m\nendalign","category":"page"},{"location":"conventions/summary/","page":"Summary","title":"Summary","text":"where k_1 = textrmmax(0 m+s) and k_2=textrmmin(ell+m ell+s).","category":"page"},{"location":"conventions/summary/#Wigner-D-matrices","page":"Summary","title":"Wigner D-matrices","text":"","category":"section"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"EditURL = \"../../../literate_input/conventions_comparisons/lalsuite_2025.jl\"","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/#LALSuite-(2025)","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"","category":"section"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"info: Summary\nThe LALSuite definitions of the spherical harmonics and Wigner's d and D functions agree with the definitions used in the SphericalFunctions package.","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"LALSuite (LSC Algorithm Library Suite) is a collection of software routines, comprising the primary official software used by the LIGO-Virgo-KAGRA Collaboration to detect and characterize gravitational waves.  As far as I can tell, the ultimate source for all spin-weighted spherical harmonic values used in LALSuite is the function XLALSpinWeightedSphericalHarmonic, which cites the NINJA paper [30] as its source.  Unfortunately, it cites version 1, which contained a serious error, using tfraccosiota2 instead of cos tfraciota2 and similarly for sin.  This error was corrected in version 2, but the citation was not updated.  Nonetheless, it appears that the actual code is consistent with the corrected versions of the NINJA paper.","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/#Implementing-formulas","page":"LALSuite (2025)","title":"Implementing formulas","text":"","category":"section"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"We begin by directly translating the C code of LALSuite over to Julia code.  There are three functions that we will want to compare with the definitions in this package:","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"COMPLEX16 XLALSpinWeightedSphericalHarmonic( REAL8 theta, REAL8 phi, int s, int l, int m );\ndouble XLALWignerdMatrix( int l, int mp, int m, double beta );\nCOMPLEX16 XLALWignerDMatrix( int l, int mp, int m, double alpha, double beta, double gam );","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"The source code is stored alongside this file, so we will read it in to a String and then apply a series of regular expressions to convert it to Julia code, parse it and evaluate it to turn it into runnable Julia.  We encapsulate the formulas in a module so that we can test them against the SphericalFunctions package.","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"We begin by setting up that module, and introducing a set of basic replacements that would usually be defined in separate C headers.","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"using TestItems: @testitem  #hide\n@testitem \"LALSuite conventions\" setup=[ConventionsUtilities, ConventionsSetup, Utilities] begin  #hide\n\nmodule LALSuite\n\n\nusing Printf: @sprintf\n\nconst I = im\nconst LAL_PI = π\nconst XLAL_EINVAL = \"XLAL Error: Invalid arguments\"\nMIN(a, b) = min(a, b)\ngsl_sf_choose(a, b) = binomial(a, b)\npow(a, b) = a^b\ncexp(a) = exp(a)\ncpolar(a, b) = a * cis(b)\nmacro XLALPrError(msg, args...)\n    quote\n        @error @sprintf($msg, $(args...))\n    end\nend","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"Next, we simply read the source file into a string.","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"lalsource = read(joinpath(@__DIR__, \"lalsuite_SphericalHarmonics.c\"), String)","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"Now we define a series of replacements to apply to the C code to convert it to Julia code. Note that many of these will be quite specific to this particular file, and may not be generally applicable.","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"replacements = (\n    # Deal with newlines in the middle of an assignment\n    r\"( = .*[^;]\\s*)\\n\" => s\"\\1\",\n\n    # Remove a couple old, unused functions\n    r\"(?ms)XLALScalarSphericalHarmonic.*?\\n}\" => \"# Removed\",\n    r\"(?ms)XLALSphHarm.*?\\n}\" => \"# Removed\",\n\n    # Remove type annotations\n    r\"COMPLEX16 ?\" => \"\",\n    r\"REAL8 ?\" => \"\",\n    r\"INT4 ?\" => \"\",\n    r\"int ?\" => \"\",\n    r\"double ?\" => \"\",\n\n    # Translate comments\n    \"/*\" => \"#=\",\n    \"*/\" => \"=#\",\n\n    # Brackets\n    r\" ?{\" => \"\",\n    r\"}.*(\\n *else)\" => s\"\\1\",\n    r\"} *else\" => \"else\",\n    r\"^}\" => \"\",\n    \"}\" => \"end\",\n\n    # Flow control\n    r\"( *if.*);\"=>s\"\\1 end\\n\",  ## one-line `if` statements\n    \"for( s=0; n-s >= 0; s++ )\" => \"for s=0:n\",\n    \"else if\" => \"elseif\",\n    r\"(?m)  break;\\n *\\n *case(.*?):\" => s\"elseif m == \\1\",\n    r\"(?m)  break;\\n\\s*case(.*?):\" => s\"elseif m == \\1\",\n    r\"(?m)  break;\\n *\\n *default:\" => \"else\",\n    r\"(?m)  break;\\n *default:\" => \"else\",\n    r\"(?m)switch.*?\\n *\\n( *)case(.*?):\" => s\"\\n\\1if m == \\2\",\n    r\"\\n *break;\" => \"\",\n    r\"(?m)(else\\n *ans = fac;)(\\n *return ans;)\" => s\"\\1\\n  end\\2\",\n\n    # Deal with ugly C declarations\n    \"f1 = (x-1)/2.0, f2 = (x+1)/2.0\" => \"f1 = (x-1)/2.0; f2 = (x+1)/2.0\",\n    \"sum=0, val=0\" => \"sum=0; val=0\",\n    \"a=0, lam=0\" => \"a=0; lam=0\",\n    r\"\\n *fac;\" => \"\",\n    r\"\\n *ans;\" => \"\",\n    r\"\\n *gslStatus;\" => \"\",\n    r\"\\n *gsl_sf_result pLm;\" => \"\",\n    r\"\\n ?XLAL\" => \"\\nfunction XLAL\",\n\n    # Differences in Julia syntax\n    \"++\" => \"+=1\",\n    \".*\" => \". *\",\n    \"./\" => \". /\",\n    \".+\" => \". +\",\n    \".-\" => \". -\",\n\n    # Deal with random bad syntax\n    \"if (m)\" => \"if m != 0\",\n    \"case 4:\" => \"elseif m == 4\",\n    \"XLALPrError\" => \"@XLALPrError\",\n    \"__func__\" => \"\\\"\\\"\",\n)","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"And we apply the replacements to the source code to convert it to Julia code.  Note that we apply them successively, even though replace can handle multiple \"simultaneous\" replacements, because the order of replacements is important.","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"for (pattern, replacement) in replacements\n    global lalsource = replace(lalsource, pattern => replacement)\nend\nprintln.(lalsource); @debug \"Remember to remove this line\"","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"Finally, we just parse and evaluate the code to turn it into a runnable Julia, and we are done defining the module","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"eval(Meta.parseall(lalsource))\n\nend  # module LALSuite","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/#Tests","page":"LALSuite (2025)","title":"Tests","text":"","category":"section"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"We can now test the functions against the equivalent functions from the SphericalFunctions package.  We will need to test approximate floating-point equality, so we set absolute and relative tolerances (respectively) in terms of the machine epsilon:","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"ϵₐ = 100eps()\nϵᵣ = 100eps()","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"The spin-weighted spherical harmonics are defined explicitly, but only for","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"s = -2","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"and only up to","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"ℓₘₐₓ = 8","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"so we only test up to that point.","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"for (θ, ϕ) ∈ θϕrange()\n    for (ℓ, m) ∈ ℓmrange(abs(s), ℓₘₐₓ)\n        @test LALSuite.XLALSpinWeightedSphericalHarmonic(θ, ϕ, s, ℓ, m) ≈\n            SphericalFunctions.Y(s, ℓ, m, θ, ϕ) atol=ϵₐ rtol=ϵᵣ\n    end\nend","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"Now, the Wigner d matrices are defined generally, but we only need to test up to","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"ℓₘₐₓ = 4","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"because the formulas are fairly inefficient and inaccurate, and this will be sufficient to sort out any sign or normalization differences, which are the most likely sources of error.","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"for β ∈ βrange()\n    for (ℓ, m′, m) ∈ ℓm′mrange(ℓₘₐₓ)\n        @test LALSuite.XLALWignerdMatrix(ℓ, m′, m, β) ≈ SphericalFunctions.d(ℓ, m′, m, β) atol=ϵₐ rtol=ϵᵣ\n    end\nend","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"We can see more-or-less by inspection that the code defines the D matrix in agreement with our convention, the key line being","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"cexp( -(1.0I)*mp*alpha ) * XLALWignerdMatrix( l, mp, m, beta ) * cexp( -(1.0I)*m*gam );","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"And because of the higher dimensionality of the space in which to test, we want to restrict the range of the tests to avoid excessive computation.  We will test up to","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"ℓₘₐₓ = 2","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"because the space of options for disagreement is smaller.","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"for (α,β,γ) ∈ αβγrange()\n    for (ℓ, m′, m) ∈ ℓm′mrange(ℓₘₐₓ)\n        @test LALSuite.XLALWignerDMatrix(ℓ, m′, m, α, β, γ) ≈\n            conj(SphericalFunctions.D(ℓ, m′, m, α, β, γ)) atol=ϵₐ rtol=ϵᵣ\n    end\nend\n@test_broken false  # We haven't flipped the conjugation of D yet","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"These successful tests show that the spin-weighted spherical harmonics and the Wigner d and D matrices defined in LALSuite agree with the corresponding functions defined by the SphericalFunctions package.","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"end  #hide","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"","category":"page"},{"location":"literate_output/conventions_comparisons/lalsuite_2025/","page":"LALSuite (2025)","title":"LALSuite (2025)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"conventions/outline/#Outline","page":"Outline","title":"Outline","text":"","category":"section"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"Three-dimensional Euclidean space\nCartesian coordinates (x y z) => ℝ³\nCartesian basis vectors (𝐱 𝐲 𝐳)\nEuclidean norm => Euclidean metric\nSpherical coordinates\nSpecifically give transformation to/from (x y z)\nDerive metric in these coordinates from transformation\nIntegration / measure on two-sphere\nDerive as restriction of full metric, in both coordinate systems\nFour-dimensional Euclidean space\nEight-dimensional Clifford algebra over the tangent vector space Tℝ³\nFour-dimensional even sub-algebra => ℝ⁴\nCoordinates (W X Y Z)\nBasis vectors (𝟏 𝐢 𝐣 𝐤), but we usually just omit 𝟏\nShow a few essential formulas establishing the product and its conventions\nUnit quaternions are isomorphic to mathbfSpin(3) = mathbfSU(2); double covers mathbfSO(3)\nBe explicit about the mapping between vector in ℝ³ and quaternions\nShow how a unit quaternion can be used to rotate a vector\nSpherical coordinates (hyperspherical / Euler)\nSpecifically give transformation to/from (W X Y Z)\nDerive metric in these coordinates from transformation\nExpress unit quaternion in Euler angles\nIntegration / measure / Haar measure on three-sphere\nDerive as restriction of full metric, in both coordinate systems\nAngular momentum operators / functional analysis\nExpress angular momentum operators in terms of quaternion components\nExpress angular momentum operators in terms of Euler angles\nShow for both the three- and two-spheres\nShow how they act on functions on the three-sphere\nRepresentation theory / harmonic analysis\nRepresentations show up in Fourier analysis on groups\nPeter-Weyl theorem\nGeneralizes Fourier analysis to compact groups\nA basis of functions on the group is given by matrix elements of group representations\nRepresentation theory of mathbfSpin(3)\nShow how the Lie algebra is represented by the angular-momentum operators\nShow how the Lie group is represented by the Wigner D-matrices\nDemonstrate that mathfrakD is a representation\nDemonstrate its behavior under left and right rotation\nDemonstrate orthonormality\nRepresentation theory of mathbfSO(3)\nThere are several places in Folland (e.g., above corollary 5.48) where he mentions that representations of a quotient group are just representations that are trivial (evidently meaning mapping everything to the identity matrix) on the factor.  I can't find anywhere that he explains this explicitly, but it seems easy enough to show.  He might do it using characters.\nFor mathbfSpin(3) and mathbfSO(3), the factor group is just 1 -1.  Presumably, every representation acting on 1 will give the identity matrix, so that's trivial.  So we just need a criterion for when a representation is trivial on -1.  Noting that exp(pi vecv) = -1 for any vecv, I think we can show that this requires m in mathbbZ.\nBasically, the point is that the representations of mathbfSO(3) are just the integer representations of mathbfSpin(3).\nRestrict to homogeneous space (S³ -> S²)\nThe circle group is a closed (normal?) subgroup of mathbfSpin(3), which we might implement as initial multiplication about a particular axis.\nIn Eq. (2.47) Folland (2016) defines a functional taking a function on the group to a function on the homogeneous space by integrating over the factor (the circle group).  This gives you the spherical harmonics, but not the spin-weighted spherical harmonics — because the spin-weighted spherical harmonics cannot be defined on the 2-sphere.\nSpin weight comes from Fourier analysis on the subgroup.\nRepresentation matrices transfer to the homogeneous space, with sparsity patterns","category":"page"},{"location":"conventions/outline/#Notes","page":"Outline","title":"Notes","text":"","category":"section"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"Spherical harmonics as functions on homogeneous space. https://www.youtube.com/watch?v=TnFvOa9v7do gives some nice discussion; maybe the paper has better references.","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"Theorem 2.16 of Hanson-Yakovlev says that an orthonormal basis of a product of L^2 spaces is given by the product of the orthonormal bases of the individual spaces. Furthermore, on page 354, they point out that (1sqrt2pi) e^imphi is an orthonormal basis of L^2(02pi), while the set 1c_nm P_n^m(costheta) is an orthonormal basis of L^2(0 pi) in the theta coordinate.  Therefore, the product of these two sets is an orthonormal basis of the product space L^2left((02pi) times (0 pi)right), which forms a coordinate space for S^2.  I would probably modify this to point out that (02pi) is really S^1, and then we could extend it to point out that you can throw on another factor of S^1 to cover S^3, which happens to give us the Wigner D-matrices.","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"We first define the rotor that takes (hatx haty hatz) onto (hattheta hatphi hatr).  Then, we can invert that, so that given a rotor that specifies such a rotation exactly, we can get the spherical coordinates — or specifically sintheta, costheta, and exp(iphi).","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"Then, with the universally agreed-upon Y as given in terms of spherical coordinates, we can rewrite it directly to work with quaternion components, and then it immediately applies to general rotations, which allows us to figure out where the s should go. That is, we can essentially derive _sY from the universal formula for Y.","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"Then, we can simply follow Wigner around Eq. (15.21) to derived a transformation law in the form","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"_sY_ellm(R_theta phi) = sum_m M_mm(R)\n_sY_ellm(R_theta phi)","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"for some matrix M.  Note that I have written this as if the _sY functions are column vectors.  The reason this happens is because I want to write R_theta phi = R R_theta phi, rather than swapping the order of the rotations on the right-hand side.","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"The big problem here is that Wigner, in his Eq. (15.21) defines the transformation matrix as if the eigenfunctions formed a row vector instead of a column vector, which means that his matrix is transposed compared to what I want to write.  I suppose maybe other authors then just consider the inverse rotation, so that they can work with the conjugate transpose, which is why we see the relative conjugate.","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"Since Y is universal, let's start with that as non-negotiable, and see if we can derive the relationship to mathfrakD.\nR_theta phi is a unit quaternion that rotates the point described by Cartesian coordinates (0,0,1) onto the point described by spherical coordinates (theta phi).\nJust textually, it makes the most sense to write\nR_theta phi = R R_theta phi\nfor some rotation R.  Now, we just need to interpret R.\nAgain, just textually, it makes the most sense to write\nY_ellm(theta phi) = sum_m mathfrakD^(ell)_mm(R)\nY_ellm(theta phi)\nor, generalizing to spin-weighted spherical harmonics\n_sY_ellm(R_theta phi) = sum_m mathfrakD^(ell)_mm(R)\n_sY_ellm(R_theta phi)\nWe also have that mathfrakD obeys the representation property, so\nmathfrakD^(ell)_mm(R_theta phi)\n= sum_m mathfrakD^(ell)_mm(R)\nmathfrakD^(ell)_mm(R_theta phi)\nThere is no reason that I can see to introduce a conjugation\nThe fact that m appears on both sides of the equation means that it must correspond to s — though we have to check the behavior under final rotation to determine the sign.","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"_sY_ellm(R_theta phi)\npropto\nmathfrakD^(ell)_mpropto s(R_theta phi)","category":"page"},{"location":"conventions/outline/#collapsible-markdown?","page":"Outline","title":"collapsible markdown?","text":"","category":"section"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"<details><summary>CLICK ME</summary>","category":"page"},{"location":"conventions/outline/#yes,-even-hidden-code-blocks!","page":"Outline","title":"yes, even hidden code blocks!","text":"","category":"section"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"println(\"hello world!\")","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"</details>","category":"page"},{"location":"conventions/outline/#More-notes","page":"Outline","title":"More notes","text":"","category":"section"},{"location":"conventions/outline/#Spherical-harmonics","page":"Outline","title":"Spherical harmonics","text":"","category":"section"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"Fortunately, there does not seem to be any disagreement in the physics literature about the definition of the spherical harmonics; everyone uses the Condon-Shortley convention.  Or at least, they say they do. The problem arises when people define the spherical harmonics in terms of the Legendre polynomials, for which there is a sign ambiguity. Therefore, to ensure that we are using the same conventions, we need to go back to the original definition of the spherical harmonics by Condon and Shortley.","category":"page"},{"location":"conventions/outline/#Condon-Shortley-phase","page":"Outline","title":"Condon-Shortley phase","text":"","category":"section"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"The Condon-Shortley phase convention is a choice of phase factors in the definition of the spherical harmonics that requires the coefficients in","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"L_pm ellmrangle = alpha^pm_ellm ell m pm 1rangle","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"to be real and positive.  The reasoning behind this choice is explained more fully in Section 2 of Ufford and Shortley (1932).  As a more practical matter, the Condon-Shortley phase describes signs chosen in the expression for spherical harmonics.  The key expression is Eq. (15) of section 4³ (page 52) of Condon-Shortley:","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"Theta(ell m) = (-1)^ell sqrtfrac2ell+12 frac(ell+m)(ell-m)\nfrac12^ell ell frac1sin^mtheta\nfracd^ell-md(costheta)^ell-m sin^2elltheta","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"When multiplied by Eq. (5) Phi(m) = e^imphi  sqrt2pi, this gives the spherical harmonic function.  The right-hand side of the expression above is usually immediately replaced by a simpler expression using Legendre polynomials, but this just shifts sign ambiguity into the definition of the Legendre polynomials.  Instead, we can expand the above expression directly for the first few ell values and/or use automatic differentiation to actually test their original expression as such against the function implemented in this package.  The first few values are given in a footnote to Condon and Shortley's Eq. (15) (and have been verified separately by hand and by computation with SymPy):","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"beginaligned\nTheta(00) = sqrtfrac12 \nTheta(10) = sqrtfrac32 costheta \nTheta(1pm1) = mp sqrtfrac34 sintheta \nTheta(20) = sqrtfrac58 (2cos^2theta - sin^2theta) \nTheta(2pm1) = mp sqrtfrac154 costheta sintheta \nTheta(2pm2) = sqrtfrac1516 sin^2theta \nTheta(30) = sqrtfrac78 (2cos^3theta - 3costhetasin^2theta) \nTheta(3pm1) = mp sqrtfrac2132 (4cos^2thetasintheta - sin^3theta) \nTheta(3pm2) = sqrtfrac10516 costheta sin^2theta \nTheta(3pm3) = mp sqrtfrac3532 sin^3theta\nendaligned","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"These are tested, along with the results from automatic differentiation, every time this package is updated.  The result is perfect agreement, so that we can definitively say that ***the spherical-harmonic functions provided by this package obey the Condon-Shortley phase convention.***","category":"page"},{"location":"conventions/outline/#Angular-momentum-operators","page":"Outline","title":"Angular-momentum operators","text":"","category":"section"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"First, a couple points about -ihbar:\nThe finite transformations look like exp-i theta L_j, but the factor of i introduced here just cancels the one in the L_j, and the sign is just chosen to make the result consistent with our notion of active or passive transformations.\nAny factors of hbar are included purely for the sake of  convenience.\nThe factor i comes from plain functional analysis: We need a self-adjoint operator, and partial_x by itself is anti-self-adjoint (as can be verified by evaluating on langle x  x rangle = delta(x-x), which switches sign based on which is being differentiated).  We want self-adjoint operators so that we get purely real eigenvalues.  Van Neerven cites this in a more rigorous context in his Example (10.40) (page 331), with more explanation around Eq. (15.17) (page 592).  The \"self-adjoint iff real eigenvalues\" condition is item (1) in his Corollary 9.18.","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"Wigner's 𝔇 matrices are defined as matrix elements of a rotation in the basis of spherical harmonics.  That rotation is defined in terms of the generators of rotation, which are expressed in terms of the angular-momentum operators.  Therefore, to really understand conventions for the 𝔇 matrices, we need to understand conventions for the angular-momentum operators.","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"There is universal agreement that the angular momentum is defined as mathbfL = mathbfx times mathbfp, where mathbfx is the position vector and mathbfp is the momentum vector.  In quantum mechanics, there is further agreement that the momentum operator becomes -ihbarnabla.  Thus, in operator form, the angular momentum can be decomposed as","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"beginaligned\nL_x = -ihbar left( y fracpartialpartial z - z fracpartialpartial y right) \nL_y = -ihbar left( z fracpartialpartial x - x fracpartialpartial z right) \nL_z = -ihbar left( x fracpartialpartial y - y fracpartialpartial x right)\nendaligned","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"We can transform these to use spherical coordinates and obtain","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"beginaligned\nL_x = -ihbar left( sinphi fracpartialpartialtheta + cottheta cosphi fracpartialpartialphi right) \nL_y = -ihbar left( cosphi fracpartialpartialtheta - cottheta sinphi fracpartialpartialphi right) \nL_z = -ihbar fracpartialpartialphi\nendaligned","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"The conventions we choose must be chosen to agree with these — modulo factors of hbar, which are nonstandard in mathematics.  We will have to check this, and the Condon-Shortley requirement that when applied to spherical harmonics they produce real and positive coefficients.","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"I defined these in Eqs. (42) and (43) of Boyle (2016) as","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"beginaligned\nL_j f(mathbfR) colonequals -z left fracpartialpartial theta\nfleft(e^theta mathbfe_j  2 mathbfR right) right_theta=0 \nK_j f(mathbfR) colonequals -z left fracpartialpartial theta\nfleft(mathbfR e^theta mathbfe_j  2right) right_theta=0\nendaligned","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"where mathbfe_j is the unit vector in the j direction. Surprisingly, I found that Edmonds expresses essentially the same thing in the equations following his Eq. (4.1.5).","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"Condon and Shortley's Eq. (1) of section 4³ (page 50) defines","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"L_z = -i hbar fracpartialpartial phi","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"while Eq. (8) on the following page defines","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"beginaligned\nL_x + i L_y = hbar e^iphi left( fracpartialpartial theta + i cottheta fracpartialpartial phi right) \nL_x - i L_y = hbar e^-iphi left(-fracpartialpartial theta + i cottheta fracpartialpartial phi right)\nendaligned","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"Note that one is not the conjugate of the other!  This is because of the factors of -i in the definitions of L_x and L_y.","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"Edmonds gives the total angular-momentum operator for a rigid body in Eq. (2.2.2) as","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"beginaligned\nL_x = -ihbar left(-cos alpha cotbeta fracpartialpartialalpha - sinalpha fracpartialpartialbeta + fraccosalphasinbeta fracpartialpartialgamma right) \nL_y = -ihbar left(-sinalpha cotbeta fracpartialpartial alpha + cosalpha fracpartialpartialbeta + fracsinalphasinbeta fracpartialpartialgamma right) \nL_z = -ihbar fracpartialpartialalpha\nendaligned","category":"page"},{"location":"conventions/outline/#Wigner-𝔇-and-d-matrices","page":"Outline","title":"Wigner 𝔇 and d matrices","text":"","category":"section"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"Wigner's Eqs. (11.18) and (11.19) define the real orthogonal transformation mathbfR by","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"x_i = R_ij x_j","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"and the operator mathbfP_mathbfR to act on a function f such that","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"mathbfP_mathbfR f(x_1 ldots) = f(x_1 ldots)","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"Then, his Eq. (15.5) presumably implies","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"Y_ellm(vartheta varphi)\n= mathbfP_alpha beta gamma Y_ellm(vartheta varphi)\n= sum_m mathfrakD^(ell)(alpha beta gamma)_mm\n  Y_ellm(vartheta varphi)","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"where alpha beta gamma takes (vartheta varphi) to (vartheta varphi).  In any case, we can now leave behind this mathbfP notation and just look at the beginning and end of the equation above as the critical relationship in Wigner's notation.","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"Eq. (44b) of Boyle (2016) says","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"L_pm mathfrakD^(ell)_mm(mathbfR)\n= sqrt(ell mp m)(ell pm m + 1) mathfrakD^(ell)_m pm 1 m(mathbfR)","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"while Eq. (21) relates the Wigner D-matrix to the spin-weighted spherical harmonics as","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"_sY_ellm(mathbfR)\n= (-1)^s sqrtfrac2ell+14pi mathfrakD^(ell)_m-s(mathbfR)","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"Plugging the latter into the former, we get","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"L_pm _sY_ellm(mathbfR)\n= sqrt(ell mp m)(ell pm m + 1) _sY_ellm pm 1(mathbfR)","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"That is, in our conventions we have","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"alpha^pm_ellm = sqrt(ell mp m)(ell pm m + 1)","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"which is always real and positive, and thus consistent with the Condon-Shortley phase convention.","category":"page"},{"location":"conventions/outline/#Properties","page":"Outline","title":"Properties","text":"","category":"section"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"D^j_mm(alphabetagamma) = (-1)^m-m D^j_-m-m(alphabetagamma)^*\n(-1)^m-mD^j_mm(alphabetagamma)=D^j_mm(gammabetaalpha)\nd_mm^j=(-1)^m-md_mm^j=d_-m-m^j","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"beginaligned\nd_mm^j(pi)        = (-1)^j-m  delta_m-m 6pt\nd_mm^j(pi-beta)  = (-1)^j+m  d_m-m^j(beta)6pt\nd_mm^j(pi+beta)  = (-1)^j-m  d_m-m^j(beta)6pt\nd_mm^j(2pi+beta) = (-1)^2j    d_mm^j(beta)6pt\nd_mm^j(-beta)     = d_mm^j(beta) = (-1)^m-m d_mm^j(beta)\nendaligned","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"begingather\nR = cosepsilon + sinepsilon hatmathfrakr \nR𝐯 = cosepsilon 𝐯 + sinepsilon hatmathfrakr𝐯 \nR𝐯R^-1 = (𝐯cosepsilon + sinepsilon hatmathfrakr𝐯)(cosepsilon - sinepsilon hatmathfrakr) \nR𝐯R^-1 = 𝐯cos^2epsilon + sin^2epsilon hatmathfrakr𝐯hatmathfrakr^-1 + sinepsilon cosepsilon (hatmathfrakr𝐯 - 𝐯hatmathfrakr) \nR𝐯R^-1 = begincases\n𝐯  𝐯 hatmathfrakr = hatmathfrakr𝐯 \n𝐯(cos^2epsilon - sin^2epsilon) + 2 sinepsilon cosepsilon frachatmathfrakr 𝐯2  𝐯 hatmathfrakr = -hatmathfrakr𝐯 \nendcases \nR𝐯R^-1 = begincases\n𝐯  𝐯 hatmathfrakr = hatmathfrakr𝐯 \ncos2epsilon 𝐯 + sin2epsilon frachatmathfrakr 𝐯2  𝐯 hatmathfrakr = -hatmathfrakr𝐯 \nendcases \nendgather","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"Using techniques from geometric algebra, we can easily prove that the result is another vector, so we can measure its (squared) norm just by multiplying it by itself:","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"beginaligned\n 𝐑 𝐯 𝐑^-1 ^2\n= 𝐑 𝐯 𝐑^-1 𝐑 𝐯 𝐑^-1 \n= 𝐑 𝐯 𝐯 𝐑^-1 \n= 𝐯^2 𝐑 𝐑^-1 \n= 𝐯^2\nendaligned","category":"page"},{"location":"conventions/outline/","page":"Outline","title":"Outline","text":"That is, 𝐯 = 𝐑 𝐯 𝐑^-1 has the same norm as 𝐯, which means that 𝐯 is a rotation of 𝐯.  Given the constraint on the norm of 𝐑, we can rewrite it as","category":"page"},{"location":"functions/#Complete-function-list","page":"Complete function list","title":"Complete function list","text":"","category":"section"},{"location":"functions/","page":"Complete function list","title":"Complete function list","text":"The following list contains all documented functions inside the SphericalFunctions module.","category":"page"},{"location":"functions/","page":"Complete function list","title":"Complete function list","text":"Modules = [SphericalFunctions]","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"EditURL = \"../../../literate_input/conventions_comparisons/ninja_2011.jl\"","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/#NINJA-(2011)","page":"NINJA (2011)","title":"NINJA (2011)","text":"","category":"section"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"info: Summary\nThe NINJA collaboration's definitions of the spherical harmonics and Wigner's d functions agree with the definitions used in the SphericalFunctions package.","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"Motivated by the need for a shared set of conventions in the NINJA project, a broad cross-section of researchers involved in modeling gravitational waves (including the author of this package) prepared Ref. [30].  It is worth noting that the first version posted to the arXiv included an unfortunate typo in the definition of the spin-weighted spherical harmonics.  This was corrected in the second version, and remains correct in the final — third — version.","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"The spherical coordinates are standard physicists' coordinates, except that the polar angle is denoted iota:","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"we define standard spherical coordinates (r ι φ) where ι is the inclination angle from the z-axis and φ is the phase angle.","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/#Implementing-formulas","page":"NINJA (2011)","title":"Implementing formulas","text":"","category":"section"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"We begin by writing code that implements the formulas from Ref. [30].  We encapsulate the formulas in a module so that we can test them against the SphericalFunctions package.","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"using TestItems: @testitem  #hide\n@testitem \"NINJA conventions\" setup=[ConventionsUtilities, ConventionsSetup, Utilities] begin  #hide\n\nmodule NINJA\n\nimport ..ConventionsUtilities: 𝒾, ❗","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"The spin-weighted spherical harmonics are defined in Eq. (II.7) as","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"  ^-sY_lm = (-1)^s sqrtfrac2l+14pi\n  d^l_ms(iota) e^imphi","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"Just for convenience, we eliminate the negative sign on the left-hand side:","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"  ^sY_lm = (-1)^-s sqrtfrac2l+14pi\n  d^l_m-s(iota) e^imphi","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"function ₛYₗₘ(s, l, m, ι::T, ϕ::T) where {T<:Real}\n    (-1)^(-s) * √((2l + 1) / (4T(π))) * d(l, m, -s, ι) * exp(𝒾 * m * ϕ)\nend","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"Immediately following that, in Eq. (II.8), we find the definition of Wigner's d function (again, noting that this expression was incorrect in version 1 of the paper, but correct in versions 2 and 3):","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"  d^l_ms(iota)\n  =\n  sum_k = k_1^k_2\n  frac(-1)^k (l+m)(l-m)(l+s)(l-s)^12\n  (l+m-k)(l-s-k)k(k+s-m)\n  left(cosleft(fraciota2right)right)^2l+m-s-2k\n  left(sinleft(fraciota2right)right)^2k+s-m","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"with k_1 = textrmmax(0 m-s) and k_2=textrmmin(l+m l-s).","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"function d(l, m, s, ι::T) where {T<:Real}\n    k₁ = max(0, m - s)\n    k₂ = min(l + m, l - s)\n    sum(\n        (-1)^k\n        * T(\n            ((l + m)❗ * (l - m)❗ * (l + s)❗ * (l - s)❗)^(1//2)\n           / ((l + m - k)❗ * (l - s - k)❗ * (k)❗ * (k + s - m)❗)\n        )\n         * cos(ι / 2) ^ (2l + m - s - 2k)\n         * sin(ι / 2) ^ (2k + s - m)\n        for k in k₁:k₂;\n        init=zero(T)\n    )\nend","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"For reference, several explicit formulas are also provided in Eqs.  (II.9)–(II.13):","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"beginaligned\n  ^-2Y_22 = sqrtfrac564pi (1+cosiota)^2 e^2iphi\n  ^-2Y_21 = sqrtfrac516pi siniota (1 + cosiota) e^iphi\n  ^-2Y_20 = sqrtfrac1532pi sin^2iota\n  ^-2Y_2-1 = sqrtfrac516pi siniota (1 - cosiota) e^-iphi\n  ^-2Y_2-2 = sqrtfrac564pi (1-cosiota)^2 e^-2iphi\nendaligned","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"₋₂Y₂₂(ι::T, ϕ::T) where {T<:Real} = √(5 / (64T(π))) * (1 + cos(ι))^2 * exp(2𝒾*ϕ)\n₋₂Y₂₁(ι::T, ϕ::T) where {T<:Real} = √(5 / (16T(π))) * sin(ι) * (1 + cos(ι)) * exp(𝒾*ϕ)\n₋₂Y₂₀(ι::T, ϕ::T) where {T<:Real} = √(15 / (32T(π))) * sin(ι)^2\n₋₂Y₂₋₁(ι::T, ϕ::T) where {T<:Real} = √(5 / (16T(π))) * sin(ι) * (1 - cos(ι)) * exp(-𝒾*ϕ)\n₋₂Y₂₋₂(ι::T, ϕ::T) where {T<:Real} = √(5 / (64T(π))) * (1 - cos(ι))^2 * exp(-2𝒾*ϕ)","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"The paper did not give an expression for the Wigner D-matrices, but the definition of the spin-weighted spherical harmonics is probably most relevant, so this will suffice.","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"end  # module NINJA","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/#Tests","page":"NINJA (2011)","title":"Tests","text":"","category":"section"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"We can now test the functions against the equivalent functions from the SphericalFunctions package.  We will need to test approximate floating-point equality, so we set absolute and relative tolerances (respectively) in terms of the machine epsilon:","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"ϵₐ = 10eps()\nϵᵣ = 10eps()","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"First, we compare the explicit formulas to the general formulas.","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"for (ι, ϕ) ∈ θϕrange(Float64, 1)\n    @test NINJA.ₛYₗₘ(-2, 2, 2, ι, ϕ) ≈ NINJA.₋₂Y₂₂(ι, ϕ) atol=ϵₐ rtol=ϵᵣ\n    @test NINJA.ₛYₗₘ(-2, 2, 1, ι, ϕ) ≈ NINJA.₋₂Y₂₁(ι, ϕ) atol=ϵₐ rtol=ϵᵣ\n    @test NINJA.ₛYₗₘ(-2, 2, 0, ι, ϕ) ≈ NINJA.₋₂Y₂₀(ι, ϕ) atol=ϵₐ rtol=ϵᵣ\n    @test NINJA.ₛYₗₘ(-2, 2, -1, ι, ϕ) ≈ NINJA.₋₂Y₂₋₁(ι, ϕ) atol=ϵₐ rtol=ϵᵣ\n    @test NINJA.ₛYₗₘ(-2, 2, -2, ι, ϕ) ≈ NINJA.₋₂Y₂₋₂(ι, ϕ) atol=ϵₐ rtol=ϵᵣ\nend","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"Next, we compare the general formulas to the SphericalFunctions package. We will only test up to","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"ℓₘₐₓ = 4","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"and","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"sₘₐₓ = 2","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"because the formulas are very slow, and this will be sufficient to sort out any sign or normalization differences, which are the most likely source of error.","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"for (θ, ϕ) ∈ θϕrange()\n    for (s, ℓ, m) ∈ sℓmrange(ℓₘₐₓ, sₘₐₓ)\n        @test NINJA.ₛYₗₘ(s, ℓ, m, θ, ϕ) ≈ SphericalFunctions.Y(s, ℓ, m, θ, ϕ) atol=ϵₐ rtol=ϵᵣ\n    end\nend","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"Finally, we compare the Wigner d matrix to the SphericalFunctions package.","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"for ι ∈ θrange()\n    for (ℓ, m′, m) ∈ ℓm′mrange(ℓₘₐₓ)\n        @test NINJA.d(ℓ, m′, m, ι) ≈ SphericalFunctions.d(ℓ, m′, m, ι) atol=ϵₐ rtol=ϵᵣ\n    end\nend","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"These successful tests show that both the spin-weighted spherical harmonics and the Wigner d matrix defined by the NINJA collaboration agree with the corresponding functions defined by the SphericalFunctions package.","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"end  #hide","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"","category":"page"},{"location":"literate_output/conventions_comparisons/ninja_2011/","page":"NINJA (2011)","title":"NINJA (2011)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"transformations/#s-SHT-Transformations","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"","category":"section"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"One important capability of this package is the transformation between the two representations of a spin-weighted spherical function:","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"Values f of the function evaluated on a set of points or \"pixels\" in the domain of the function.\nValues f̃ of the mode weights (coefficients) of an expansion in the standard spin-weighted spherical-harmonic basis.","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"In the literature, the transformation f ↦ f̃ is usually called \"analysis\" or map2salm, while the inverse transformation f ↦ f̃ is called \"synthesis\" or salm2map.  These are both referred to as spin-spherical-harmonic transforms, or s-SHTs.","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"To describe the values of a spin-s function up to some maximum angular resolution ell_mathrmmax, we need (ell_mathrmmax+1)^2 - s^2 mode weights.  We assume throughout that the values f̃ are stored as","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"f̃ = [mode_weight(ℓ, m) for ℓ ∈ abs(s):ℓₘₐₓ for m ∈ -ℓ:ℓ]","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"(Here, mode_weight is a made-up function intended to provide a schematic.)  In particular, the m index varies most rapidly, and the ell index varies most slowly.  Correspondingly, there must be at least (ell_mathrmmax+1)^2 - s^2 function values f.  However, some s-SHT algorithms require more function values — usually by a factor of 2 or 4 — trading off between speed and memory usage.","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"The SSHT object implements these transformations, storing pre-computed constants and pre-allocated workspace for the transformations.  The interface is designed to be similar to that of FFTW.jl, whereby an SSHT object 𝒯 can be used to perform the transformation as either","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"f = 𝒯 * f̃","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"or","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"f̃ = 𝒯 \\ f","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"Currently, there are three algorithms implemented, each having different advantages and disadvantages:","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"The \"Direct\" algorithm (introduced here for the first time), which is the default, but should only be used up to ell_mathrmmax lesssim 50 because its intermediate storage requirements scale as ell_mathrmmax^4.  This algorithm is the fastest for small ell_mathrmmax, it can be used with arbitrary (non-degenerate) pixelizations, and achieves optimal dimensionality.\nThe \"Minimal\" algorithm due to Elahi et al. [2], with some minor improvements.  This algorithm is fast and — as the name implies — also achieves optimal dimensionality, and its storage scales as ell_mathrmmax^3.  However, its pixelization is restricted, and its accuracy at very high ell_mathrmmax is not as good as the \"RS\" algorithm.  The algorithm itself is not actually fully specified by Elahi et al., and leaves out some relatively simple improvements, so I have had to take some liberties with my interpretation.\nThe \"RS\" algorithm due to Reinecke and Seljebotn [3].  This forms the basis for the libsharp and ducc.sht packages.  It requires pixelizations on \"iso-latitude rings\", and does not achieve optimal dimensionality.  However, it is very fast, and its accuracy is excellent at extremely high ell_mathrmmax.","category":"page"},{"location":"transformations/#SSHT-objects","page":"s-SHT Transformations","title":"SSHT objects","text":"","category":"section"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"Modules = [SphericalFunctions]\nPages   = [\"ssht.jl\", \"ssht/direct.jl\", \"ssht/minimal.jl\", \"ssht/rs.jl\"]","category":"page"},{"location":"transformations/#SphericalFunctions.SSHT","page":"s-SHT Transformations","title":"SphericalFunctions.SSHT","text":"Supertype of storage for spin-spherical-harmonic transforms\n\n\n\n\n\n","category":"type"},{"location":"transformations/#SphericalFunctions.SSHT-Tuple{Any, Any}","page":"s-SHT Transformations","title":"SphericalFunctions.SSHT","text":"SSHT(s, ℓₘₐₓ; [method=\"Direct\"], [T=Float64], [kwargs...])\n\nConstruct an SSHT object to transform between spin-weighted spherical-harmonic mode weights and function values — performing an s-SHT.\n\nThis object behaves similarly to an AbstractFFTs.Plan object — specifically in the ability to use the semantics of algebra to perform transforms.  For example, if the function values are stored as a vector f, the mode weights as f̃, and the SSHT as 𝒯, then we can compute the function values from the mode weights as\n\nf = 𝒯 * f̃\n\nor solve for the mode weights from the function values as\n\nf̃ = 𝒯 \\ f\n\nThe first dimensions of f̃ must index the mode weights (as usual, for ℓ∈abs(s):ℓₘₐₓ and m∈-ℓ:ℓ) and the first index of f must index the locations at which the function is evaluated.  Any following dimensions will be broadcast over.  Note that certain types will broadcast using Julia threads, while others will broadcast using BLAS threads.  The relevant number of threads must be set appropriately.\n\nCertain SSHT types (currently, only Minimal and Direct) also have an option to always act in place — meaning that they simply re-use the input storage, even when used in an expression like 𝒯 \\ f.  The option must be passed as the inplace argument to the constructors, and is part of the type of the resulting object.  Regardless of the value of that option, for those types where the option exists, it is also possible to use mul! and ldiv! from the LinearAlgebra package to force operation in place.\n\nNote that different algorithms require different \"pixelizations\", or sets of Rotors on which to evaluate the function.  These can be obtained from the SSHT object using the pixels and rotors functions.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.pixels","page":"s-SHT Transformations","title":"SphericalFunctions.pixels","text":"pixels(𝒯)\n\nReturn the spherical coordinates (θ, ϕ) on which the spin-weighted spherical harmonics are evaluated.  See also rotors, which provides the actual Rotors on which they are evaluated.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#SphericalFunctions.rotors","page":"s-SHT Transformations","title":"SphericalFunctions.rotors","text":"rotors(𝒯)\n\nReturn the Rotors on which the spin-weighted spherical harmonics are evaluated.  See also pixels, which provides the corresponding spherical coordinates.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#SphericalFunctions.SSHTDirect","page":"s-SHT Transformations","title":"SphericalFunctions.SSHTDirect","text":"SSHTDirect(s, ℓₘₐₓ; decomposition=LinearAlgebra.qr, T=Float64, Rθϕ=golden_ratio_spiral_rotors(s, ℓₘₐₓ, T), inplace=true)\n\nConstruct an s-SHT object that uses the \"Direct\" method; see ₛ𝐘 for details about the method and optional arguments.  Also see SSHT for general information about how to use these objects.\n\nBy default, this uses precisely optimal sampling — meaning that the number of points on which the function is evaluated, represented by Rθϕ, is equal to the number of modes.  However, it is equally possible to evaluate on more points than there are modes.  This can be useful, for example, when processing multiple fields with different spin weights; the function could be evaluated on points appropriate for the lowest value of s, and therefore could also be used to solve for fields of all other spin weights.\n\nNote that in-place operation is possible for this type when the length of the input Rθϕ is equal to the number of modes given s and ℓₘₐₓ — and is the default behavior when possible.  See SSHT for description of in-place operation.\n\nThis method is typically better than other current implementations for ℓₘₐₓ  24, both in terms of speed and accuracy.  However, this advantage quickly falls away.  A warning will be issued if ℓₘₐₓ is greater than about 64, because this method is not likely to be the most efficient or most accurate choice.\n\n\n\n\n\n","category":"type"},{"location":"transformations/#SphericalFunctions.SSHTMinimal","page":"s-SHT Transformations","title":"SphericalFunctions.SSHTMinimal","text":"Storage for Minimal spin-spherical-harmonic transform\n\nThe Minimal algorithm was described by Elahi et al., and allows for the minimal number of function samples.\n\n\n\n\n\n","category":"type"},{"location":"transformations/#SphericalFunctions.SSHTMinimal-Union{Tuple{TT}, Tuple{Any, Any}} where TT","page":"s-SHT Transformations","title":"SphericalFunctions.SSHTMinimal","text":"SSHTMinimal(s, ℓₘₐₓ; kwargs...)\n\nConstruct a SSHTMinimal object directly.  This may also be achieved by calling the main SSHT function with the same keywords, along with method=\"Minimal\".\n\nThis object uses the algorithm described by Elahi et al.\n\nThe basic floating-point number type may be adjusted with the keyword argument T, which defaults to Float64.\n\nThe SSHs are evaluated on a series of \"rings\" at constant colatitude.  Their locations are specified by the θ keyword argument, which defaults to sorted_rings(s, ℓₘₐₓ, T).  The first element of θ is the colatitude of the smallest ring (containing 2s+1 elements), and so on to the last element of θ, which is the colatitude of the largest ring (containing 2ℓₘₐₓ+1 elements).\n\nWhenever T is either Float64 or Float32, the keyword arguments plan_fft_flags and plan_fft_timelimit may also be useful for obtaining more efficient FFTs.  They default to FFTW.ESTIMATE and Inf, respectively.  They are passed to AbstractFFTs.plan_fft.\n\nNote that, because this algorithm achieves optimal dimensionality, the transformation will be performed in place by default.  If this is not desired, pass the keyword argument inplace=false.  This will cause the algorithm to copy the input and perform in-place transformation on that copy.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.SSHTRS","page":"s-SHT Transformations","title":"SphericalFunctions.SSHTRS","text":"Storage for  spin-spherical-harmonic transform\n\nThe algorithm was described in by Reinecke and Seljebotn.\n\n\n\n\n\n","category":"type"},{"location":"transformations/#SphericalFunctions.SSHTRS-Union{Tuple{TT}, Tuple{Any, Any}} where TT","page":"s-SHT Transformations","title":"SphericalFunctions.SSHTRS","text":"SSHTRS(s, ℓₘₐₓ; kwargs...)\n\nConstruct a SSHTRS object directly.  This may also be achieved by calling the main SSHT function with the same keywords, along with method=\"RS\".\n\nThis object uses the algorithm described by Reinecke and Seljebotn.\n\nThe basic floating-point number type may be adjusted with the keyword argument T, which defaults to Float64.\n\nThe SSHs are evaluated on a series of \"rings\" at constant colatitude.  Their locations are specified by the θ keyword argument, which defaults to fejer1_rings(2ℓₘₐₓ+1, T).  If this is changed, the user should also provide the corresponding quadrature_weights argument — the default being fejer1(length(θ), T).\n\nOn each of these rings, an FFT is performed.  To reach the band limit of m =  ℓₘₐₓ, the number of points along each ring must therefore be at least 2ℓₘₐₓ+1, but may be greater.  For example, if 2ℓₘₐₓ+1 does not factorize neatly into a product of small primes, it may be preferable to use 2ℓₘₐₓ+2 points along each ring.  (In that case, whenever ℓₘₐₓ is 1 less than a power of 2, the number of points will be exactly a power of 2, which is usually particularly efficient.)  The number of points on each ring can be modified independently, if given as a vector with the same length as θ, or as a single number which is assumed to be the same for all rings.\n\nWhenever T is either Float64 or Float32, the keyword arguments plan_fft_flags and plan_fft_timelimit may also be useful for obtaining more efficient FFTs.  They default to FFTW.ESTIMATE and Inf, respectively.  They are passed to AbstractFFTs.plan_fft.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#Pixelizations","page":"s-SHT Transformations","title":"Pixelizations","text":"","category":"section"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"The algorithms implemented here require pixelizations.  While the \"Direct\" algorithm can be used with arbitrary pixelizations, the \"Minimal\" and \"RS\" algorithms require more specific choices, as noted in their docstrings.","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"Typically, \"pixelization\" refers exclusively to a choice of points on the sphere 𝕊² at which to compute function values.  Of course, as mentioned elsewhere, it is not technically possible to define spin-weighted functions as functions of a point on 𝕊² alone; we also need some sense of reference direction in the tangent space.  Quite generally, we can define spin-weighted functions on the group 𝐒𝐎(3) or 𝐒𝐩𝐢𝐧(3), so we will also refer to a choice of a set of points in 𝐒𝐩𝐢𝐧(3) (which is essentially the group of unit quaternions) as a \"pixelization\".  However, assuming spherical coordinates, a choice of coordinates on the sphere almost everywhere induces a choice of the reference direction in the tangent space, so it is almost possible to define pixelizations just in terms of points on 𝕊².  But using spherical coordinates is actually enough to fully specify the pixelization, because the degeneracies at the poles also allow us to define the reference direction.","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"In principle, we could be concerned about the choice of reference direction in the tangent space.  That is, we might expect to care about pixelizations over 𝕊³.  However, we are dealing with spin-weighted functions, which are eigenfunctions of a final rotation about the reference direction.  This means that once we choose any reference direction at each point, we know the function values for any other reference direction at those points.  In particular, an important property of a pixelization is the condition number of the transformation matrix between the function values and the mode weights.  If we rotate the reference direction at a single point, this is equivalent to multiplying the matrix by a diagonal matrix with entries of 1 everywhere except the entry corresponding to that point, where the entry is some complex phase.  This does not change the condition number of the matrix, so we can ignore the choice of reference direction at every point.  For other situations, where we might care about the choice of reference direction, it might be interesting to consider this work by Marc Alexa, and references therein.","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"Interesting discussions of various pixelizations and metrics can be found in Saff and Kuijlaars (1997) and Brauchart and Grabner (2015), as well as blog posts here and here. Note that the \"equal-area\" pixelizations of Healpix are very restrictive—only being available for very specific numbers of points—and do not provide any obvious advantages over the more flexible pixelizations available here.","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"The various pixelizations may be computed as follows:","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"Modules = [SphericalFunctions]\nPages   = [\"pixelizations.jl\"]","category":"page"},{"location":"transformations/#SphericalFunctions.clenshaw_curtis_rings-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T","page":"s-SHT Transformations","title":"SphericalFunctions.clenshaw_curtis_rings","text":"clenshaw_curtis_rings(N, [T=Float64])\n\nValues of the colatitude coordinate (θ) appropriate for quadrature by the Clenshaw-Curtis rule, using weights provided by clenshaw_curtis.\n\nNote that the first argument to this function is N, rather than the ℓₘₐₓ used in some other functions.  For spin-weighted spherical harmonics, you may want to use N=2ℓₘₐₓ+1.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.fejer1_rings-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T","page":"s-SHT Transformations","title":"SphericalFunctions.fejer1_rings","text":"fejer1_rings(N, [T=Float64])\n\nValues of the colatitude coordinate (θ) appropriate for quadrature by Fejér's first rule, using weights provided by fejer1.\n\nNote that the first argument to this function is N, rather than the ℓₘₐₓ used in some other functions.  For spin-weighted spherical harmonics, you may want to use N=2ℓₘₐₓ+1.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.fejer2_rings-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T","page":"s-SHT Transformations","title":"SphericalFunctions.fejer2_rings","text":"fejer2_rings(N, [T=Float64])\n\nValues of the colatitude coordinate (θ) appropriate for quadrature by Fejér's second rule, using weights provided by fejer2.\n\nNote that the first argument to this function is N, rather than the ℓₘₐₓ used in some other functions.  For spin-weighted spherical harmonics, you may want to use N=2ℓₘₐₓ+1.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.golden_ratio_spiral_pixels-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"s-SHT Transformations","title":"SphericalFunctions.golden_ratio_spiral_pixels","text":"golden_ratio_spiral_pixels(s, ℓₘₐₓ, [T=Float64])\n\nCover the sphere 𝕊² with pixels generated by the golden-ratio spiral. Successive pixels are separated by the azimuthal angle Δϕ = 2π(2-φ), and are uniformly distributed in cos θ.\n\nThis is also known as the \"Fibonacci sphere\" or \"Fibonacci lattice\".\n\nVisually, this is a very reasonable-looking pixelization, with fairly uniform distance between neighbors, and approximate isotropy.  No two pixels will share the same values of either θ or ϕ.  Also note that no point is present on either the North or South poles.\n\nThe returned quantity is a vector of 2-SVectors providing the spherical coordinates of each pixel.  See also golden_ratio_spiral_rotors for the corresponding Rotors.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.golden_ratio_spiral_rotors-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"s-SHT Transformations","title":"SphericalFunctions.golden_ratio_spiral_rotors","text":"golden_ratio_spiral_rotors(s, ℓₘₐₓ, [T=Float64])\n\nCover the sphere 𝕊² with pixels generated by the golden-ratio spiral.\n\nSee golden_ratio_spiral_pixels for more detailed explanation.  The quantity returned by this function is a vector of Rotors providing each pixel.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.sorted_ring_pixels-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"s-SHT Transformations","title":"SphericalFunctions.sorted_ring_pixels","text":"sorted_ring_pixels(s, ℓₘₐₓ, [T=Float64])\n\nCover the sphere 𝕊² with (ℓₘₐₓ+1)²-s² pixels distributed in rings provided by sorted_rings; see that function's documentation for more description.\n\nThe returned quantity is a vector of 2-SVectors containing the spherical coordinates of each pixel.  See also sorted_ring_rotors for the corresponding Rotors.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.sorted_ring_rotors-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"s-SHT Transformations","title":"SphericalFunctions.sorted_ring_rotors","text":"sorted_ring_rotors(s, ℓₘₐₓ, [T=Float64])\n\nCover the sphere 𝕊² with (ℓₘₐₓ+1)²-s² pixels distributed in rings provided by sorted_rings; see that function's documentation for more description.\n\nThe returned quantity is a vector of Rotors.  See also sorted_ring_rotors for the corresponding spherical coordinates.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.sorted_rings-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"s-SHT Transformations","title":"SphericalFunctions.sorted_rings","text":"sorted_rings(s, ℓₘₐₓ, [T=Float64])\n\nCompute locations of a series of rings labelled by j  sℓₘₐₓ (analogous to ℓ), where each ring will contain k = 2j+1 (analogous to m) pixels distributed evenly around the ring.  These rings are then sorted, so that the ring with the most pixels (j = ℓₘₐₓ) is closest to the equator, and the next-largest ring is placed just above or below the equator (depending on the sign of s), the next just below or above, and so on.  This is generally a fairly good first guess when minimizing the condition number of matrices used to solve for mode weights from function values.  In particular, I use this to initialize the Minimal algorithm, which is then fed into an optimizer to fine-tune the positions of the rings.\n\nThis function does not provide the individual pixels; it just provides the colatitude values of the rings on which the pixels will be placed.  The pixels themselves are provided by sorted_ring_pixels.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#Quadrature-weights","page":"s-SHT Transformations","title":"Quadrature weights","text":"","category":"section"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"The \"RS\" algorithm requires quadrature weights corresponding to the input pixelization.  Though there is a working default choice, it is possible to use others.  There are several that are currently implemented, along with their corresponding pixelizations:","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"Modules = [SphericalFunctions]\nPages   = [\"weights.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"transformations/#SphericalFunctions.clenshaw_curtis-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"s-SHT Transformations","title":"SphericalFunctions.clenshaw_curtis","text":"clenshaw_curtis(n, [T])\n\nCompute n weights for the Clenshaw-Curtis rule, corresponding to n evenly spaced nodes from 0 to π inclusive.  That is, the nodes are located at\n\ntheta_k = k fracpin-1 quad k=0 ldots n-1\n\nThis function uses Waldvogel's method.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.fejer1-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"s-SHT Transformations","title":"SphericalFunctions.fejer1","text":"fejer1(n, [T])\n\nCompute n weights for Fejér's first rule, corresponding to n evenly spaced nodes from 0 to π inclusive.  That is, the nodes are located at\n\ntheta_k = k fracpin-1 quad k=0 ldots n-1\n\nThis function uses Waldvogel's method.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.fejer2-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"s-SHT Transformations","title":"SphericalFunctions.fejer2","text":"fejer2(n, [T])\n\nCompute n weights for Fejér's second rule, corresponding to n evenly spaced nodes between 0 and π exclusive.  That is, the nodes are located at\n\ntheta_k = k fracpin+1 quad k=1 ldots n\n\nThis function uses Waldvogel's method.  However, contrary to Waldvogel's notation, this routine does not include the weight corresponding to the ϑ=0 or π nodes, which both have weight 0.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"EditURL = \"../../literate_input/euler_angular_momentum.jl\"","category":"page"},{"location":"literate_output/euler_angular_momentum/#L_j-and-R_j-with-Euler-angles","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"","category":"section"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"This package defines the angular-momentum operators L_j and R_j in terms of elements of the Lie group and algebra:","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"L_𝐮 f(𝐑) = left i fracddepsilonright_epsilon=0\nfleft(e^-epsilon 𝐮2 𝐑right)\nqquad textand qquad\nR_𝐮 f(𝐑) = -left i fracddepsilonright_epsilon=0\nfleft(𝐑 e^-epsilon 𝐮2right)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"This is certainly the natural realm for these operators, but it is not the common one.  In particular, virtually all textbooks and papers on the subject define these operators in terms of the standard spherical coordinates on the 2-sphere, rather than quaternions or even Euler angles.  In particular, the standard forms are essentially always given in terms of the Cartesian basis, as in L_x, L_y, and L_z — though some times the first two are expressed as L_pm = L_x pm i L_y.","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"Here, we will use SymPy to just grind through the algebra of expressing the angular-momentum operators in terms of Euler angles, including evaluating the commutators in that form, and further reduce them to operators in terms of spherical coordinates.  We will find a couple important results that help make contact with more standard expressions:","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"Our results for L_x, L_x, and L_z in spherical coordinates agree with standard expressions.\nThe commutators obey L_x L_y = i L_z and cyclic permutations, in agreement with the standard expressions.\nWe also find R_x R_y = i R_z and cyclic permutations.\nWe can explicitly compute L_i R_j = 0, as expected.\nUsing the natural extension of Goldberg et al.'s SWSHs to include gamma, we can see that the natural spin-weight operator is R_z = i partial_gamma.  Thus, we define R_z = s for a function with spin weight s.\nThe spin-raising operator for R_z is eth = R_x + i R_y; the spin-lowering operator is bareth = R_x - i R_y.","category":"page"},{"location":"literate_output/euler_angular_momentum/#Analytical-groundwork","page":"L_j and R_j with Euler angles","title":"Analytical groundwork","text":"","category":"section"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"We start by defining a new set of Euler angles according to","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"mathbfR_alpha beta gamma\n= e^-epsilon mathbfu  2 mathbfR_alpha beta gamma\nqquad textor qquad\nmathbfR_alpha beta gamma\n= mathbfR_alpha beta gamma e^-epsilon mathbfu  2","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"where mathbfu will be each of the basis quaternions, and each of alpha, beta, and gamma is a function of alpha, beta, gamma, and epsilon.  Then, we note that the chain rule tells us that","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"fracpartialpartial epsilon\n=\nfracpartial alphapartial epsilon fracpartialpartial alpha\n+ fracpartial betapartial epsilon fracpartialpartial beta\n+ fracpartial gammapartial epsilon fracpartialpartial gamma","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"which we will use to convert the general expression for the angular-momentum operators in terms of partial_epsilon into an expression in terms of derivatives with respect to these new Euler angles:","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"beginalign\n  L_j f(mathbfR_alpha beta gamma)\n  =\n  left i fracpartial partial epsilon f left( e^-epsilon mathbfe_j  2\n  mathbfR_alpha beta gamma right) right_epsilon=0\n  \n  =\n  i left left(\n      fracpartial alphapartial epsilon fracpartialpartial alpha\n      + fracpartial betapartial epsilon fracpartialpartial beta\n      + fracpartial gammapartial epsilon fracpartialpartial gamma\n  right) f left(alpha beta gammaright) right_epsilon=0\n  \n  =\n  i left left(\n      fracpartial alphapartial epsilon fracpartialpartial alpha\n      + fracpartial betapartial epsilon fracpartialpartial beta\n      + fracpartial gammapartial epsilon fracpartialpartial gamma\n  right) f left(alpha beta gammaright) right_epsilon=0\nendalign","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"or for R_j:","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"beginalign\n  R_j f(mathbfR_alpha beta gamma)\n  =\n  -left i fracpartial partial epsilon f left( mathbfR_alpha beta gamma\n  e^-epsilon mathbfe_j  2 right) right_epsilon=0\n  \n  =\n  -i left left(\n      fracpartial alphapartial epsilon fracpartialpartial alpha\n      + fracpartial betapartial epsilon fracpartialpartial beta\n      + fracpartial gammapartial epsilon fracpartialpartial gamma\n  right) f left(alpha beta gammaright) right_epsilon=0\nendalign","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"So the objective is to find the new Euler angles, differentiate with respect to epsilon, and then evaluate at epsilon = 0.  We do this by first multiplying mathbfR_alpha beta gamma and e^-epsilon mathbfu  2 in the desired order, then expanding the results in terms of its quaternion components, and then computing the new Euler angles in terms of those components according to the usual expression.","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"import SymPyPythonCall","category":"page"},{"location":"literate_output/euler_angular_momentum/#Computational-infrastructure","page":"L_j and R_j with Euler angles","title":"Computational infrastructure","text":"","category":"section"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"We'll use SymPy (via Julia) since Symbolics.jl isn't very good at trig yet.","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"import Memoization: @memoize\nimport LaTeXStrings: @L_str, LaTeXString\nimport Quaternionic: Quaternionic, Quaternion, components\nimport SymPyPythonCall\nimport SymPyPythonCall: sympy, symbols, sqrt, sin, cos, tan, acos, atan, latex\nconst expand_trig = sympy.expand_trig\nconst Derivative = sympy.Derivative\nconst π = sympy.pi\nconst I = sympy.I\nnothing  #hide","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"Define symbols we will use throughout","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"α, β, γ, θ, ϕ, ϵ = symbols(\"α β γ θ ϕ ϵ\", real=true, positive=true)\nf = symbols(\"f\", cls=SymPyPythonCall.sympy.o.Function)\nnothing  #hide","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"Reinterpret the quaternion basis elements for compatibility with SymPy.  (Quaternionic defines the basis with Bool components, but SymPy can't handle that.)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"const 𝐢 = Quaternion{Int}(Quaternionic.𝐢)\nconst 𝐣 = Quaternion{Int}(Quaternionic.𝐣)\nconst 𝐤 = Quaternion{Int}(Quaternionic.𝐤)\nnothing  #hide","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"Next, we define functions to compute the Euler components of the left and right operators","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"@memoize function 𝒪(u, side)\n    # Substitutions that sympy doesn't make but we want\n    subs = Dict(\n        cos(β)/sin(β) => 1/tan(β),\n        sqrt(1 - cos(β))*sqrt(cos(β) + 1) => sin(β)\n    )\n\n    # Define the essential quaternions\n    e = cos(ϵ/2) + u * sin(-ϵ/2)\n    R₀ = Quaternion(sympy.simplify.(sympy.expand.(components(\n        (cos(α/2) + 𝐤 * sin(α/2)) * (cos(β/2) + 𝐣 * sin(β/2)) * (cos(γ/2) + 𝐤 * sin(γ/2))\n    ))))\n\n    # Extract the (simplified) components of the product\n    w, x, y, z = sympy.simplify.(sympy.expand.(components(\n        side == :left ? e * R₀ : R₀ * e\n    )))\n\n    # Convert back to Euler angles\n    α′ = (atan(z/w) + atan(-x/y)).expand().simplify()\n    β′ = (2*acos(sqrt(w^2 + z^2) / sqrt(w^2 + x^2 + y^2 + z^2))).expand().simplify()\n    γ′ = (atan(z/w) - atan(-x/y)).expand().simplify()\n\n    # Differentiate with respect to ϵ, set ϵ to 0, and simplify\n    ∂α′∂ϵ = expand_trig(Derivative(α′, ϵ).doit().subs(ϵ, 0).expand().simplify().subs(subs))\n    ∂β′∂ϵ = expand_trig(Derivative(β′, ϵ).doit().subs(ϵ, 0).expand().simplify().subs(subs))\n    ∂γ′∂ϵ = expand_trig(Derivative(γ′, ϵ).doit().subs(ϵ, 0).expand().simplify().subs(subs))\n\n    return ∂α′∂ϵ, ∂β′∂ϵ, ∂γ′∂ϵ\nend\n\n# Note that we are not including the factor of ``i`` here; for simplicity, we will insert\n# it manually when displaying the results below, and when applying these operators to\n# functions (`Lx` and related definitions below).\nL(u) = 𝒪(u, :left)\nR(u) = 𝒪(u, :right)\nnothing  #hide","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"We need a couple quick helper macros to display the results. The details are boring, but you can expand the source code to see them.","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"<details>\n<summary>\nClick here to expand the source code for display macros\n</summary>","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"macro display(expr)\n    op = string(expr.args[1])\n    arg = Dict(:𝐢 => \"x\", :𝐣 => \"y\", :𝐤 => \"z\")[expr.args[2]]\n    if op == \"L\"\n        quote\n            ∂α′∂ϵ, ∂β′∂ϵ, ∂γ′∂ϵ = latex.($expr)  # Call expr; format results as LaTeX\n            expr = $op * \"_\" * $arg  # Standard form of the operator\n            L\"\"\"%$expr = i\\left[\n                %$(∂α′∂ϵ) \\frac{\\partial}{\\partial \\alpha}\n                + %$(∂β′∂ϵ) \\frac{\\partial}{\\partial \\beta}\n                + %$(∂γ′∂ϵ) \\frac{\\partial}{\\partial \\gamma}\n            \\right]\"\"\"  # Display the result in LaTeX form\n        end\n    else\n        quote\n            ∂α′∂ϵ, ∂β′∂ϵ, ∂γ′∂ϵ = latex.($expr)  # Call expr; format results as LaTeX\n            expr = $op * \"_\" * $arg  # Standard form of the operator\n            L\"\"\"%$expr = -i\\left[\n                %$(∂α′∂ϵ) \\frac{\\partial}{\\partial \\alpha}\n                + %$(∂β′∂ϵ) \\frac{\\partial}{\\partial \\beta}\n                + %$(∂γ′∂ϵ) \\frac{\\partial}{\\partial \\gamma}\n            \\right]\"\"\"  # Display the result in LaTeX form\n        end\n    end\nend\nnothing  #hide","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"And we'll need another for the angular-momentum operators in standard S^2 form.","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"conversion(∂) = ∂.subs(Dict(α => ϕ, β => θ, γ => 0)).simplify()\nmacro display2(expr)\n    op = string(expr.args[1])\n    element = expr.args[2]\n    arg = Dict(:𝐢 => \"x\", :𝐣 => \"y\", :𝐤 => \"z\", :+ => \"+\", :- => \"-\")[element]\n    @info element\n    if op == \"L\" && arg ∈ (\"+\", \"-\")\n        quote\n            ∂φ′∂ϵ, ∂ϑ′∂ϵ, ∂γ′∂ϵ = (\n                (\n                    ($element)(I * $conversion(i), -$conversion(j)).rewrite(exp)\n                    / exp(($element)(I) * ϕ)\n                ).simplify()\n                for (i, j) ∈ zip(L(𝐢), L(𝐣))\n            )\n            expr = $op * \"_\" * $arg  # Standard form of the operator\n            expsign = ($arg==\"+\" ? \"\" : \"-\")\n            L\"\"\"%$expr = e^{%$expsign i \\phi} \\left[\n                %$(∂ϑ′∂ϵ) \\frac{\\partial}{\\partial \\theta}\n                + %$(∂φ′∂ϵ) \\frac{\\partial}{\\partial \\phi}\n            \\right]\"\"\"  # Display the result in LaTeX form\n        end\n    elseif op == \"L\"\n        quote\n            ∂φ′∂ϵ, ∂ϑ′∂ϵ, ∂γ′∂ϵ = latex.($conversion.($expr))  # Call expr; format as LaTeX\n            expr = $op * \"_\" * $arg  # Standard form of the operator\n            L\"\"\"%$expr = i\\left[\n                %$(∂ϑ′∂ϵ) \\frac{\\partial}{\\partial \\theta}\n                + %$(∂φ′∂ϵ) \\frac{\\partial}{\\partial \\phi}\n            \\right]\"\"\"  # Display the result in LaTeX form\n        end\n    else\n        quote\n            ∂φ′∂ϵ, ∂ϑ′∂ϵ, ∂γ′∂ϵ = latex.($conversion.($expr))  # Call expr; format as LaTeX\n            expr = $op * \"_\" * $arg  # Standard form of the operator\n            L\"\"\"%$expr = -i\\left[\n                %$(∂ϑ′∂ϵ) \\frac{\\partial}{\\partial \\theta}\n                + %$(∂φ′∂ϵ) \\frac{\\partial}{\\partial \\phi}\n                + %$(∂γ′∂ϵ) \\frac{\\partial}{\\partial \\gamma}\n            \\right]\"\"\"  # Display the result in LaTeX form\n        end\n    end\nend\nnothing  #hide","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"</details>","category":"page"},{"location":"literate_output/euler_angular_momentum/#Full-expressions-on-S3","page":"L_j and R_j with Euler angles","title":"Full expressions on S^3","text":"","category":"section"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"Finally, we can actually compute the Euler components of the angular momentum operators.","category":"page"},{"location":"literate_output/euler_angular_momentum/#L-operators-in-terms-of-Euler-angles","page":"L_j and R_j with Euler angles","title":"L operators in terms of Euler angles","text":"","category":"section"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"@display L(𝐢)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"@display L(𝐣)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"@display L(𝐤)","category":"page"},{"location":"literate_output/euler_angular_momentum/#R-operators-in-terms-of-Euler-angles","page":"L_j and R_j with Euler angles","title":"R operators in terms of Euler angles","text":"","category":"section"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"@display R(𝐢)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"@display R(𝐣)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"@display R(𝐤)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"In their description of the Wigner 𝔇 functions as wave functions of a rigid symmetric top, Varshalovich et al. [26] provide equivalent expressions in Eqs. (6) and (7) of their Sec. 4.2 — except that R_x and R_z have the wrong signs. Wikipedia, meanwhile, provides equivalent expressions, except that their hatmathcalP has (consistently) the opposite sign to R defined here.","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"Note that the Wikipedia convention is actually entirely sensible — maybe more sensible than the one we use.  In that convention hatJ is in the inertial frame, whereas hatP is exactly that operator in the body-fixed frame.  In our notation, we have","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"beginalign\nR_𝐮 f(𝐑)\n=\n-left i fracddepsilonright_epsilon=0 fleft(𝐑 e^-epsilon 𝐮2right) \n=\n-left i fracddepsilonright_epsilon=0\n  fleft(𝐑 e^-epsilon 𝐮2 𝐑^-1 𝐑right) \n=\n-left i fracddepsilonright_epsilon=0\n  fleft(e^-epsilon 𝐑 𝐮 𝐑^-12 𝐑right) \n=\n-L_𝐑 𝐮 𝐑^-1 f(𝐑)\nendalign","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"which says that R is just the negative of the L operator transformed to the body-fixed frame.  That negative sign is slightly unnatural, but the reason we choose to define R in this way is for its more natural connection to the literature on spin-weighted spherical functions.  Also, R defined here obeys the same commutation relations as the standard angular-momentum operators, whereas the Wikipedia convention leads to \"anomalous\" commutation relations with an extra minus sign.","category":"page"},{"location":"literate_output/euler_angular_momentum/#Commutators","page":"L_j and R_j with Euler angles","title":"Commutators","text":"","category":"section"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"We can also compute the commutators of the angular momentum operators, as derived above. First, we define the operators acting on functions of the Euler angles.  Note that this function differs from the one above because it explicitly takes the function f and the Euler angles as arguments — which will be necessary to compute the commutators.","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"function 𝒪(u, side, f, α, β, γ)\n    let O = 𝒪(u, side)\n        (side==:left ? I : -I) * (\n            O[1] * f(α, β, γ).diff(α)\n            + O[2] * f(α, β, γ).diff(β)\n            + O[3] * f(α, β, γ).diff(γ)\n        )\n    end\nend\n\nLx(f, α, β, γ) = 𝒪(𝐢, :left, f, α, β, γ)\nLy(f, α, β, γ) = 𝒪(𝐣, :left, f, α, β, γ)\nLz(f, α, β, γ) = 𝒪(𝐤, :left, f, α, β, γ)\n\nRx(f, α, β, γ) = 𝒪(𝐢, :right, f, α, β, γ)\nRy(f, α, β, γ) = 𝒪(𝐣, :right, f, α, β, γ)\nRz(f, α, β, γ) = 𝒪(𝐤, :right, f, α, β, γ)\n\nnothing  #hide","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"Now we define their commutator O₁ O₂ = O₁O₂ - O₂O₁:","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"function commutator(O₁, O₂)\n    (\n        O₁((α, β, γ)->O₂(f, α, β, γ), α, β, γ)\n        - O₂((α, β, γ)->O₁(f, α, β, γ), α, β, γ)\n    ).expand().simplify()\nend\n\nnothing  #hide","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"And finally, evaluate each in turn.  We expect L_x L_y = i L_z and cyclic permutations:","category":"page"},{"location":"literate_output/euler_angular_momentum/#L-commutators-in-Euler-angles","page":"L_j and R_j with Euler angles","title":"L commutators in Euler angles","text":"","category":"section"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"commutator(Lx, Ly)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"which equals i L_z,","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"commutator(Ly, Lz)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"which equals i L_x, and","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"commutator(Lz, Lx)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"which equals i L_y.  Similarly, we expect R_x R_y = i R_z and cyclic permutations:","category":"page"},{"location":"literate_output/euler_angular_momentum/#R-commutators-in-Euler-angles","page":"L_j and R_j with Euler angles","title":"R commutators in Euler angles","text":"","category":"section"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"commutator(Rx, Ry)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"which equals i R_z,","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"commutator(Ry, Rz)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"which equals i R_x, and","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"commutator(Rz, Rx)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"which equals i R_y — all as expected.","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"Just for completeness, let's evaluate the commutators of the left and right operators, which should all be zero.","category":"page"},{"location":"literate_output/euler_angular_momentum/#L,R-commutators-in-Euler-angles","page":"L_j and R_j with Euler angles","title":"LR commutators in Euler angles","text":"","category":"section"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"[commutator(L, R) for L ∈ (Lx, Ly, Lz), R ∈ (Rx, Ry, Rz)]","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"This completes independent commutator results, which are all as we expect them to be.","category":"page"},{"location":"literate_output/euler_angular_momentum/#Standard-expressions-on-S2","page":"L_j and R_j with Euler angles","title":"Standard expressions on S^2","text":"","category":"section"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"We can substitute (α β γ) to (φ θ 0) to get the standard expressions for the angular momentum operators on the 2-sphere.","category":"page"},{"location":"literate_output/euler_angular_momentum/#L-operators-in-spherical-coordinates","page":"L_j and R_j with Euler angles","title":"L operators in spherical coordinates","text":"","category":"section"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"@display2 L(𝐢)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"@display2 L(𝐣)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"@display2 L(𝐤)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"We can also provide the usual expressions for the raising and lowering operators in terms of spherical coordinates with L_pm = L_x pm i L_y:","category":"page"},{"location":"literate_output/euler_angular_momentum/#L_{\\pm}-operators-in-spherical-coordinates","page":"L_j and R_j with Euler angles","title":"L_pm operators in spherical coordinates","text":"","category":"section"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"@display2 L(+)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"@display2 L(-)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"These are all indeed the standard expressions for the angular-momentum operators on the 2-sphere, as seen in numerous references, so we can declare compatibility between our unusual definition of L and more standard definitions.","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"Now, note that including partial_gamma for an expression on the 2-sphere doesn't actually make any sense: gamma isn't even a coordinate for the 2-sphere!  However, for historical reasons, we include it here when showing the results of the R operator in Euler angles.","category":"page"},{"location":"literate_output/euler_angular_momentum/#R-operators-in-spherical-coordinates","page":"L_j and R_j with Euler angles","title":"R operators in spherical coordinates","text":"","category":"section"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"@display2 R(𝐢)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"@display2 R(𝐣)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"@display2 R(𝐤)","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"We get nonzero components of partial_gamma, showing that these operators really do not make sense for the 2-sphere, and therefore that it doesn't actually make sense to define spin-weighted spherical functions on the 2-sphere; they really only make sense on the 3-sphere.  Nonetheless, if we stipulate that the function eta has a specific spin weight, that means that on the 3-sphere it is an eigenfunction with R_zeta = ipartial_gamma eta = seta.  So we could just substitute -i s for partial_gamma in the expressions above, and recover the standard spin-weight operators.  We get","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"leftR_x + i R_yright eta\n= left\n    -i frac1sintheta fracpartialpartial phi\n    + fracstan theta\n    - fracpartialpartial theta\n  right eta\n= -(sin theta)^s left\n    fracpartialpartial theta\n    +i frac1sintheta fracpartialpartial phi\n  right\n  left (sin theta)^-s eta right","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"And in the latter form, we can see that R_x + i R_y is exactly the spin-raising operator eth as originally defined by Newman and Penrose [7] in their Eq. (3.8).  The complex-conjugate of this operator is the spin-lowering operator bareth for R_z.  By definition of raising and lowering operators, this means that R_z eth = eth and R_z bareth = -bareth.  We can verify these results by computing the commutators directly from the expressions above:","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"beginaligned\nR_z eth\n  = R_z R_x + i R_z R_y = i R_y - i i R_x = R_x + i R_y = eth\n\nR_z bareth\n  = R_z R_x - i R_z R_y = i R_y + i i R_x = -R_x + i R_y = -bareth\nendaligned","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"So we see that we've reproduced precisely the standard expressions for the spin-weighted spherical functions (depicted as functions on the 2-sphere) from the expressions for the angular-momentum operators acting on general functions on the 3-sphere.  The standard expressions appear arbitrarily, and are not even well defined as functions on the 2-sphere because they also need input from tangent space of the sphere — which is not part of the 2-sphere proper.  On the other hand, the expressions from the 3-sphere are mathematically and physically well defined and intuitive.  Note that the latter is complete in itself; it can stand alone without reference to the 2-sphere.  Rather, what we have done here is just shown the connection to the inadequate standard presentation.  But it is important to recognize that our complete treatment on mathrmSpin(3) is the more fundamental one, and can be used without reference to the older treatment.","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"","category":"page"},{"location":"literate_output/euler_angular_momentum/","page":"L_j and R_j with Euler angles","title":"L_j and R_j with Euler angles","text":"This page was generated using Literate.jl.","category":"page"},{"location":"internal/#Internal-functions","page":"Internal functions","title":"Internal functions","text":"","category":"section"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"There are various functions that are only used internally, some of which are likely to be deprecated in the near future.  These are documented here for completeness.","category":"page"},{"location":"internal/#H-recursion-and-ALFs","page":"Internal functions","title":"H recursion and ALFs","text":"","category":"section"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"The fundamental algorithm is the H recursion, which is the core computation needed for Wigner's d and 𝔇 matrices, and the spin-weighted spherical harmonics _sY_ellm, as well as map2salm functions.","category":"page"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"Modules = [SphericalFunctions]\nPages   = [\"Hrecursion.jl\"]","category":"page"},{"location":"internal/#SphericalFunctions.H!-Union{Tuple{T}, Tuple{AbstractVector, Complex{T}, Any, Any, Any}, Tuple{AbstractVector, Complex{T}, Vararg{Any, 4}}} where T<:Real","page":"Internal functions","title":"SphericalFunctions.H!","text":"H!(H, expiβ, ℓₘₐₓ, m′ₘₐₓ, H_rec_coeffs)\nH!(H, expiβ, ℓₘₐₓ, m′ₘₐₓ, H_rec_coeffs, Hindex)\n\nCompute the H matrix defined by Gumerov and Duraiswami [8].\n\nThis computation forms the basis for computing Wigner's d and 𝔇 matrices via d_matrices! and D_matrices!, the spin-weighted spherical harmonics via sYlm_values!, and for transforming from values of spin-weighted spherical functions evaluated on a grid to the corresponding mode weights via map2salm.\n\nDue to symmetries, we only need to compute ~1/4 of the elements of this matrix, so only those elements with m  m are computed.  The relevant indices of the H vector are computed based on the Hindex function — which defaults to WignerHindex, but could reasonably be WignerDindex if the input H vector contains all valid indices.  However, it is assumed that the storage scheme used for H is such that the successive m values are located in successive elements.\n\nIf mₘₐₓ  ℓₘₐₓ, we don't even need 1/4 of the elements, and only values with m  mₘₐₓ will be computed.  This is particularly useful for computing spin-weighted spherical harmonics.\n\nNote that the recursion coefficients H_rec_coeffs should be the quantity returned by H_recursion_coefficients.\n\n\n\n\n\n","category":"method"},{"location":"internal/#SphericalFunctions.H_recursion_coefficients-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:Real","page":"Internal functions","title":"SphericalFunctions.H_recursion_coefficients","text":"H_recursion_coefficients(ℓₘₐₓ, T)\n\nPre-compute constants used in Wigner H recursion.\n\n\n\n\n\n","category":"method"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"Internally, the H recursion relies on calculation of the Associated Legendre Functions (ALFs), which can also be called on their own:","category":"page"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"Modules = [SphericalFunctions]\nPages   = [\"associated_legendre.jl\"]","category":"page"},{"location":"internal/#SphericalFunctions.ALFcompute!-Union{Tuple{T}, Tuple{Vector{T}, Complex{T}, Int64, ALFRecursionCoefficients{T}}} where T<:Real","page":"Internal functions","title":"SphericalFunctions.ALFcompute!","text":"ALFcompute(expiβ, nmax)\nALFcompute!(P̄, expiβ, nmax)\nALFcompute(expiβ, nmax, recursion_coefficients)\nALFcompute!(P̄, expiβ, nmax, recursion_coefficients)\n\nCompute the \"fully normalized\" Associated Legendre Functions up to some maximum n value nmax.\n\nThese functions can take a vector P̄, to store the data, stored in order of increasing m most rapidly varying and then increasing n.  If not supplied, P̄ will be constructed for you and returned.\n\nThe optional recursion_coefficients argument must be an ALFRecursionCoefficients, which stores various constant coefficients used in the recursion.  This object requires more than 3x the memory and more than 20x the time to compute a single P̄ vector without this argument, but passing it will typically speed up the calculation of each P̄ by a factor of 8x or so.  Thus, if you expect to compute P̄ more than a few times, it will take less time to pre-compute those factors, and pass them to this function.\n\nNote that the base real type will be inferred from the (complex) type of expiβ.  If present, the base types of P̄ and recursion_coefficients must agree.\n\n\n\n\n\n","category":"method"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"The function _slambda_ellm is defined as essentially _sY_ell0, and is important internally for computing the ALFs.  We have some important utilities for computing it:","category":"page"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"SphericalFunctions.λ_recursion_initialize\nSphericalFunctions.λ_iterator\nSphericalFunctions.AlternatingCountdown","category":"page"},{"location":"internal/#SphericalFunctions.λ_recursion_initialize","page":"Internal functions","title":"SphericalFunctions.λ_recursion_initialize","text":"λ_recursion_initialize(cosθ, sin½θ, cos½θ, s, ℓ, m)\n\nThis provides initial values for the recursion to find _slambda_ellm along indices of increasing ell, due to Kostelec & Rockmore Specifically, this function computes values with ell=m.\n\n_slambda_ellm(theta)\n    = _sY_ellm(theta 0)\n    = (-1)^m sqrtfrac2ell+14pi d^ell_-ms(theta)\n\n\n\n\n\n","category":"function"},{"location":"internal/#SphericalFunctions.λ_iterator","page":"Internal functions","title":"SphericalFunctions.λ_iterator","text":"λ_iterator(θ, s, m)\n\nConstruct an object to iterate over ₛλₗₘ values.\n\nThe ₛλₗₘ(θ) function is defined as the spin-weighted spherical harmonic evaluated at spherical coordinates (θ ϕ), with ϕ=0.  In particular, note that it is real-valued. The return type is determined by the type of θ (or more precisely, cos½θ).\n\nThis algorithm by Kostelec & Rockmore allows us to iterate over increasing ℓ values, for given fixed s and m values.\n\nNote that this iteration has no inherent bound, so if you try to iterate over all values, you will end up in an infinite loop.  Instead, you can zip this iterator with another:\n\nθ = 0.1\ns = -2\nm = 1\nλ = λ_iterator(θ, s, m)\nΔ = max(abs(s), abs(m))\nfor (ℓ, ₛλₗₘ) ∈ zip(Δ:Δ+5, λ)\n    @show (ℓ, ₛλₗₘ)\nend\n\nAlternatively, you could use Iterates.take(λ, 6), for example.\n\nNote that the iteration always begins with ℓ = Δ = max(abs(s), abs(m)).\n\n\n\n\n\n","category":"type"},{"location":"internal/#SphericalFunctions.AlternatingCountdown","page":"Internal functions","title":"SphericalFunctions.AlternatingCountdown","text":"Simple iterator to count down to 0, with alternating signs\n\njulia> collect(AlternatingCountdown(5))\n11-element Vector{Int64}:\n  5\n -5\n  4\n -4\n  3\n -3\n  2\n -2\n  1\n -1\n  0\n\n\n\n\n\n","category":"type"},{"location":"internal/#Y,-d,-and-D","page":"Internal functions","title":"Y, d, and D","text":"","category":"section"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"Various d, D, and sYlm functions are important in the main API.  Their names and signatures have been tweaked from older versions of this package.  The only one with remaining documentation is ₛ𝐘, which could probably be replaced by sYlm_values, except that the default pixelization is golden_ratio_spiral_rotors, which makes it very convenient for interacting with SSHT.","category":"page"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"ₛ𝐘\nSphericalFunctions.Y\nSphericalFunctions.d\nSphericalFunctions.D","category":"page"},{"location":"internal/#SphericalFunctions.ₛ𝐘","page":"Internal functions","title":"SphericalFunctions.ₛ𝐘","text":"ₛ𝐘(s, ℓₘₐₓ, [T=Float64], [Rθϕ=golden_ratio_spiral_rotors(s, ℓₘₐₓ, T)])\n\nConstruct a matrix of ₛYₗₘ(Rθϕ) values for the input s and all nontrivial (ell m) up to ℓₘₐₓ.\n\nThis is a fast and accurate method for mapping between the vector of spin-weighted spherical-harmonic mode weights ₛ𝐟ₗₘ and the vector of function values on the sphere ₛ𝐟ⱼₖ, as\n\nₛ𝐟ⱼₖ = ₛ𝐘 ₛ𝐟ₗₘ\n\nwhere the right-hand side represents the matrix-vector product.  As usual, we assume that the ₛ𝐟ₗₘ modes are ordered by increasing m  -ℓℓ, and ℓ  sℓₘₐₓ.  The ordering of the ₛ𝐟ⱼₖ values will be determined by the ordering of the argument Rθϕ.\n\nNote that the number of modes need not be the same as the number of points on which the function is evaluated, which would imply that the output matrix is not square.  To be able to invert the relationship, however, we need the number of points ₛ𝐟ⱼₖ to be at least as large as the number of modes ₛ𝐟ₗₘ.\n\nNote that the usefulness of this approach is limited by the fact that the size of this matrix scales as ℓₘₐₓ⁴.  As such, it is mostly useful only for ℓₘₐₓ of order dozens, rather than — say — the tens of thousands that CMB astronomy or lensing require, for example.\n\nDirect application and inversion of this matrix are used in the \"direct\" methods of s-SHT transformations.  See SSHTDirect for details about the implementation.\n\n\n\n\n\n","category":"function"},{"location":"internal/#SphericalFunctions.Y","page":"Internal functions","title":"SphericalFunctions.Y","text":"Y(ℓ, m, θ, ϕ)\nY(s, ℓ, m, θ, ϕ)\n\nNOTE: This function is primarily a test function just to make comparisons between this package's spherical harmonics and other references' more clear.  It is inefficient, both in terms of memory and computation time, and should generally not be used in production code.\n\nComputes a single (complex) value of the spherical harmonic (ell m) at the given spherical coordinate (theta phi).\n\n\n\n\n\n","category":"function"},{"location":"internal/#SphericalFunctions.d","page":"Internal functions","title":"SphericalFunctions.d","text":"d(ℓ, m′, m, β)\nd(ℓ, m′, m, expiβ)\n\nNOTE: This function is primarily a test function just to make comparisons between this package's Wigner d function and other references' more clear.  It is inefficient, both in terms of memory and computation time, and should generally not be used in production code.\n\nComputes a single (complex) value of the d matrix (ell m m) at the given angle (iota).\n\n\n\n\n\n","category":"function"},{"location":"internal/#SphericalFunctions.D","page":"Internal functions","title":"SphericalFunctions.D","text":"D(ℓ, m′, m, β)\nD(ℓ, m′, m, expiβ)\n\nNOTE: This function is primarily a test function just to make comparisons between this package's Wigner D function and other references' more clear.  It is inefficient, both in terms of memory and computation time, and should generally not be used in production code.\n\nComputes a single (complex) value of the D matrix (ell m m) at the given angle (iota).\n\n\n\n\n\n","category":"function"},{"location":"internal/#Transformation","page":"Internal functions","title":"Transformation","text":"","category":"section"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"The newer SSHT interface is more efficient for most purposes, but this package used to use functions named map2salm, which is still present, but may be deprecated.","category":"page"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"Modules = [SphericalFunctions]\nPages   = [\"map2salm.jl\"]","category":"page"},{"location":"internal/#SphericalFunctions.map2salm!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, Int64, Int64, Any}} where T<:Real","page":"Internal functions","title":"SphericalFunctions.map2salm!","text":"map2salm!(salm, map, spin, ℓmax)\nmap2salm!(salm, map, plan)\n\nTransform map values sampled on the sphere to _sa_ell m modes in place.\n\nFor details, see map2salm.\n\n\n\n\n\n","category":"method"},{"location":"internal/#SphericalFunctions.map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, Int64, Int64, Any}} where T<:Real","page":"Internal functions","title":"SphericalFunctions.map2salm","text":"map2salm(map, spin, ℓmax)\nmap2salm(map, plan)\n\nTransform map values sampled on the sphere to _sa_ell m modes.\n\nThe map array should have size Nφ along its first dimension and Nϑ along its second; any number of dimensions may follow.  The spin must be entered explicitly, and ℓmax is the highest ℓ value you want in the output.\n\nFor repeated applications of this function with different values of map, it is more efficient to pre-compute plan using plan_map2salm.  These functions will create a new salm array on each call.  To operate in place on a pre-allocated salm array, use map2salm!.\n\nThe core of this function follows the method described by Reinecke and Seljebotn.\n\n\n\n\n\n","category":"method"},{"location":"internal/#SphericalFunctions.plan_map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, Int64, Int64}} where T<:Real","page":"Internal functions","title":"SphericalFunctions.plan_map2salm","text":"plan_map2salm(map, spin, ℓmax)\n\nPrecompute values to use in executing map2salm or map2salm!.\n\nThe arguments to this function exactly mirror those of the first form of map2salm, and all but the first argument in the first form of map2salm!.  The plan returned by this function can be passed to the second forms of those functions to avoid some computation and allocation costs.\n\nNote that the plan object is not thread safe; a separate plan should be created for each thread that will use one, or locks should be used to ensure that a single plan is not used at the same time on different threads.\n\n\n\n\n\n","category":"method"},{"location":"sYlm/#{}_{s}Y_{\\ell,m}-functions","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"","category":"section"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"The spin-weighted spherical harmonics are an important set of functions defined on the rotation group 𝐒𝐎(3), or more generally, the spin group 𝐒𝐩𝐢𝐧(3) that covers it.  They are eigenfunctions of the left- and right-Lie derivatives, and are particularly useful in describing the angular dependence of polarized fields, like the electromagnetic field and gravitational-wave field.  Originally introduced by Newman and Penrose [7], they are essentially components of Wigner's frakD matrices:","category":"page"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"_sY_ellm(mathbfR)\n  = (-1)^s sqrtfrac2ell+14pi  frakD^(ell)_m -s(mathbfR)","category":"page"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"As such, they can be computed using the same H recursion algorithm as the Wigner frakD^(ell)_m -s matrices.  But because not all values of s in -ellell are used, we can be much more efficient in both storage and computation time.","category":"page"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"The user interface is very similar to the one for Wigner's 𝔇 and d matrices:","category":"page"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"using Quaternionic\nusing SphericalFunctions\n\nR = randn(RotorF64)\nℓₘₐₓ = 8\ns = -2\nY = sYlm_values(R, ℓₘₐₓ, s)","category":"page"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"Again, the results can take up a lot of memory, so for maximum efficiency when calling this function repeatedly with different R values, it is best to pre-allocate the necessary memory with the sYlm_prep function, and the pass that in as an argument to sYlm_values!:","category":"page"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"Y_storage = sYlm_prep(ℓₘₐₓ, s)\nY = sYlm_values!(Y_storage, R, s)","category":"page"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"(Beware that, as noted in the documentation for sYlm_values!, the output Y is just a reference to part of the Y_storage object, so you should not reuse Y_storage until you have copied or otherwise finished using Y.)","category":"page"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"The output Y is a single vector of Complex numbers with the same base type as R.  The ordering of the elements is described in the documentation for sYlm_values!.  It is also possible to efficiently view slices of this vector as a series of individual vectors using a sYlm_iterator:","category":"page"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"for (ℓ, Yˡ) in zip(0:ℓₘₐₓ, sYlm_iterator(Y, ℓₘₐₓ))\n    # Do something with the matrix Yˡ[ℓ+m′+1, ℓ+m+1]\nend","category":"page"},{"location":"sYlm/#Docstrings","page":"_sY_ellm functions","title":"Docstrings","text":"","category":"section"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"sYlm_values\nsYlm_values!\nsYlm_prep\nsYlm_iterator","category":"page"},{"location":"sYlm/#SphericalFunctions.sYlm_values","page":"_sY_ellm functions","title":"SphericalFunctions.sYlm_values","text":"sYlm_values(R, ℓₘₐₓ, spin)\nsYlm_values(θ, ϕ, ℓₘₐₓ, spin)\n\nCompute values of the spin-weighted spherical harmonic _sY_ell m(R) for all ell leq ell_mathrmmax.\n\nSee sYlm_values! for details about the input and output values.\n\nThis function only appropriate when you need to evaluate the _sY_ell m for a single value of R or θ, ϕ because it allocates large arrays and performs many calculations that could be reused.  If you need to evaluate the matrices for many values of R or θ, ϕ, you should pre-allocate the storage with sYlm_prep, and then call sYlm_values! with the result instead.\n\n\n\n\n\n","category":"function"},{"location":"sYlm/#SphericalFunctions.sYlm_values!","page":"_sY_ellm functions","title":"SphericalFunctions.sYlm_values!","text":"sYlm_values!(sYlm_storage, R, spin)\nsYlm_values!(sYlm_storage, θ, ϕ, spin)\nsYlm_values!(sYlm, R, ℓₘₐₓ, spin)\nsYlm_values!(sYlm, θ, ϕ, ℓₘₐₓ, spin)\n\nCompute values of the spin-weighted spherical harmonic _sY_ell m(R) for all ell leq ell_mathrmmax.\n\nThe spherical harmonics of spin weight s are related to Wigner's mathfrakD matrix as\n\nbeginaligned\n_sY_ell m(R)\n  = (-1)^s sqrtfrac2ell+14pi mathfrakD^(ell)_m -s(R) \n  = (-1)^s sqrtfrac2ell+14pi barmathfrakD^(ell)_-s m(barR)\nendaligned\n\nIn all cases, the result is returned in a 1-dimensional array ordered as\n\n[\n    ₛYₗₘ(R)\n    for ℓ ∈ 0:ℓₘₐₓ\n    for m ∈ -ℓ:ℓ\n]\n\nWhen the first argument is Y, it will be modified, so it must be at least as large as that array. When the first argument is sYlm_storage, it should be the quantity returned by sYlm_prep, and the result will be written into the Y field of that tuple.  Both of these options — especially the latter — reduce the number of allocations needed on each call to the corresponding functions, which should increase the speed significantly.  Note that the Y or sYlm_storage arguments must have types compatible with the type of R or θ, ϕ.\n\nwarn: Warn\nWhen using the sYlm_storage argument (which is recommended), the returned quantity sYlm will be an alias of sYlm_storage[1].  If you want to retain that data after the next call to sYlm_values!, you should copy it with copy(sYlm).\n\nThe θ, ϕ arguments are spherical coordinates as described in the documentation of Quaternionic.from_spherical_coordinates.\n\nSee also sYlm_values for a simpler function call when you only need to evaluate the _sY_ell m for a single value of R or θ, ϕ.\n\nExamples\n\nusing Quaternionic, SphericalFunctions\nspin = -2\nℓₘₐₓ = 8\nT = Float64\nR = Rotor{T}(1, 2, 3, 4)  # Will be normalized automatically\nsYlm_storage = sYlm_prep(ℓₘₐₓ, spin, T)\nsYlm = sYlm_values!(sYlm_storage, R, spin)\n\n\n\n\n\n","category":"function"},{"location":"sYlm/#SphericalFunctions.sYlm_prep","page":"_sY_ellm functions","title":"SphericalFunctions.sYlm_prep","text":"sYlm_prep(ℓₘₐₓ, sₘₐₓ, [T=Float64, [ℓₘᵢₙ=0]])\n\nConstruct storage space and pre-compute recursion coefficients to compute spin-weighted spherical-harmonic values _sY_ell m in place.\n\nThis returns the sYlm_storage arguments needed by sYlm_values!.\n\nNote that the result of this function can be passed to sYlm_values!, even if the value of spin passed to that function is smaller (in absolute value) than the sₘₐₓ passed to this function.  That is, the sYlm_storage returned by this function can be used to compute _sY_ell m values for numerous values of the spin.\n\n\n\n\n\n","category":"function"},{"location":"sYlm/#SphericalFunctions.sYlm_iterator","page":"_sY_ellm functions","title":"SphericalFunctions.sYlm_iterator","text":"sYlm_iterator(Y, ℓₘₐₓ, [ℓₘᵢₙ, [iₘᵢₙ]])\n\nConstruct an Iterator that returns sub-vectors of Y, each of which consists of elements (ℓ-ℓ) through (ℓℓ), for ℓ from ℓₘᵢₙ through ℓₘₐₓ.\n\nNote that the returned objects are views into the original Y data — meaning that you may alter their values.\n\nBecause the result is a vector restricted to a particular ℓ value, you can index the (ℓ m) element as [ℓ+m+1].  For example, you might use this as something like\n\nfor (ℓ, Yˡ) in zip(ℓₘᵢₙ:ℓₘₐₓ, sYlm_iterator(Y, ℓₘₐₓ))\n    for m in -ℓ:ℓ\n        Yˡ[ℓ+m+1]  # ... do something with Yˡ\n    end\nend\n\nBy default, Y is assumed to contain all possible values, beginning with (0,0).  However, if ℓₘᵢₙ is not 0, this can be ambiguous: do we mean that Y really starts with the (0,0) element and we are just asking to begin the iteration higher?  Or do we mean that Y doesn't even contain data for lower ℓ values?  We can resolve this using iₘᵢₙ, which gives the index of ℓₘᵢₙ in Y.  By default, we assume the first case, and set iₘᵢₙ=Ysize(ℓₘᵢₙ-1)+1. However, if Y doesn't contain data below ℓₘᵢₙ, we could use iₘᵢₙ=1 to indicate the index in Y at which to find (ℓₘᵢₙ-ℓₘᵢₙ).\n\nAlso note that no bounds checking is done, either at instantiation time or during iteration.  You are responsible for ensuring that the size of Y and the values of ℓₘₐₓ, ℓₘᵢₙ, and iₘᵢₙ make sense.\n\n\n\n\n\n","category":"type"},{"location":"operators/#Differential-operators","page":"Differential operators","title":"Differential operators","text":"","category":"section"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Spin-weighted spherical functions cannot be defined on the sphere S^2, but are well defined on the group mathrmSpin(3) cong mathrmSU(2) or the rotation group mathrmSO(3).  (See Boyle [1] for the explanation.)  However, this also allows us to define a variety of differential operators acting on these functions, relating to infinitesimal motions in these groups, acting either from the left or the right on their arguments.  Right or left matters because the groups mentioned above are all non-commutative groups.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"In general, the left Lie derivative of a function f(Q) over the unit quaternions with respect to a generator of rotation g is defined as","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_g(f)Q = -fraci2\n    left fracdfleft(exp(tg) Qright)dt right_t=0","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Note that the exponential multiplies Q on the left — hence the name.  We will see below that this agrees with the usual definition of the angular-momentum from physics, except that in quantum physics a factor of hbar is usually included.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"So, for example, a rotation about the z axis has the quaternion z as its generator of rotation, and L_z defined in this way agrees with the usual angular-momentum operator L_z familiar from spherical-harmonic theory, and reduces to it when the function has spin weight 0, but also applies to functions of general spin weight.  Similarly, we can compute L_x and L_y, and take appropriate combinations to find the usual raising and lowering (ladder) operators L_+ and L_-.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"In just the same way, we can define the right Lie derivative of a function f(Q) over the unit quaternions with respect to a generator of rotation g as","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"R_g(f)Q = -fraci2\n    left fracdfleft(Q exp(tg)right)dt right_t=0","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Note that the exponential multiplies Q on the right — hence the name.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"This operator is less common in physics, because it represents the dependence of the function on the choice of frame (or coordinate system), which is not usually of interest. Multiplication on the left represents a rotation of the physical system, while rotation on the right represents a rotation of the coordinate system.  However, this dependence on coordinate system is precisely what defines the spin weight of a function, so this class of operators is relevant in discussions of spin-weighted spherical functions.  In particular, the operators R_pm correspond (up to a sign) to the spin-raising and -lowering operators eth and bareth originally introduced by Newman and Penrose [7], as explained in greater detail by Boyle [1].","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Note that these definitions are extremely general, in that they can be used for any Lie group, and for any complex-valued function on that group.  And in full generality, we have the useful properties of linearity:","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_smathbfa = sL_mathbfa\nqquad textand qquad\nR_smathbfa = sR_mathbfa","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"and","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_mathbfa+mathbfb = L_mathbfa + L_mathbfb\nqquad textand qquad\nR_mathbfa+mathbfb = R_mathbfa + R_mathbfb","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"for any scalar s and any elements of the Lie algebra mathbfa and mathbfb.  In particular, if the Lie algebra has a basis mathbfe_(j), we use the shorthand L_j and R_j for L_mathbfe_(j) and R_mathbfe_(j), respectively, and we can expand any operator in terms of these basis operators:","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_mathbfa = sum_j a_j L_j\nqquad textand qquad\nR_mathbfa = sum_j a_j R_j","category":"page"},{"location":"operators/#Commutators","page":"Differential operators","title":"Commutators","text":"","category":"section"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"In general, for generators a and b, we have the commutator relations","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"left L_a L_b right = fraci2 L_ab\nqquad\nleft R_a R_b right = -fraci2 R_ab","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"where ab is the commutator of the two generators, which can be obtained directly as the commutator of the corresponding quaternions.  Note the sign difference between these two equations.  The factors of pm i2 are inherited directly from the definitions of L_g and R_g given above, but they appear there with the same sign.  The sign difference between these two commutator equations results from the fact that the quaternions are multiplied in opposite orders in the two cases.  It could be absorbed by defining the operators with opposite signs.[1]  The arbitrary sign choices used above are purely for historical reasons.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Again, these results are valid for general (finite-dimensional) Lie groups, but a particularly interesting case is in application to the three-dimensional rotation group.  In the following, we will apply our results to this group.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"The commutator relations for L are consistent — except for the differing use of hbar — with the usual relations from quantum mechanics:","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"left L_j L_k right = i hbar sum_l=1^3 varepsilon_jkl L_l","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Here, j, k, and l are indices that run from 1 to 3, and index the set of basis vectors (hatx haty hatz).  If we represent an arbitrary basis vector as hate_j, then the quaternion commutator ab in the expression for L_a L_b becomes","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"hate_j hate_k = 2 sum_l=1^3 varepsilon_jkl hate_l","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Plugging this into the general expression L_a L_b = fraci2 L_ab, we obtain (up to the factor of hbar) the version frequently seen in quantum physics.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"[1]: In fact, we can define the left and right Lie derivative operators quite generally, for functions on any Lie group and for the corresponding Lie algebra.  And in all cases (at least for finite-dimensional Lie algebras) we obtain the same commutator relations. The only potential difference is that it may not make sense to use the coefficient i2 in general; it was chosen here for consistency with the standard angular-momentum operators. If that coefficient is changed in the definitions of the Lie derivatives, the only change to the commutator relations would the substitution of that coefficient.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"The raising and lowering operators relative to L_z and R_z satisfy — by definition of raising and lowering operators — the relations","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_z L_pm = pm L_pm\nqquad\nR_z R_pm = pm R_pm","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"These allow us to solve — up to an overall factor — for those operators in terms of the basic generators (again, noting the sign difference):","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_pm = L_x pm i L_y\nqquad\nR_pm = R_x mp i R_y","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"(Interestingly, this procedure also shows that rasing and lowering operators can only exist if the factor in front of the derivatives in the definitions of L_g and R_g are pure imaginary numbers.)  In particular, this results in the commutator relations","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_+ L_- = 2L_z\nqquad\nR_+ R_- = 2R_z","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Here, the signs are similar because the two sign differences noted above essentially cancel each other out.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"In the functions listed below, these operators are returned as matrices acting on vectors of mode weights.  As such, we can actually evaluate these commutators as given to cross-validate the expressions and those functions.","category":"page"},{"location":"operators/#Transformations-of-functions-vs.-mode-weights","page":"Differential operators","title":"Transformations of functions vs. mode weights","text":"","category":"section"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"One important point to note is that mode weights transform \"contravariantly\" (very loosely speaking) relative to the spin-weighted spherical functions under some operators.  For example, take the action of the L_+ operator, which acts on a SWSH as","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_+ left_sY_ellmright (R) = sqrt(ell-m)(ell+m+1) _sY_ellm+1(R)","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"We can use this to derive the mode weights of a general spin-weighted function f under the action of this operator:[2]","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"beginaligned\nleftL_+ fright_ellm\n=\nint leftL_+ f(R)right _sbarY_ellm(R) dR \n=\nint leftL_+ sum_ellmf_ellm _sY_ellm(R)right _sbarY_ellm(R) dR \n=\nint sum_ellm f_ellm leftL_+ _sY_ellm(R)right _sbarY_ellm(R) dR \n=\nsum_ellm f_ellm int leftL_+ _sY_ellm(R)right _sbarY_ellm(R) dR \n=\nsum_ellm f_ellm int leftsqrt(ell-m)(ell+m+1) _sY_ellm+1(R)right _sbarY_ellm(R) dR \n=\nsum_ellm f_ellm sqrt(ell-m)(ell+m+1) int _sY_ellm+1(R) _sbarY_ellm(R) dR \n=\nsum_ellm f_ellm sqrt(ell-m)(ell+m+1) delta_ellell delta_mm+1 \n=\nf_ellm-1 sqrt(ell-m+1)(ell+m)\nendaligned","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Note that this expression (and in particular its signs) more resembles the expression for L_- left_sY_ellmright than for L_+ left_sY_ellmright.  Similar relations hold for the action of L_-.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"[2]: A technical note about the integrals above: the integrals should be taken over the appropriate space and with the appropriate weight such that the SWSHs are orthonormal.  In general, this integral should be over mathrmSpin(3) and weighted by 12pi so that the result will be either 0 or 1; in general the SWSHs are not truly orthonormal when integrated over an S^2 subspace (nor even is the integral invariant). However, if we know that the spins are the same in both cases, it is possible to integrate over an S^2 subspace.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"However, it is important to note that the same \"contravariance\" is not present for the spin-raising and -lowering operators:","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"beginaligned\nlefteth fright_ellm\n=\nint lefteth f(R)right _s+1barY_ellm(R) dR \n=\nint lefteth sum_ellmf_ellm _sY_ellm(R)right _s+1barY_ellm(R) dR \n=\nsum_ellm f_ellm int lefteth _sY_ellm(R)right _s+1barY_ellm(R) dR \n=\nsum_ellm f_ellm sqrt(ell-s)(ell+s+1) int _s+1Y_ellm(R) _s+1barY_ellm(R) dR \n=\nsum_ellm f_ellm sqrt(ell-s)(ell+s+1) delta_ellell delta_mm \n=\nf_ellm sqrt(ell-s)(ell+s+1)\nendaligned","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Similarly bareth — and R_pm of course — obey this more \"covariant\" form of transformation.","category":"page"},{"location":"operators/#Docstrings","page":"Differential operators","title":"Docstrings","text":"","category":"section"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Modules = [SphericalFunctions]\nPages   = [\"operators.jl\"]","category":"page"},{"location":"operators/#SphericalFunctions.Lz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.Lz","text":"Lz(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the angular-momentum operator associated with the z direction.  This is the standard L_z operator, familiar from basic physics, extended to work with SWSHs.  Note that this is the left Lie derivative; see Rz for the equivalent right Lie derivative.  See the documentation or Boyle for more details.\n\nIn terms of the SWSHs, we can write the action of L_z as\n\nL_z _sY_ellm = m _sY_ellm\n\nSee also L², L₊, L₋, R², Rz, R₊, R₋, ð, ð̄.\n\n\n\n\n\n","category":"method"},{"location":"operators/#SphericalFunctions.L²-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.L²","text":"L²(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the total angular-momentum operator from ℓₘᵢₙ up to ℓₘₐₓ.  If not present, ℓₘᵢₙ is assumed to be abs(s).  The argument s is ignored; it is present only for consistency with other operators, and is assumed to be 0 if not present.\n\nThis is the standard L² operator, familiar from basic physics, extended to work with SWSHs.  It is also known as the Casimir operator, and is equal to\n\nL^2 = L_x^2 + L_y^2 + L_z^2 = fracL_+L_- + L_-L_+ + 2L_zL_z2\n\nNote that these are the left Lie derivatives, but L^2 = R^2, where R is the right Lie derivative.  See the documentation or Boyle for more details.\n\nIn terms of the SWSHs, we can write the action of L^2 as\n\nL^2 _sY_ellm = ell(ell+1) _sY_ellm\n\nSee also Lz, L₊, L₋, R², Rz, R₊, R₋, ð, ð̄.\n\n\n\n\n\n","category":"method"},{"location":"operators/#SphericalFunctions.L₊-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.L₊","text":"L₊(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the angular-momentum raising operator.  This is the standard L_+ operator, familiar from basic physics, extended to work with SWSHs.  Note that this is the left Lie derivative; see R₊ for the equivalent right Lie derivative.  See the documentation or Boyle for more details.\n\nWe define L_+ to be the raising operator for the left Lie derivative with respect to rotation about z: L_z.  By definition, this implies the commutator relation L_z L_+ = L_+, which allows us to derive L_+ = L_x + i L_y\n\nIn terms of the SWSHs, we can write the action of L_+ as\n\nL_+ _sY_ellm = sqrt(ell-m)(ell+m+1) _sY_ellm+1\n\nConsequently, the mode weights of a function are affected as\n\nleftL_+(f)right_sellm = sqrt(ell+m)(ell-m+1)leftfright_sellm-1\n\nSee also L², Lz, L₋, R², Rz, R₊, R₋, ð, ð̄.\n\n\n\n\n\n","category":"method"},{"location":"operators/#SphericalFunctions.L₋-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.L₋","text":"L₋(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the angular-momentum lowering operator.  This is the standard L_- operator, familiar from basic physics, extended to work with SWSHs.  Note that this is the left Lie derivative; see R₋ for the equivalent right Lie derivative.  See the documentation or Boyle for more details.\n\nWe define L_- to be the lowering operator for the left Lie derivative with respect to rotation about z: L_z.  By definition, this implies the commutator relation L_z L_- = -L_-, which allows us to derive L_- = L_x - i L_y\n\nIn terms of the SWSHs, we can write the action of L_- as\n\nL_- _sY_ellm = sqrt(ell+m)(ell-m+1) _sY_ellm-1\n\nConsequently, the mode weights of a function are affected as\n\nleftL_-(f)right_sellm = sqrt(ell-m)(ell+m+1)leftfright_sellm+1\n\nSee also L², Lz, L₊, L₋, R², Rz, R₊, R₋, ð, ð̄.\n\n\n\n\n\n","category":"method"},{"location":"operators/#SphericalFunctions.Rz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.Rz","text":"Rz(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the right angular-momentum operator associated with the z direction.\n\nThis is the R_z operator, much like the L_z operator familiar from basic physics, but in terms of the right Lie derivative, and extended to work with SWSHs.  See Lz for the equivalent left Lie derivative.  See the documentation or Boyle for more details.\n\nIn terms of the SWSHs, we can write the action of R_z as\n\nR_z _sY_ellm = -s _sY_ellm\n\nNote the unfortunate sign of s, which seems to be opposite to what we expect, and arises from the choice of definition of s in the original paper by Newman and Penrose.\n\nSee also L², Lz, L₊, L₋, R², R₊, R₋, ð, ð̄.\n\n\n\n\n\n","category":"method"},{"location":"operators/#SphericalFunctions.R²-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.R²","text":"R²(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the total angular-momentum operator from ℓₘᵢₙ up to ℓₘₐₓ.  If not present, ℓₘᵢₙ is assumed to be abs(s).  The argument s is ignored; it is present only for consistency with other operators, and is assumed to be 0 if not present.\n\nThis is the R^2 operator, much like the L^2 operator familiar from basic physics, but in terms of the right Lie derivative, and extended to work with SWSHs.  It is also known as the Casimir operator, and is equal to\n\nR^2 = R_x^2 + R_y^2 + R_z^2 = fracR_+R_- + R_-R_+ + 2R_zR_z2\n\nNote that these are the right Lie derivatives, but L^2 = R^2, where L is the left Lie derivative.  See the documentation or Boyle for more details.\n\nIn terms of the SWSHs, we can write the action of R^2 as\n\nR^2 _sY_ellm = ell(ell+1) _sY_ellm\n\nSee also L², Lz, L₊, L₋, Rz, R₊, R₋, ð, ð̄.\n\n\n\n\n\n","category":"method"},{"location":"operators/#SphericalFunctions.R₊-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.R₊","text":"R₊(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the right angular-momentum raising operator.\n\nThis is the R_+ operator, much like the L_+ operator familiar from basic physics, but in terms of the right Lie derivative, and extended to work with SWSHs.  See L₊ for the equivalent left Lie derivative.  See the documentation or Boyle for more details.\n\nWe define R_+ to be the raising operator for the right Lie derivative with respect to rotation about z: R_z.  By definition, this implies the commutator relation R_z R_+ = R_+, which allows us to derive R_+ = R_x - i R_y\n\nIn terms of the SWSHs, we can write the action of R_+ as\n\nR_+ _sY_ellm = sqrt(ell+s)(ell-s+1) _s-1Y_ellm\n\nConsequently, the mode weights of a function are affected as\n\nleftR_+(f)right_sellm = sqrt(ell+s)(ell-s+1)leftfright_s-1ellm\n\nBecause of the unfortunate sign of s arising from the choice of definition of s in the original paper by Newman and Penrose, this is a lowering operator for s, though it really is a raising operator for R_z, and raises the eigenvalue of the corresponding Wigner matrix.\n\nSee also L², Lz, L₊, L₋, R², Rz, R₋, ð, ð̄.\n\n\n\n\n\n","category":"method"},{"location":"operators/#SphericalFunctions.R₋-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.R₋","text":"R₋(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the right angular-momentum lowering operator.\n\nThis is the R_- operator, much like the L_- operator familiar from basic physics, but in terms of the right Lie derivative, and extended to work with SWSHs.  See L₋ for the equivalent left Lie derivative.  See the documentation or Boyle for more details.\n\nWe define R_- to be the raising operator for the right Lie derivative with respect to rotation about z: R_z.  By definition, this implies the commutator relation R_z R_- = -R_-, which allows us to derive R_- = R_x + i R_y\n\nIn terms of the SWSHs, we can write the action of R_- as\n\nR_- _sY_ellm = sqrt(ell-s)(ell+s+1) _s+1Y_ellm\n\nConsequently, the mode weights of a function are affected as\n\nleftR_-(f)right_sellm = sqrt(ell-s)(ell+s+1)leftfright_s+1ellm\n\nBecause of the unfortunate sign of s arising from the choice of definition of s in the original paper by Newman and Penrose, this is a raising operator for s, though it really is a lowering operator for R_z, and lowers the eigenvalue of the corresponding Wigner matrix - though that raises the eigenvalue of the corresponding Wigner matrix.\n\nSee also L², Lz, L₊, L₋, R², Rz, R₊, ð, ð̄.\n\n\n\n\n\n","category":"method"},{"location":"operators/#SphericalFunctions.ð-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.ð","text":"ð(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute coefficients for the spin-raising operator eth.\n\nThis operator was originally defined by Newman and Penrose, but is more completely defined by Boyle.  It is identical to R₋.  Refer to that function's documentation for more details.\n\nBy definition, the spin-raising operator satisfies the commutator relation S eth = eth (where S is the spin operator, which just multiplies the function by its spin). In terms of the SWSHs, we can write the action of eth as\n\n    eth _sY_ellm = sqrt(ell-s)(ell+s+1) _s+1Y_ellm\n\nConsequently, the mode weights of a function are affected as\n\nlefteth fright_sellm = sqrt(ell-s)(ell+s+1)leftfright_s+1ellm\n\nSee also ð̄,  L², Lz, L₊, L₋, R², Rz, R₊.\n\n\n\n\n\n","category":"method"},{"location":"operators/#SphericalFunctions.ð̄-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.ð̄","text":"ð̄(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute coefficients for the spin-lowering operator bareth.\n\nThis operator was originally defined by Newman and Penrose, but is more completely defined by Boyle.  It is opposite to R₊ — meaning that bareth = -R.  Refer to that function's documentation for more details.\n\nBy definition, the spin-lowering operator satisfies the commutator relation S bareth = -bareth (where S is the spin operator, which just multiplies the function by its spin).  In terms of the SWSHs, we can write the action of bareth as\n\nbareth _sY_ellm = -sqrt(ell+s)(ell-s+1) _s-1Y_ellm\n\nConsequently, the mode weights of a function are affected as\n\nleftbareth fright_sellm\n= -sqrt(ell-s)(ell+s+1)leftfright_s+1ellm\n\nSee also ð,  L², Lz, L₊, L₋, R², Rz, R₊.\n\n\n\n\n\n","category":"method"},{"location":"conventions/details/#Details","page":"Details","title":"Details","text":"","category":"section"},{"location":"conventions/details/","page":"Details","title":"Details","text":"This page carefully works through all the conventions used in this package, starting from first principles to motivate the choices and ensure that each step is on firm footing.  The previous page collects the results in a more concise form.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Note that we will use Euler angles and spherical coordinates here, but they are not used internally in this package — though conversion functions are available.  It is almost always a bad idea to use Euler angles in computing; quaternions are clearly the preferred representation for numerous reasons.  However, Euler angles are important for (a) comparing to other sources, and (b) performing analytic integrations.  These are the only two uses we will make of Euler angles.","category":"page"},{"location":"conventions/details/#Three-dimensional-space","page":"Details","title":"Three-dimensional space","text":"","category":"section"},{"location":"conventions/details/","page":"Details","title":"Details","text":"The space we are working in is naturally three-dimensional Euclidean space, so we start with a right-handed Cartesian coordinate system (x y z).  These also give us the unit basis vectors (𝐱 𝐲 𝐳).  Note that these basis vectors are assumed to have unit norm, but we omit the hats just to keep the notation simple.  Any vector in this space can be written as","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"mathbfv = v_x mathbf𝐱 + v_y mathbf𝐲 + v_z mathbf𝐳","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"in which case the Euclidean norm is given by","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":" mathbfv  = sqrtv_x^2 + v_y^2 + v_z^2","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Equivalently, we can write the components of the Euclidean metric as","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"g_ij = left( beginarrayccc\n  1  0  0 \n  0  1  0 \n  0  0  1\nendarray right)_ij","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Note that, because the points of the space are in one-to-one correspondence with the vectors, we will frequently use a vector to label a point in space.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"We will be working on the sphere, so it will be very convenient to use spherical coordinates (r theta phi).  We choose the standard \"physics\" conventions for these, in which we relate to the Cartesian coordinates by","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nr = sqrtx^2 + y^2 + z^2 in 0 infty) \ntheta = arccosleft(fraczrright) in 0 pi \nphi = arctanleft(fracyxright) in 0 2pi)\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"where we assume the arctan in the expression for phi is really the two-argument form that gives the correct quadrant.  The inverse transformation is given by","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nx = r sintheta cosphi \ny = r sintheta sinphi \nz = r costheta\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"We can use this to find the components of the metric in spherical coordinates:","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"g_ij\n= sum_ij fracpartial x^ipartial x^i fracpartial x^jpartial x^j g_ij\n= left( beginarrayccc\n  1  0  0 \n  0  r^2  0 \n  0  0  r^2 sin^2theta\nendarray right)_ij","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"The unit coordinate vectors in spherical coordinates are then","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nmathbf𝐫 = sintheta cosphi mathbf𝐱 + sintheta sinphi mathbf𝐲 + costheta mathbf𝐳 \nboldsymboltheta = costheta cosphi mathbf𝐱 + costheta sinphi mathbf𝐲 - sintheta mathbf𝐳 \nboldsymbolphi = -sinphi mathbf𝐱 + cosphi mathbf𝐲\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"where, again, we omit the hats on the unit vectors to keep the notation simple.  Conversely, we can express the Cartesian basis vectors in terms of the spherical basis vectors as","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nmathbf𝐱 = sintheta cosphi mathbf𝐫 + costheta cosphi boldsymboltheta - sinphi boldsymbolphi \n\nmathbf𝐲 = sintheta sinphi mathbf𝐫 + costheta sinphi boldsymboltheta + cosphi boldsymbolphi\n\nmathbf𝐳 = costheta mathbf𝐫 - sintheta boldsymboltheta\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"One seemingly obvious — but extremely important — fact is that the unit basis frame (𝐱 𝐲 𝐳) can be rotated onto (boldsymboltheta boldsymbolphi mathbfr) by first rotating through the \"polar\" angle theta about the mathbfy axis, and then through the \"azimuthal\" angle phi about the mathbfz axis.  This becomes important when we consider spin-weighted functions.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Integration in Cartesian coordinates is, of course, trivial as","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"int_mathbbR^3 f d^3mathbfr = int_-infty^infty int_-infty^infty int_-infty^infty f dx dy dz","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"In spherical coordinates, the integrand involves the square-root of the determinant of the metric, so we have","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"int_mathbbR^3 f d^3mathbfr = int_0^infty int_0^pi int_0^2pi f r^2 sintheta dr dtheta dphi","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Restricting to the unit sphere, and normalizing so that the integral of 1 over the sphere is 1, we can simplify this to","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"int_S^2 f d^2Omega = frac14pi int_0^pi int_0^2pi f sintheta dtheta dphi","category":"page"},{"location":"conventions/details/#Four-dimensional-space:-Quaternions-and-rotations","page":"Details","title":"Four-dimensional space: Quaternions and rotations","text":"","category":"section"},{"location":"conventions/details/#Geometric-algebra","page":"Details","title":"Geometric algebra","text":"","category":"section"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Given the basis vectors (𝐱 𝐲 𝐳) and the Euclidean norm, we can define the geometric algebra.  The key feature is the geometric product, which is defined for any pair of vectors as 𝐯 and 𝐰 as","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"𝐯 𝐰 = 𝐯  𝐰 + 𝐯  𝐰","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"where the dot product is the usual scalar product and the wedge product is the antisymmetric part of the tensor product — acting just like the standard exterior product from the algebra of differential forms.  The geometric product is linear, associative, distributive, and has the property that","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"𝐯𝐯 =  𝐯 ^2","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"The most useful properties of the geometric product are that parallel vectors commute with each other, while orthogonal vectors anticommute. Since the geometric product is linear, the product of any two vectors can be decomposed into parallel and orthogonal parts.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"The basis for this entire space is then the set","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"begingather\n𝟏 \n𝐱 𝐲 𝐳\n𝐱𝐲 𝐱𝐳 𝐲𝐳 \n𝐱𝐲𝐳\nendgather","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"The standard presentation of quaternions (including the confused historical development) uses different symbols for these last four basis elements:","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"begingather\n𝐢 = 𝐳𝐲 = -𝐲𝐳 \n𝐣 = 𝐱𝐳 = -𝐳𝐱 \n𝐤 = 𝐲𝐱 = -𝐱𝐲 \n𝐈 = 𝐱𝐲𝐳\nendgather","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Note that each of these squares to -1.  For example, recalling that orthogonal vectors anticommute, the product is associative, and the product of a vector with itself is just its squared norm, we have","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"𝐱𝐲𝐱𝐲 = -𝐱𝐲𝐲𝐱 = -𝐱(𝐲𝐲)𝐱 = -𝐱𝐱 = -1","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Any of these could act like the unit imaginary; 𝐱𝐲 is probably the canonical choice.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"𝐈 is sometimes called the pseudoscalar.  Its inverse is 𝐈^-1 = 𝐳𝐲𝐱 = -𝐱𝐲𝐳, which can also serve as something very much like the Hodge star operator,[1] mapping elements to their \"dual\" elements.  In particular, we have","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\n𝐢 = 𝐈^-1𝐱 \n𝐣 = 𝐈^-1𝐲 \n𝐤 = 𝐈^-1𝐳\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"We will see that 𝐢 generates right-handed rotations in the positive sense about 𝐱, 𝐣 about 𝐲, and 𝐤 about 𝐳.  Moreover, this mapping between (𝐱 𝐲 𝐳) and (𝐢 𝐣 𝐤) is a vector-space isomorphism.  In fact, the reader who is not familiar with geometric algebra but is familiar with quaternions may be able to read an expression like 𝐣 𝐱 𝐣¹ as if it is just an abuse of notation, and mentally replace 𝐱 with 𝐢 to read those symbols as a valid quaternion expression; both viewpoints are equally correct by the isomorphism.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"[1]: Note that quaternions will only be spanned by elements made from   an even number of the basis vectors.  It turns out that those   with an odd number will produce reflections, rather than   rotations, when acting on a vector — as discussed below.  This   explains why quaternions are restricted to just those elements   with an even number to represent rotations.  For details see any   geometric algebra text, like Doran and Lasenby.","category":"page"},{"location":"conventions/details/#Quaternions-and-Euler-angles","page":"Details","title":"Quaternions and Euler angles","text":"","category":"section"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Note that there are different conventions for the signs of the (𝐢 𝐣 𝐤) basis.  Everyone agrees that 𝐢² = 𝐣² = 𝐤² = -1, but we could easily flip the sign of any basis element, and these would still be satisfied.  The identifications we chose above are made to ensure that 𝐢 generates rotations about 𝐱, and so on, but even that depends on how we define quaternions as acting on vectors (to be discussed below).  A different choice of the latter would result in all flipping the sign of all three basis elements, which is a convention that is commonly used — though almost exclusively in aerospace.  The key expressions that eliminate ambiguity are the multiplications","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\n𝐢 𝐣 = 𝐤 \n𝐣 𝐤 = 𝐢 \n𝐤 𝐢 = 𝐣\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"We can also use these rules above to determine 𝐢𝐣𝐤 = -𝟏.  All four of these equations have flipped signs in other conventions.  See Sommer et al. for a discussion of the different conventions.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"We use coordinates (W X Y Z) on the space of quaternions, so that a quaternion would be written as","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"𝐐 = W𝟏 + X𝐢 + Y𝐣 + Z𝐤","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"though we usually omit the 𝟏.  The space of all quaternions is thus four dimensional.  The norm is just the standard Euclidean norm, so that the norm of a quaternion is","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":" 𝐐  = sqrtW^2 + X^2 + Y^2 + Z^2","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"An important operation is the conjugate, which is defined as","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"overline𝐐 = W - X𝐢 - Y𝐣 - Z𝐤","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Note that the squared norm can be written as the quaternion times its conjugate.  Any nonzero quaternion has an inverse, which is just the conjugate divided by the squared norm:","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"𝐐^-1 = fracoverline𝐐𝐐overline𝐐 = fracoverline𝐐 𝐐 ^2","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"The other important operation is exponentiation.  Since a scalar commutes with any quaternion, including a nonzero scalar component in the quaternion will simply multiply the result by the exponential of that scalar component.  Moreover, we will not have any use for such an exponential, so we assume that the argument to the exponential function is a \"pure\" quaternion — that is, one with zero scalar component.  Moreover, we write it as a unit quaternion 𝐮 times some real number sigma.  In particular, note that 𝐮^2 = -1, so that it acts like the imaginary unit, which means we already know how to exponentiate it:","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"exp(𝐮 sigma) = cossigma + 𝐮 sinsigma","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Note that the inverse of the result can be obtained simply by negating the argument, as usual.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Much as with standard three-dimensional space, we could introduce a generalization of spherical coordinates, though we use a slight variant: extended Euler coordinates.  We will see below how to interpret these as a series of rotations.  For now, we simply state the relation:","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nR = sqrtW^2 + X^2 + Y^2 + Z^2 in 0 infty) \nalpha = arctanfracZW + arctanfrac-XY in 0 2pi) \nbeta = 2arccossqrtfracW^2+Z^2W^2+X^2+Y^2+Z^2 in 0 2pi \ngamma = arctanfracZW - arctanfrac-XY in 0 2pi)\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"where we again assume the arctan in the expressions for alpha and gamma is really the two-argument form that gives the correct quadrant.  Note that here, beta ranges up to 2pi rather than just pi, as in the standard Euler angles.  This is because we are describing the space of quaternions, rather than just the space of rotations.  If we restrict to R=1, we have exactly the group of unit quaternions mathrmSpin(3)=mathrmSU(2), which is a double cover of the rotation group mathrmSO(3). This extended range for beta is necessary to cover the entire space of quaternions; if we further restrict to 0 pi), we would only cover the space of rotations.  This and the inclusion of R identify precisely how this coordinate system extends the standard Euler angles.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"The inverse transformation is given by","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\n  W = R cosfracβ2 cosfracα+γ2 \n  X = -R sinfracβ2 sinfracα-γ2 \n  Y = R sinfracβ2 cosfracα-γ2 \n  Z = R cosfracβ2 sinfracα+γ2\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"As with the spherical coordinates, we can use this to find the components of the metric in our extended Euler coordinates:","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"g_ij\n= sum_ij fracpartial X^ipartial X^i fracpartial X^jpartial X^j g_ij\n= left( beginarraycccc\n  1  0  0  0 \n  0  fracR^24  0  fracR^2 cosbeta4 \n  0  0  fracR^24  0 \n  0  fracR^2 cosbeta4  0  fracR^24\nendarray right)_ij","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"The unit basis vectors in extended Euler coordinates in terms of the unit basis vectors in quaternion coordinates are","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nmathbf𝐑 = frac1R left(\n  cos fracbeta2 cos fracalpha+gamma2 𝟏\n  - sin fracbeta2 sin fracalpha-gamma2 𝐢\n  + sin fracbeta2 cos fracalpha-gamma2 𝐣\n  + cos fracbeta2 sin fracalpha+gamma2 𝐤\nright) \nboldsymbolalpha = fracR2 left(\n  -cos fracbeta2 sin fracalpha+gamma2 𝟏\n  - sin fracbeta2 cos fracalpha-gamma2 𝐢\n  - sin fracbeta2 sin fracalpha-gamma2 𝐣\n  + cos fracbeta2 cos fracalpha+gamma2 𝐤\nright) \nboldsymbolbeta = fracR2 left(\n  -sin fracbeta2 cos fracalpha+gamma2 𝟏\n  - cos fracbeta2 sin fracalpha-gamma2 𝐢\n  + cos fracbeta2 cos fracalpha-gamma2 𝐣\n  - sin fracbeta2 sin fracalpha+gamma2 𝐤\nright) \nboldsymbolgamma = fracR2 left(\n  -cos fracbeta2 sin fracalpha+gamma2 𝟏\n  + sin fracbeta2 cos fracalpha-gamma2 𝐢\n  - sin fracbeta2 cos fracalpha-gamma2 𝐣\n  - cos fracbeta2 sin fracalpha+gamma2 𝐤\nright)\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Again, integration involves a square-root of the determinant of the metric, which reduces to R^3 sinbeta  8.  Note that — unlike with standard spherical coordinates — the absolute value is necessary because beta ranges over the entire interval 0 2pi.  The integral over the entire space of quaternions is then","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"int_mathbbR^4 f d^4𝐐\n= int_-infty^infty int_-infty^infty int_-infty^infty int_-infty^infty f dW dX dY dZ\n= int_0^infty int_0^2pi int_0^2pi int_0^2pi f fracR^38 sin β dR dα dβ dγ","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Restricting to the unit sphere, and normalizing so that the integral of 1 over the sphere is 1, we can simplify this to","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"int_mathrmSpin(3) f d^3Omega\n= frac116pi^2 int_0^2pi int_0^2pi int_0^2pi f sin β dα dβ dγ","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Finally, restricting to the space of rotations, we can further simplify this to","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"int_mathrmSO(3) f d^3Omega\n= frac18pi^2 int_0^2pi int_0^pi int_0^2pi f sin β dα dβ dγ","category":"page"},{"location":"conventions/details/#Rotations","page":"Details","title":"Rotations","text":"","category":"section"},{"location":"conventions/details/","page":"Details","title":"Details","text":"We restrict to a unit quaternion 𝐑, for which W^2 + X^2 + Y^2 + Z^2 = 1.  Given this constraint we can, without loss of generality, write the quaternion as","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"𝐑\n= expleft(fracrho2 hatmathfrakrright)\n= cosfracrho2 + sinfracrho2 hatmathfrakr","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"where rho is an angle of rotation and hatmathfrakr is a unit \"pure-vector\" quaternion.  We can multiply a vector 𝐯 as","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"𝐑 𝐯 𝐑^-1","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Splitting 𝐯 = 𝐯_ + 𝐯_ into components perpendicular and parallel to hatmathfrakr, we see that 𝐯_ commutes with 𝐑 and 𝐑^-1, while 𝐯_ anticommutes with hatmathfrakr.  To find the full rotation, we expand the product:","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\n𝐑 𝐯 𝐑^-1\n= 𝐯_\n   + left(cosfracrho2 + sinfracrho2 hatmathfrakrright)\n     𝐯_\n     left(cosfracrho2 - sinfracrho2 hatmathfrakrright) \n= 𝐯_\n   + left(cosfracrho2 𝐯_ + sinfracrho2 hatmathfrakr 𝐯_right)\n     left(cosfracrho2 - sinfracrho2 hatmathfrakrright) \n= 𝐯_\n   + cos^2fracrho2 𝐯_ + sinfracrho2 cosfracrho2 hatmathfrakr 𝐯_\n   - sinfracrho2 cosfracrho2 𝐯_  hatmathfrakr - sin^2fracrho2 hatmathfrakr 𝐯_ hatmathfrakr \n= 𝐯_\n   + cos^2fracrho2 𝐯_ + sinfracrho2 cosfracrho2 hatmathfrakr 𝐯_ - sin^2fracrho2 𝐯_ \n= 𝐯_\n   + cosrho 𝐯_ + sinrho hatmathfrakrtimes 𝐯_\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"The final expression shows that this is precisely what we expect when rotating 𝐯 through an angle rho (in a positive, right-handed sense) about the axis hatmathfrakr.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Note that the presence of two factors of 𝐑 in the expression for rotating a vector explains two things.  First, it explains why the angle of rotation is twice the angle of the quaternion: one factor of 𝐑 either commutes and cancels or anti-commutes and combines with the the other factor.  Second, it explains why the quaternion group is a double cover of the rotation group: negating 𝐑 results in the same rotation.  Thus, for any rotation, there are two (precisely opposite) quaternions that represent it.","category":"page"},{"location":"conventions/details/#Euler-angles-and-spherical-coordinates","page":"Details","title":"Euler angles and spherical coordinates","text":"","category":"section"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Now that we understand how rotations work, we can provide geometric intuition for the expressions given above for Euler angles.  The Euler angles in our convention represent an initial rotation through gamma about the 𝐳 axis, followed by a rotation through beta about the 𝐲 axis, and finally a rotation through alpha about the 𝐳 axis.  Note that the axes are fixed, and not subject to any preceding rotations.  More precisely, we can write the unit quaternion as","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"𝐑 = expleft(fracalpha2 𝐤right)\n    expleft(fracbeta2 𝐣right)\n    expleft(fracgamma2 𝐤right)","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"One of the more important interpretations of a rotor is considering what it does to the basis triad (𝐱 𝐲 𝐳).  In particular, the vector 𝐳 is rotated onto the point given by spherical coordinates (theta phi) = (beta alpha), while 𝐱 and 𝐲 are rotated into the plane spanned by the unit basis vectors boldsymboltheta and boldsymbolphi corresponding to that point.  If gamma = 0 the rotation is precise, meaning that 𝐱 is rotated onto boldsymboltheta and 𝐲 onto boldsymbolphi; if gamma  0 then they are rotated within that plane by the angle gamma about the mathbfr axis. Thus, we identify the spherical coordinates (theta phi) with the Euler angles (alpha beta gamma) = (phi theta 0).","category":"page"},{"location":"conventions/details/#Rotation-and-angular-momentum-operators","page":"Details","title":"Rotation and angular-momentum operators","text":"","category":"section"},{"location":"conventions/details/#Complex-valued-functions","page":"Details","title":"Complex-valued functions","text":"","category":"section"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Starting with Cartesian coordinates and the Euclidean norm on mathbbR^3, we have constructed the geometric algebra over that space, as well as the spaces mathrmSpin(3) = mathrmSU(2) (topologically S^3), mathrmSO(3) (topologically mathbbRP^3), and S^2.  We will be defining complex-valued functions on these spaces, and defining operators to construct and classify them.  In particular, because we have constructed the spaces, they are naturally supplied with coordinates that are effectively inherited from the original Cartesian system.  We will be using these coordinate systems to construct both the operators and functions.  However, it is important to note that the coordinate systems may have singularities, which means that the spaces of coordinates may have different topologies than the spaces they represent.  For example, Euler angles have topology S^1 times I times S^1 instead of the S^3 and mathbbRP^3 topologies of the spaces they represent; spherical coordinates have topology S^1 times I instead of S^2.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Defining functions on the coordinate system of a space is subtly different from defining functions on the space itself.  For example, spin-weighted functions are generally written as functions of (S^2) spherical coordinates.  However, they cannot be defined as functions on S^2 itself; some notion of a reference tangent direction is needed at each point.  The difference is that spherical coordinates supply a natural choice for the reference tangent direction: the unit vector in the boldsymboltheta direction. This supplies just enough information to define the spin-weighted functions — though this ends up not being a useful form when more general transformations or deeper understanding are needed.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Because of this variety of spaces, we will need to use function composition in several ways; functions defined on one space can be \"lifted\" or \"lowered\" to another via maps between the spaces.  In the diagram below, the function F can be used to define the function f via the mapping m as f = m circ F.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"<div class=\"composition-diagram\">\n<?xml version='1.0' encoding='UTF-8'?>\n<!-- This file was generated by dvisvgm 3.2.2 -->\n<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='135.540542pt' height ='77.088398pt' viewBox='-77.707098 -79.853543 145.540542 99.088398'>\n<g id='page1'>\n<text class='f1' x='8.094022' y='-98.111224' transform='matrix(1 0 0 1 -75.80112 37.3849)'>A</text>\n<text class='f1' x='135.870232' y='-98.111224' transform='matrix(1 0 0 1 -76.0934 37.3849)'>B</text>\n<text class='f0' x='71.835977' y='-30.150075' transform='matrix(1 0 0 1 -75.66273 37.38493)'>C</text>\n<path d='M-55.742164-63.2187H54.886736' stroke-width='.39848' stroke-miterlimit='10'/>\n<path d='M53.0156-65.60941C53.3906-64.17582 54.234347-63.496133 55.085909-63.218789C54.234347-62.937539 53.3906-62.261758 53.0156-60.82816' stroke-width='.39848' stroke-miterlimit='10' stroke-linecap='round' stroke-linejoin='round'/>\n<text class='f1' x='.064136' y='-30.150075' transform='matrix(1 0 0 1 -4.666016 -35.414)'>m</text>\n<path d='M-58.027364-56.8789L-8.207034-3.7695' stroke-width='.39848' stroke-miterlimit='10' stroke-dasharray='2.78941 1.59395'/>\n<path d='M-7.742183-6.769534C-8.531245-5.511715-8.449215-4.433593-8.070309-3.621092C-8.855465-4.05078-9.925779-4.203125-11.230462-3.499999' stroke-width='.39848' stroke-miterlimit='10' stroke-linecap='round' stroke-linejoin='round'/>\n<text class='f1' x='.064136' y='-30.150075' transform='matrix(1 0 0 1 -41.341736 9.2371)'>f</text>\n<path d='M57.839836-56.8789L7.785156-3.7656' stroke-width='.39848' stroke-miterlimit='10'/>\n<path d='M10.808601-3.492188C9.507814-4.199216 8.433598-4.050779 7.648441-3.621093C8.027348-4.433593 8.113288-5.511721 7.33204-6.769528' stroke-width='.39848' stroke-miterlimit='10' stroke-linecap='round' stroke-linejoin='round'/>\n<text class='f1' x='.064136' y='-30.150075' transform='matrix(1 0 0 1 34.957364 9.1264)'>F</text>\n</g>\n</svg>\n</div>","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"For example, A could be the space of spherical coordinates, B could be mathrmSpin(3), and F could be a spin-weighted function.  There are many maps from spherical coordinates into mathrmSpin(3); we expect that all such maps will be related by rotations from mathrmSO(3), and in some sense equivalent via some universality relation.  However, for singular maps — such as coordinate singularities where multiple coordinate values correspond to a single \"physical\" point — we find exceptions to the universality. These compositions will be useful, in that we can define functions on the \"largest\" available space, and extend them to any space that maps into the first.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"In principle, our functions should be defined on mathrmSpin(3) or even the quaternions in general, though in practice we will define them on the space of coordinates on those spaces.  In any case, we will classify the functions by their behavior with respect to actions of mathrmSpin(3) on the argument to the function.  Therefore, we need to consider the general behavior of functions under such actions.","category":"page"},{"location":"conventions/details/#Finite-rotations","page":"Details","title":"Finite rotations","text":"","category":"section"},{"location":"conventions/details/","page":"Details","title":"Details","text":"We work with functions f A to mathbbC, where A is either the group of unit quaternions, or the full algebra of quaternions. Any non-zero quaternion can be expressed as e^mathfrakg for some finite quaternion mathfrakg, which is referred to as the \"generator\" of the action of e^mathfrakg.  This can act on a function f by multiplying the argument by e^mathfrakg. However, there is an ambiguity: we could multiply either on the left or the right:[2]","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"fleft(mathbfQright) mapsto fleft(e^mathfrakg mathbfQright)\nqquad textor qquad\nfleft(mathbfQright) mapsto fleft(mathbfQ e^mathfrakgright)","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"There is an additional ambiguity, in that this action rotates the argument of the function, whereas we will often prefer to think in terms of rotating the function itself.  For example, our function may describe the measurement of some field in a particular coordinate system.  Here, the argument mathbfQ describes a particular value of the coordinates, and e^mathfrakg changes the point under consideration.  If, on the other hand e^mathfrakg describes how the field itself is rotated, then we can write the rotated field as a function f which is related to the original function f by","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"fleft(mathbfQright) = fleft(e^-mathfrakg mathbfQright)\nqquad textor qquad\nfleft(mathbfQright) = fleft(mathbfQ e^-mathfrakgright)","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Note that the exponent is negated, because the action of e^mathfrakg on the argument is the inverse of the action of e^-mathfrakg on the function.  This is a general property of the action of a group on a space, and is a consequence of the group action being a homomorphism.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"[2]: In group theory, this type of transformation is often referred   to as a \"translation\", even when — as in this case — we would   usually describe these as rotations.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"To validate the signs here, it may be helpful to work through a simple example involving the sphere S^2.  We define a function on spherical coordinates as","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"f(theta phi) = sintheta sinphi","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Recall that we can map the spherical coordinates into the Euler angles, and the Euler angles into the quaternion","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"(theta phi) mapsto (phi theta 0) mapsto mathbfQ\n=\nexpleft(fracphi2 mathbfkright)\nexpleft(fractheta2 mathbfjright)","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"It is straightforward to see that we can write f as a function of mathbfQ as","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"f(mathbfQ) = leftlangle mathbfQ mathbfk mathbfQ^-1 rightrangle_mathbfj","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"where the angle brackets and subscript indicate that we are taking the mathbfj component.  That is, f is the y component of the vector mathbfz rotated by mathbfQ. ","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Now, we imagine rotating the field by an angle alpha in the positive sense about the z axis.  Visualizing the situation, we can see that the rotated field should be represented by","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"f(theta phi) = sintheta sin(phi - alpha)","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"For example, the rotated field evaluated at the point (theta phi) = (pi2 0) along the positive x axis should correspond to the original field evaluated at the point (theta phi) = (pi2 -alpha).  This rotation is generated by mathfrakg = alpha mathbfk  2, which allows us to immediately calculate","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nf(e^mathfrakg mathbfQ) = sintheta sin(phi + alpha) \nf(mathbfQ e^mathfrakg) = sintheta sinphi \nf(e^-mathfrakg mathbfQ) = sintheta sin(phi - alpha) \nf(mathbfQ e^-mathfrakg) = sintheta sinphi\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Thus, we see that left-multiplication by e^-mathfrakg corresponds to rotation of the field while leaving the coordinates fixed; left-multiplication by e^mathfrakg corresponds to rotation of the coordinates while leaving the field fixed; and right-multiplication by either doesn't affect this function at all.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Of course, right-multiplication using other choices for mathfrakg could certainly have some effect on this function, and this choice of mathfrakg could have an effect on other functions.  Note that right-multiplication can also be interpreted as left-multiplication, where the generator itself is rotated by the argument to the function.  That is,","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nf(mathbfQ e^mathfrakg)\n  = f(mathbfQ e^mathfrakg mathbfQ^-1 mathbfQ)\n  = f(e^mathfrakg mathbfQ) \nf(mathbfQ e^-mathfrakg)\n  = f(mathbfQ e^-mathfrakg mathbfQ^-1 mathbfQ)\n  = f(e^-mathfrakg mathbfQ)\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"where mathfrakg = mathbfQ mathfrakg mathbfQ^-1.  In this example, mathfrakg generates a rotation by an angle alpha about the point in question, which leaves that point fixed, and since this is a scalar function it has no effect on the value.  Of course, we will see below that changing by a phase proportional to alpha is the defining feature of a spin-weighted function.","category":"page"},{"location":"conventions/details/#Differential-rotations","page":"Details","title":"Differential rotations","text":"","category":"section"},{"location":"conventions/details/","page":"Details","title":"Details","text":"We now define a pair of operators that differentiate a function with respect to infinitesimal rotations we apply to the functions themselves:","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nL_mathfrakg f(mathbfQ) = lambda left fracpartial partial theta f left( e^-theta mathfrakg  2 mathbfQ right) right_theta=0 \nR_mathfrakg f(mathbfQ) = rho left fracpartial partial theta f left( mathbfQ e^-theta mathfrakg  2 right) right_theta=0\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Here, we have introduced the constants lambda and rho because we will actually be able to derive their values — up to signs — based on the requirement that raising and lowering operators exist for each.  Finally, we will choose the signs based on demands that these operators correspond as naturally as possible to the standard canonical angular-momentum operators.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Note that when composing operators, it is critical to keep track of the order of operations, which may look slightly unnatural:","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\n  L_mathfrakg L_mathfrakh f(mathbfQ)\n   = left lambda fracpartial partial gamma fleft(e^-gamma mathfrakg  2 mathbfQ right) right_gamma=0 \n  = left lambda^2 fracpartial partial gamma fracpartial partial eta fleft(e^-eta mathfrakh  2 e^-gamma mathfrakg  2 mathbfQ right) right_gamma=eta=0 \n  R_mathfrakg R_mathfrakh f(mathbfQ)\n   = rho left fracpartial partial gamma f left( mathbfQ e^-gamma mathfrakg  2 right) right_gamma=0 \n  = left rho^2 fracpartial partial gamma fracpartial partial eta fleft( mathbfQ e^-gamma mathfrakg  2 e^-eta mathfrakh  2 right) right_gamma=eta=0\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"We can prove the first of these, for example, by defining f(mathbfQ) = L_mathfrakh f(mathbfQ), then applying the definition of L_mathfrakg to f(mathbfQ), and finally substituting the definition of f back in.  If we failed to use the correct order of operations, we would get sign errors when trying to evaluate the commutators.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"These operators have some nice properties.  For any scalar s, we have","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nL_s mathfrakg = s L_mathfrakg \nR_s mathfrakg = s R_mathfrakg\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Given any basis mathbfe_n for the quaternions, we can use the multivariable chain rule to expand the operators in terms of components:","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nL_mathfrakg = sum_n g_n L_mathbfe_n \nR_mathfrakg = sum_n g_n R_mathbfe_n\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"This implies that vector addition holds more generally:","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nL_mathfrakg + mathfrakh = L_mathfrakg + L_mathfrakh \nR_mathfrakg + mathfrakh = R_mathfrakg + R_mathfrakh\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Moreover, we can show that these operators form a Lie algebra with the commutator as the Lie bracket.  That is, we have","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nL_mathfrakg L_mathfrakh\n    = fraclambda2 L_mathfrakg mathfrakh\n\nR_mathfrakg R_mathfrakh\n    = -fracrho2 R_mathfrakg mathfrakh\n\nL_mathfrakg R_mathfrakh = 0\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Conventionally, we single out the mathbfz axis — or equivalently the generator mathbfk = mathbfymathbfx — as a sort of fiducial axis, and L_z = L_mathbfk and R_z = R_mathbfk as the fiducial operators.  Then, by definition, their raising operators L_+ and R_+ and lowering operators L_- and R_- satisfy ","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nL_z L_pm = pm L_pm \nR_z R_pm = pm R_pm\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Assuming that the raising and lowering operators can be written as linear combinations of the basis operators, these equations imply that they have no component proportional L_mathbfz, and that both of the remaining components must be nonzero.  This actually allows us to deduce that lambda^2 = rho^2 = -1.  This, in turn, allows us to deduce the values of the raising and lowering operators up to an overall factor.  Conventionally the factor is chosen so that","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nL_pm = L_mathbfx pm i L_mathbfy \nR_pm = R_mathbfx pm i R_mathbfy\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"TODO: Impose R_z = s\nTODO: Impose Condon-Shortley condition (positive, real eigenvalues of R_pm)\nTODO: Show how the following happens","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Using these relations, we can actually solve for the constants lambda and rho up to a sign.  We find that","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nlambda = i \nrho = -i\nendaligned","category":"page"},{"location":"conventions/details/#Angular-momentum-operators-in-Euler-angles","page":"Details","title":"Angular-momentum operators in Euler angles","text":"","category":"section"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Express angular momentum operators in terms of Euler angles\nWe just rewrite the R in the Lie definitions in terms of Euler angles, multiply by exp(theta2), rederive the new Euler angles from that result, and use the chain rule\nShow for both the three- and two-spheres\nShow how they act on functions on the three-sphere","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"The idea here is to express, e.g., e^theta mathbfe_i  2mathbfR_alpha beta gamma in quaternion components, then solve for the new Euler angles mathbfR_alpha beta gamma in terms of the quaternion components, where these new angles all depend on theta.  We then use the chain rule to express partial_theta in terms of partial_alpha, etc., which become partial_alpha, etc., when theta=0.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\n  L_i f(mathbfR_alpha beta gamma)\n  =\n  left -mathbfz fracpartial partial theta f left( e^theta mathbfe_i  2 mathbfR_alpha beta gamma right) right_theta=0 \n  =\n  left -mathbfz fracpartial partial theta f left( mathbfR_alpha beta gamma right) right_theta=0 \n  =\n  left -mathbfz left fracpartial alpha partial thetafracpartial partial alpha + fracpartial beta partial thetafracpartial partial beta + fracpartial gamma partial thetafracpartial partial gamma right f left( mathbfR_alpha beta gamma right) right_theta=0 \n  =\n  -mathbfz left fracpartial alpha partial thetafracpartial partial alpha + fracpartial beta partial thetafracpartial partial beta + fracpartial gamma partial thetafracpartial partial gamma right_theta=0 f left( mathbfR_alpha beta gamma right) \n  K_i f(mathbfR_alpha beta gamma)\n  =\n  -mathbfz left fracpartial alpha partial thetafracpartial partial alpha + fracpartial beta partial thetafracpartial partial beta + fracpartial gamma partial thetafracpartial partial gamma right_theta=0 f left( mathbfR_alpha beta gamma right)\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nmathbfR_alpha beta gamma\n=\n  R cosfracβ2 cosfracα+γ2\n  -R sinfracβ2 sinfracα-γ2 mathbfi\n  + R sinfracβ2 cosfracα-γ2 mathbfj\n  + R cosfracβ2 sinfracα+γ2 mathbfk\n\ne^theta mathbfu  2 mathbfR_alpha beta gamma\n= left(cosfractheta2 + mathbfu sinfractheta2right) mathbfR_alpha beta gamma\n\n=\n  R cosfractheta2 cosfracβ2 cosfracα+γ2\n  -R cosfractheta2 sinfracβ2 sinfracα-γ2 mathbfi\n  + R cosfractheta2 sinfracβ2 cosfracα-γ2 mathbfj\n  + R cosfractheta2 cosfracβ2 sinfracα+γ2 mathbfk\n\nquad +\n  R sinfractheta2cosfracβ2 cosfracα+γ2 mathbfu\n  -R sinfractheta2sinfracβ2 sinfracα-γ2 mathbfumathbfi\n  + R sinfractheta2sinfracβ2 cosfracα-γ2 mathbfumathbfj\n  + R sinfractheta2cosfracβ2 sinfracα+γ2 mathbfumathbfk\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nalpha = arctanfracZW + arctanfrac-XY in 0 2pi) \nbeta = 2arccossqrtfracW^2+Z^2W^2+X^2+Y^2+Z^2 in 0 2pi \ngamma = arctanfracZW - arctanfrac-XY in 0 2pi)\nendaligned","category":"page"},{"location":"conventions/details/#Laplacians","page":"Details","title":"Laplacians","text":"","category":"section"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Bander and Itzykson [12] show that Wigner's D matrices (extended to the full space of quaternions with arbitrary norm) are harmonic with respect to the Laplacian of the full 4-D space.  We also know that","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Delta_S^n-1 f(x) = Delta_mathbbR^n f(xx)","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"and","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Delta_mathbbR^n f(x)\n=\nfrac1r^n-1 fracpartialpartial r left( r^n-1 fracpartial fpartial r right)\n+\nfrac1r^2 Delta_S^n-1 f","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"These imply that the restriction to the space of unit quaternions is not harmonic with respect to the Laplacian on the 3-sphere, but is an eigenfunction with eigenvalue -ell(ell+2).","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"frac1r^n-1 fracpartialpartial r left( r^n-1 fracpartial fpartial r right)\n=\nfrac1r^n-1 left( r^n-1 fracpartialpartial r fracpartial fpartial r right)\n+\nfrac1r^n-1 fracpartialpartial r left( r^n-1 right) fracpartial fpartial r\n=\nfracpartial^2 fpartial r^2\n+\nfracn-1r^n-1 r^n-2 fracpartial fpartial r\n=\nfracpartial^2 fpartial r^2\n+\nfracn-1r fracpartial fpartial r","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"fracpartial^2 fpartial r^2\n+\nfracn-1r fracpartial fpartial r\n=\nfracfr^ell fracpartial^2 r^ellpartial r^2\n+\nfracfr^ell fracn-1r fracpartial r^ellpartial r\n=\nell(ell-1) fracfr^ell r^ell-2\n+\nell fracfr^ell fracn-1r r^ell-1\n=\nell(ell-1) fracfr^2\n+\nell (n-1) fracfr^2\n=\nell(ell+n-2) fracfr^2\nto\nell(ell+2) fracfr^2","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Note that Lee [13] points out that there is a sign ambiguity in the Laplacian.  As I see it, the geometry community skews toward including a negative sign (which means that all eigenvalues are non-negative), while the physics community skews toward excluding it (which means that all eigenvalues are non-positive).  It's also easy to prove that on a closed and connected manifold, eigenfunctions with distinct eigenvalues are orthogonal, since","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"(lambda_u - lambda_v) int f_u f_v\n= int (lambda_u f_u) f_v - int f_u (lambda_v f_v)\n= int (Delta f_u) f_v - int f_u (Delta f_v) = 0","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"(the last equality by Green's theorem).  Since the eigenvalues are distinct, this can only be true if int f_u f_v=0.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Boyd and Petschek [14] produced an interesting discussion with numerous little insights into the use of special functions on different spaces.  In particular, they show why associated Legendre functions are preferred to Chebyshev polynomials for the spherical harmonics.  They also mention that since the Laplacian measures curvature, and spherical harmonics of a given degree have the same Laplacian eigenvalue, they all have the same measure of curvature. So, for example, the ell = m mode varies most rapidly with longitude but not at all with latitude, while the ell = 0 mode varies just as rapidly with latitude but not at all with longitude.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"TODO: Show the relationship between the spherical Laplacian and the angular momentum operator.\nTODO: Show how D matrices are harmonic with respect to the Laplacian on the 3-sphere.","category":"page"},{"location":"conventions/details/#Wigner's-𝔇-matrices","page":"Details","title":"Wigner's 𝔇 matrices","text":"","category":"section"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Sakurai [15] says that","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"[...] rotations affect physical systems, the state ket corresponding to a rotated system is expected to look different from the state ket corresponding to the original unrotated system. Given a rotation operation R, characterized by a 3times 3 orthogonal matrix R, we associate an operator mathscrD(R) in the appropriate ket space such thatalpharangle_R = mathscrD(R) alpharanglealpharangle_R and alpharangle stand for the kets of the rotated and original system, respectively.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"If the field is represented as a function f(𝐑), then rotating the field by e^epsilon 𝐮2 is equivalent to rotating the argument of the function by e^-epsilon 𝐮2:","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\nfleft(𝐑right)\nto\nfleft(e^-epsilon 𝐮2𝐑right) \napprox\nfleft(𝐑right) + epsilon left fracddepsilon right_epsilon=0\nfleft(e^-epsilon 𝐮2𝐑right) \n=\nfleft(𝐑right) - i epsilon L_𝐮 fleft(𝐑right)\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"This final expression is precisely equivalent to Sakurai's Eq. (3.1.15):","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"mathscrDleft(hatmathbfn dphi right)\n=\n1 - i left( mathbfJ cdot hatmathbfn right) dphi","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Now, we can write the eigenkets of L^2 and L_z as ell mrangle, where the eigenvalues are ell(ell+1) and m, respectively.  Finally, define the 𝔇 matrix as (Eq. 3.5.42)","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"𝔇^(ell)_mm(R)\n=\nlangle ell m  𝔇(R)  ell m rangle","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Sakurai notes the important result that (Eq. 3.5.46)","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"𝔇^(ell)_mm(R_1 R_2)\n=\nsum_m 𝔇^(ell)_mm(R_1) 𝔇^(ell)_mm(R_2)","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"and we can readily find the essential behavior with respect to the first and last Euler angles (Eq. 3.5.50):","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"beginaligned\n𝔇^(ell)_mm(alpha beta gamma)\n=\nlangle ell m \n    exp-iL_z alphaexp-iL_y betaexp-iL_z gamma\n ell m rangle \n=\nexp-i(m alpha+mgamma)\nlangle ell m  exp-iL_y beta  ell m rangle\nendaligned","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Using","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"L_y = (L  L)  (2i)","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"we can expand","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"exp-iL_y β\n=\nΣ_k (-iL_y β)^k  k\n=\nΣ_k (L - L)^k (β2)^k  k","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Now, writing d_+(X) = L_+ X, Eq. (9) of https://arxiv.org/pdf/1707.03861 says","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"(L - L)^k = sum_j=0^k binomk j ((L - d_+)^j 1) (-L)^k-j","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"The sum will automatically be zero unless m+k-j  ℓ — which means j  m+k-ℓ","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"(-L)^k-jℓmrangle = (-1)^k-j sqrtfrac(ell+m+k-j)(ell+m)frac(ell-m)(ell-m-k+j) ℓm+k-jrangle","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"L L = 2 L_z","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"L_z L_pm = pm L_pm","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"I wonder if there's a nicer approach using the symmetry transformation Edmonds notes in Sec. 4.5 (and credits to Wigner) — or the presumably equivalent one McEwan and Wieux use (and credit Risbo):","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"expleft beta 𝐣  2 right\n=\nexpleft pi 𝐤  4 right\nexpleft pi 𝐣  4 right\nexpleft beta 𝐤  2 right\nexpleft -pi 𝐣  4 right\nexpleft -pi 𝐤  4 right","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"The 𝔇 matrices corresponding to the 𝐤 rotations are simple phases, which converts the problem into one of finding the 𝔇 matrices for the 𝐣 rotations through angles of pmpi2 — which are presumably simpler to compute.  See, e.g., Varshalovich's Eq. 4.16.(5), where they are given by purely combinatorial terms.","category":"page"},{"location":"conventions/details/#Representation-theory-/-harmonic-analysis","page":"Details","title":"Representation theory / harmonic analysis","text":"","category":"section"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Representations show up in Fourier analysis on groups\nPeter-Weyl theorem\nGeneralizes Fourier analysis to compact groups\nHas three parts, as given by Wikipedia:\n\"The matrix coefficients of irreducible representations of G are dense in the space C(G) of continuous complex-valued functions on G, and thus also in the space L^2(G) of square-integrable functions.\"\nUnitary representations of G are completely reducible.\n\"The regular representation of G on L^2(G) decomposes as the direct sum of all irreducible unitary representations. Moreover, the matrix coefficients of the irreducible unitary representations form an orthonormal basis of L^2(G).\"\nRepresentation theory of mathbfSpin(3)\nShow how the Lie algebra is represented by the angular-momentum operators\nShow how the Lie group is represented by the Wigner D-matrices\nDemonstrate that mathfrakD is a representation\nDemonstrate its behavior under left and right rotation\nDemonstrate orthonormality\nRepresentation theory of mathbfSO(3)\nThere are several places in Folland (e.g., above corollary 5.48) where he mentions that representations of a quotient group are just representations that are trivial (evidently meaning mapping everything to the identity matrix) on the factor.  I can't find anywhere that he explains this explicitly, but it seems easy enough to show.  He might do it using characters.\nFor mathbfSpin(3) and mathbfSO(3), the factor group is just 1 -1.  Presumably, every representation acting on 1 will give the identity matrix, so that's trivial.  So we just need a criterion for when a representation is trivial on -1.  Noting that exp(pi vecv) = -1 for any vecv, I think we can show that this requires m in mathbbZ.\nBasically, the point is that the representations of mathbfSO(3) are just the integer representations of mathbfSpin(3).\nRestrict to homogeneous space (S³ -> S²)\nThe circle group is a closed (normal?) subgroup of mathbfSpin(3), which we might implement as initial multiplication about a particular axis.\nIn Eq. (2.47) Folland (2016) defines a functional taking a function on the group to a function on the homogeneous space by integrating over the factor (the circle group).  This gives you the spherical harmonics, but not the spin-weighted spherical harmonics — because the spin-weighted spherical harmonics cannot be defined on the 2-sphere.\nSpin weight comes from Fourier analysis on the subgroup.\nRepresentation matrices transfer to the homogeneous space, with sparsity patterns","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Theorem 2.16 of Hanson-Yakovlev says that an orthonormal basis of a product of L^2 spaces is given by the product of the orthonormal bases of the individual spaces. Furthermore, on page 354, they point out that (1sqrt2pi) e^imphi is an orthonormal basis of L^2(02pi), while the set 1c_nm P_n^m(costheta) is an orthonormal basis of L^2(0 pi) in the theta coordinate.  Therefore, the product of these two sets is an orthonormal basis of the product space L^2left((02pi) times (0 pi)right), which forms a coordinate space for S^2.  I would probably modify this to point out that (02pi) is really S^1, and then we could extend it to point out that you can throw on another factor of S^1 to cover S^3, which happens to give us the Wigner D-matrices.","category":"page"},{"location":"conventions/details/#Recursion-relations","page":"Details","title":"Recursion relations","text":"","category":"section"},{"location":"conventions/details/","page":"Details","title":"Details","text":"Gumerov and Duraiswami (2001) derive their recursion relations by differentiating solutions of the Helmholtz equation nabla^2 psi + k^2 psi = 0 as tfrac1k nabla psi.  More precisely, they differentiate both sides of the equation relating one solution to its rotated form — which naturally involves Wigner's mathfrakD matrix.  Using orthogonal basis functions for the solution, this allows them to equate terms on the two sides proportional to a given basis function, which leaves them with expressions involving sums of only the mathfrakD matrices and some coefficients depending on the indices of the basis functions (and hence of mathfrakD) on both sides of the equation.  Since nabla is a 3-vector operator, this gives them three relations.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"This, of course, is happening in 3-D space, since psi is a function of location in the Helmholtz equation.  It seems likely to me, however, that we could use the 4-D (quaternionic) version of the functions.  Note that G&D use partial_z and partial_x pm i partial_y as their operators to differentiate the functions — that is, the derivatives are with respect to Cartesian coordinates, which may be more similar to the right-derivative defined above.  However, I don't know that we'll necessarily be able to achieve the same results with just angular-momentum operators, since their operators do involve moving off of the sphere.  Maybe we'd need to move off of the sphere in 4-D space to get comparable results.  Or maybe just use something like 𝐫  L, which should also have 3 degrees of freedom.","category":"page"},{"location":"conventions/details/","page":"Details","title":"Details","text":"The SWSHs/mathfrakD functions can be naturally promoted to functions not just on the 3-sphere, but also in 4-D space just by allowing the quaternions to be non-unit quaternions.","category":"page"},{"location":"notes/sampling_theorems/#Sampling-theorems-and-transformations-of-spin-weighted-spherical-harmonics","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"","category":"section"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"McEwen and Wiaux [34] (MW) provide a very thorough review of the literature on sampling theorems related to spin-weighted spherical harmonics up to 2011.  Reinecke and Seljebotn [3] (RS) outlined one of the more efficient and accurate implementations of spin-weighted spherical harmonic transforms (sSHT) currently available as libsharp, but their algorithm is 4L², whereas McEwen and Wiaux's is2L², while Elahi et al. [2] (EKKM) have obtained the optimal result that scales as L².","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"The downside of the EKKM algorithm is that the θ values at which to sample have to be obtained by iteratively minimizing the condition numbers of various matrices (which are involved in the computation itself).  This expensive step only has to be performed once per choice of spin s and maximum ℓ value L.  Otherwise, the results of this algorithm seem to be relatively good — at least for L up to 64.  This does not compare favorably with the MW algorithm, which has slowly growing errors through L = 4096.","category":"page"},{"location":"notes/sampling_theorems/#EKKM-analysis","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"EKKM analysis","text":"","category":"section"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"The EKKM analysis looks like the following (with some notational changes).  We begin by defining","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  _stildef_theta(m) = int_0^2pi _sf(theta phi) e^-imphi dphi","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"We will denote the vector of these quantities for all values of theta as _stildemathbff_m.  Inserting the _sY_ellm expansion for _sf(theta phi), and performing the integration using orthogonality of complex exponentials, we can find that","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  _stildef_theta(m) = (-1)^s 2pi sum_ell=Delta^L sqrtfrac2ell+14pi d_m-s^ell(theta) _sf_ellm","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"Now, denoting the vector of _sf_ellm for all values of ell as _smathbff_m, we can write this as a matrix-vector equation:","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  _stildemathbff_m = (-1)^s 2pi _smathbfd_m _smathbff_m","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"We are effectively measuring the _stildemathbff_m values, we can easily construct the _smathbfd_m matrix, and we are seeking the _smathbff_m values, so we can just invert this equation to solve for the latter.","category":"page"},{"location":"notes/sampling_theorems/#Discretizing-the-Fourier-transform","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Discretizing the Fourier transform","text":"","category":"section"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"Now, the only flaw in this analysis is that we have undersampled everywhere except ell = L, which means that the second equation (re-expressing the Fourier transforms as a sum using orthogonality of complex exponentials) isn't quite right; in general there is some folding due to aliasing of higher-frequency modes, so we need an additional sum over mm.  Or perhaps more precisely, the first equation isn't actually what we implement.  It should look more like this:","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  _stildef_j(m) = sum_k=0^2j _sf(theta_j phi_k) e^-imphi_k Delta phi","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"where phi_k = frac2pi k2j+1, and Delta phi = frac2pi2j+1.  (Recall the subtle notational distinction common in time-frequency analysis that tildes(t_j) = Delta t tildes_j, which would suggest we use _stildef_j(m) = Delta phi _stildef_jm.)  Next, we can insert the expansion for _sf(theta phi):","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"beginaligned\n    _stildef_j(m)\n    = sum_k=0^2j sum_ellm _sf_ellm _sY_ellm(theta_j phi_k) e^-imphi_k Delta phi \n    = sum_k=0^2j sum_ellm _sf_ellm (-1)^s sqrtfrac2ell+14pi d_ell^m-s(theta_j) e^i m phi_k e^-imphi_k frac2pi2j+1 \n    = (-1)^s frac2pi2j+1 sum_ellm _sf_ellm sqrtfrac2ell+14pi d_ell^m-s(theta_j) sum_k=0^2je^i (m-m) phi_k\nendaligned","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"We can evaluate this last sum easily:","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  sum_k=0^2je^i (m-m) phi_k = begincases\n    2j+1  m-m = n(2j+1) mathrmfor ninmathbbZ \n    0  mathrmotherwise\n  endcases","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"This allows us to simplify as","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"beginaligned\n    _stildef_j(m) = (-1)^s 2pi sum_ellm _sf_ellm sqrtfrac2ell+14pi d_ell^m-s(theta_j)\nendaligned","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"where m ranges over m + n(2j+1) for all nin mathbbZ such that m + n(2j+1) leq ell — that is, all nin mathbbZ such that","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  left lceil frac-ell-m2j+1 right rceil leq n leq left lfloor fracell-m2j+1 right rfloor","category":"page"},{"location":"notes/sampling_theorems/#Matrix-representation","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Matrix representation","text":"","category":"section"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"Usually, we would take the sum over ell ranging from mathrmmax(ms) to L, and the sum over m ranging over m + n(2j+1) for all nin mathbbZ such that m + n(2j+1) leq ell. However, we can also consider these sums to range over all possible values of ell m, and just set the coefficient to zero whenever these conditions are not satisfied.  In that case, we can again think of this as a (much larger) vector-matrix equation reading","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  _stildemathbff = (-1)^s 2pi _smathbfd _smathbff","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"where the index on _stildemathbff loops over j and m, the index on _smathbff loops over ell and m, and the indices on _smathbfd loop over each of those pairs.","category":"page"},{"location":"notes/sampling_theorems/#De-aliasing","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"De-aliasing","text":"","category":"section"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"While it is far simpler to simply invert the full _smathbfd matrix, its size scales as L^4, which means that it very quickly becomes impractical to store and manipulate the full matrix.  In CMB astronomy, for example, it is not uncommon to use L into the tens of thousands, which would make the full matrix utterly impractical to use.","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"However, the matrix has a fairly sparse structure, with the number of nonzero elements scaling as L^3.  More particularly, the sparsity has a fairly special structure, where the full matrix is mostly block diagonal, along with some sparse upper triangular elements.  Of course, the goal is to solve the linear equation.  For that, the first obvious choice is an LU decomposition.  Unfortunately, the L and U components are not sparse.  A second obvious choice is the QR decomposition, which is more tailored to the structure of this matrix — the Q factor being essentially just the block diagonal, and the R factor being a somewhat less sparse upper triangle.","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"In principle, this alone could delay the impracticality threshold — though still not enough for CMB astronomy.  We can use the unusual structure to solve the linear equation in a more piecewise fashion, with fairly low memory overhead.  Essentially, we start with the highest-k values, and solve for the corresponding highest-m values.  Those harmonics will alias to other frequencies in theta_j rings with j  k.  But crucially, we know how they alias, and can simply remove them from the Fourier transforms of those rings.  We then repeat, solving for the next-highest k values, and so on.","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"The following pseudo-code summarizes the analysis algorithm, modifying the input in place:","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"# Iterate over rings, doing Fourier decompositions on each\nfor j ∈ abs(s):ℓₘₐₓ\n    fft!(ₛf[j])  # Perform in-place FFT\n    fftshift!(ₛf[j])  # Cycle order of FFT elements in place to match order of modes\n    ₛf[j] *= 2π / (2j+1)  # Change normalization\nend\n\nfor m ∈ AlternatingCountdown(ℓₘₐₓ)  # Iterate over +m, then -m, down to m=0\n    Δ = max(abs(s), abs(m))\n\n    # Gather the `m` data from each ring into a temporary workspace\n    for j ∈ Δ:ℓₘₐₓ\n        ₛfₘ[j] = ₛf[Yindex(j, m, abs(s))]\n    end\n\n    # Solve for the mode weights from the Fourier components\n    ₛf̃ₘ[Δ:ℓₘₐₓ] = ₛΛ[m] \\ ₛfₘ[Δ:ℓₘₐₓ]\n\n    # Distribute the data back into the output\n    for ℓ ∈ Δ:ℓₘₐₓ\n        ₛf[Yindex(ℓ, m, abs(s))] = ₛf̃ₘ[ℓ]\n    end\n\n    # De-alias Fourier components from rings with values of j < Δ\n    for j′ ∈ abs(s):m-1\n        m′ = mod(j′+m, 2j′+1)-j′  # `m` aliases into `(j′, m′)`\n        α = 2π * sum(\n            𝒯.ₛf̃ₘ[ℓ] * ₛλₗₘ\n            for (ℓ, ₛλₗₘ) ∈ zip(Δ:ℓₘₐₓ, λ_iterator(𝒯.θ[j′], s, m))\n        )\n        ₛf[Yindex(j′, m′, abs(s))] -= α\n    end\n\nend","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"The following pseudo-code summarizes the synthesis algorithm, modifying the input in place:","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"for m ∈ AlternatingCountup(ℓₘₐₓ)  # Iterate over +m, then -m, up from m=0\n    Δ = max(abs(s), abs(m))\n\n    # Iterate over rings, combining contributions for this `m` value\n    for j ∈ Δ:ℓₘₐₓ\n        # We will accumulate into 𝒯.ₛfₘ, and write it out at the end of the loop\n        ₛfₘ[j] = false\n\n        # Direct (non-aliased) contributions from m′ == m\n        λ = λ_iterator(𝒯.θ[j], s, m)\n        for (ℓ, ₛλₗₘ) ∈ zip(Δ:ℓₘₐₓ, λ)\n            ₛfₘ[j] += ₛf̃[Yindex(ℓ, m, abs(s))] * ₛλₗₘ\n        end\n\n        # Aliased contributions from |m′| > j > |m|\n        for ℓ′ ∈ j:ℓₘₐₓ\n            for n ∈ cld(-ℓ′-m, 2j+1):fld(ℓ′-m, 2j+1)\n                m′ = m + n*(2j+1)\n                if abs(m′) > j\n                    ₛλₗ′ₘ′ = ₛΛ[m′][j,ℓ′]\n                    𝒯.ₛfₘ[j] += ₛf̃[Yindex(ℓ′, m′, abs(s))] * ₛλₗ′ₘ′\n                end\n            end\n        end\n\n    end  # j\n\n    # Distribute the data back into the output\n    @threads for j ∈ Δ:ℓₘₐₓ\n        ₛf̃[Yindex(j, m, abs(s))] = 𝒯.ₛfₘ[j]\n    end\n\nend  # m\n\n# Iterate over rings, doing Fourier decompositions on each\nfor j ∈ abs(s):ℓₘₐₓ\n    ifftshift!(ₛf̃[j]) # Cycle order of modes in place to match order of FFT elements\n    bfft!(ₛf̃ⱼ[j]) # Perform in-place BFFT\nend","category":"page"},{"location":"notes/H_recursions/#Algorithm-for-computing-H","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"The H array, as given by Gumerov and Duraiswami [8], is related to Wigner's (small) d matrices — which is itself related to the (big) mathfrakD matrices and the various spin-weighted spherical harmonics _sY_ellm — via","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"d_ell^mm = epsilon_m epsilon_-m H_ell^mm","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"where","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"epsilon_k =\n  begincases\n    1  kleq 0 \n    (-1)^k  k  0\n  endcases","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"H has various advantages over d, including the fact that it can be efficiently and robustly valculated via recurrence relations, and the following symmetry relations:","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  H^m m_n(β) = H^m m_n(β) \n  H^m m_n(β) = H^-m -m_n(β) \n  H^m m_n(β) = (-1)^n+m+m H^-m m_n(π - β) \n  H^m m_n(β) = (-1)^m+m H^m m_n(-β)\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Because of these symmetries, we only need to evaluate at most 1/4 of all the elements.","category":"page"},{"location":"notes/H_recursions/#Steps-to-compute-H","page":"Algorithm for computing H","title":"Steps to compute H","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"The following describes various details that are not spelled out correctly by Gumerov and Duraiswami [8].  All equation numbers refer to that paper.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Because of the symmetries noted above, we only compute H^m m_n with m  m — roughly one quarter of all possible values.  Furthermore, for computations of spin-weighted spherical harmonics of weight s, we only need to compute values with m  s, which constitutes a dramatic savings when s  ℓₘₐₓ.  The data are stored in the array Hwedge.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"However, some parts of this calculation require calculating terms with m=n+1 — whereas such elements of d and mathfrakD are considered zero.  For this purpose, we need additional storage.  Rather than allocating extra space, or requiring some additional workspace to be passed in, we can actually use parts of the input H data space for temporary storage while these extra terms are needed, which is before those parts of the storage are needed.  Specifically, we need this additional storage for H^0 m_n_mathrmmax+1 with m in 0 n_mathrmmax+1, and we can use the storage destined for H^-1 m_n_mathrmmax with m in 1 n_mathrmmax.  But this leaves two more indices, which we just store as individual variables — HΩ and HΨ — representing the last and second-to-last of these additional elements stored.","category":"page"},{"location":"notes/H_recursions/#Step-1","page":"Algorithm for computing H","title":"Step 1","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Set H_0^00=1.","category":"page"},{"location":"notes/H_recursions/#Step-2","page":"Algorithm for computing H","title":"Step 2","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Compute values H^0m_n(β) for m=0ldotsn and H^0m_n+1(β) for m=0ldotsn+1.  Using Eq. (32), we see that within Gumerov and Duraiswami's conventions","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  H^0m_n(β) = (-1)^m sqrtfrac(n-m)(n+m) P^m_n(cos β) \n                 = frac1sqrtk_m (2n+1) P_nm(cos β)\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Here, k_0=1 and k_m=2 for m0, and P is defined as","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"  P_nm = sqrtfrack_m(2n+1)(n-m)(n+m) P_nm","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Note that the factor of (-1)^m in the first equation above is different from the convention used here, and is related to the Condon-Shortley phase. Note that Gumerov and Duraiswami use the notation P^m_n, whereas we are using the notation P_nm — which usually differ by a factor of (-1)^m.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"We use the \"fully normalized\" associated Legendre functions (fnALF) P because, as explained by Xing et al. [31], it is possible to compute these values very efficiently and accurately, while also delaying the onset of overflow and underflow.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"The algorithm Xing et al. describe as the best for computing P is due to Strakhov [32] via Belikov [33], and is given by them as","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  P_00 = 1 \n  P_10 = sqrt3 cos β \n  P_11 = sqrt3 sin β \n  P_n0 = a_n cos β P_n-10 - b_n fracsin β2 P_n-11 \n  P_nm =\n    c_nm cos β P_n-1m\n    - sin β left d_nm P_n-1m+1 - e_nm P_n-1m-1 right\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"where the coefficients are given by","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  a_n = sqrtfrac2n+12n-1 \n  b_n = sqrtfrac2(n-1)(2n+1)n(2n-1) \n  c_nm = frac1n sqrtfrac(n+m)(n-m)(2n+1)2n-1 \n  d_nm = frac12n sqrtfrac(n-m)(n-m-1)(2n+1)2n-1 \n  e_nm = frac12n sqrtfrac22-delta_0^m-1 sqrtfrac(n+m)(n+m-1)(2n+1)2n-1\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Now, we can directly obtain a recurrence relation for H^0m_n = P_nm  sqrtk_m (2n+1) from those expressions:","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  H^00_0 = 1 \n  H^00_1 = cos β \n  H^01_1 = sqrt12 sin β \n  H^00_n = cos β H^00_n-1 - b_n sin β H^01_n-1 \n  H^0m_n =\n    c_nm cos β H^0m_n-1\n    - sin β left d_nm H^0m+1_n-1 - e_nm H^0m-1_n-1 right\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"where the coefficients are given by","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  b_n = sqrtfracn-1n \n  c_nm = frac1n sqrt(n+m)(n-m) \n  d_nm = frac12n sqrt(n-m)(n-m-1) \n  e_nm = frac12n sqrt(n+m)(n+m-1)\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Note that the coefficients all simplified (in fact, a_n disappeared), without any increase in the complexity of the recurrence relations themselves.  Rewriting Belikov's algorithm explicitly in terms of the H^0m_n also allows us to avoid an extra normalization step.","category":"page"},{"location":"notes/H_recursions/#Step-3","page":"Algorithm for computing H","title":"Step 3","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Compute H^1m_n(β) for m=1ldotsn using relation (41).  Symmetry and shift of the indices allow this relation to be written as","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"b^0_n+1 H^1 m_n\n  = fracb^m1_n+1 (1cos β)2 H^0 m+1_n+1\n   fracb^ m1_n+1 (1+cos β)2 H^0 m1_n+1\n   a^m_n sin β H^0 m_n+1","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Here the constants are defined by","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"a^m_n = sqrtfrac(n+m+1)(n-m+1) (2n+1)(2n+3)","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"b^m_n = mathrmsgn(m) sqrtfrac(n-m-1)(n-m) (2n-1)(2n+1)","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Note that all values are assumed to be zero whenever m  n, we use mathrmsgn(0)=1 (unlike the common convention that mathrmsgn(0)=0), and we have a^m_n = a^-m_n.  Also note that these coefficients only appear in this step, and because of how they appear (specifically, because b always appears with argument n+1), we can factor out the denominators in the definitions of the constants.  We obtain this simplified formula","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"H^1 m_n\n  = -frac1sqrtn(n+1) left\n      fracbarb^m1_n+1 (1cos β)2 H^0 m+1_n+1\n      + fracbarb^ m1_n+1 (1+cos β)2 H^0 m1_n+1\n      + bara^m_n sin β H^0 m_n+1\n    right","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"with","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"bara^m_n = sqrt(n+m+1)(n-m+1)","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"barb^m_n+1 = sqrt(n-m)(n-m+1)","category":"page"},{"location":"notes/H_recursions/#Step-4","page":"Algorithm for computing H","title":"Step 4","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Recursively compute H^m+1 m_n(β) for m=1ldotsn1, m=mn using relation (50) resolved with respect to H^m+1 m_n:","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"d^m_n H^m+1 m_n\n  = d^m1_n H^m1 m_n\n   d^m1_n H^m m1_n\n  + d^m_n H^m m+1_n","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"(where the last term drops out for m=n).  The constants are defined by","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"d^m_n = fracmathrmsgn(m)2 sqrt(n-m)(n+m+1)","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Note that we can drop the factor of 12, and for this case only the sign is always +1.","category":"page"},{"location":"notes/H_recursions/#Step-5","page":"Algorithm for computing H","title":"Step 5","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Recursively compute H^m1 m_n(β) for m=0ldotsn+1, m=mldotsn using relation (50) resolved with respect to H^m1 m_n:","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"d^m1_n H^m1 m_n\n  = d^m_n H^m+1 m_n\n  + d^m1_n H^m m1_n\n   d^m_n H^m m+1_n","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"(where the last term drops out for m=n).","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"NOTE: Although Gumerov and Duraiswami specify the loop over m to start at -1, I find it necessary to start at 0, or there will be missing information. This also requires setting the H^0 -1_n components (for all n) before beginning this loop.","category":"page"},{"location":"notes/H_recursions/#Pre-computing-constants-versus-computing-on-the-fly","page":"Algorithm for computing H","title":"Pre-computing constants versus computing on the fly","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Each of the constants a^m_n, b^m_n, and c^m_n involves divisions and square-roots, which can be very costly to compute.  It can be advantageous to pre-compute the constants, and simply index the pre-computed arrays rather than re-computing them on each recursion.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"If we include the cost of computing all these constants in a single call to the H recurrence, it can be much cheaper to compute each constant as needed within the algorithm, rather than computing them all at once at the beginning of the algorithm — but only for very small computations, such as those involving n_mathrmmax  10.  Beyond this, despite the storage penalties for all those constants, it turns out to be better to pre-compute them.  However, it should be noted that the fractional cost of storing the constants is sim 3n_mathrmmax compared to just storing H itself, so this will never be a very significant amount of space.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"On the other hand, if we can pre-compute the constants just once, and store them between multiple calls to the H recurrence, then it is always advantageous to do so — typically by factors of 2 or 3 in speed.  The only difficulty here is ensuring that each call to the recurrence has access to the constants, which can be a little awkward when using multiple processes and/or threads.  However, it should be thread safe, since we only need to read those constants within the H recurrence.  All in all, I conclude that it is probably not worth the effort to maintain separate versions of the recurrence for pre-computed and on-the-fly constants.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is a Julia package for evaluating and transforming Wigner's 𝔇 matrices, and spin-weighted spherical harmonics _sY_ellm (which includes the ordinary scalar spherical harmonics).  Because both 𝔇 and the harmonics are most correctly considered functions on the rotation group 𝐒𝐎(3) — or more generally, the spin group 𝐒𝐩𝐢𝐧(3) that covers it — these functions are evaluated directly in terms of quaternions.  Concessions are also made for more standard forms of spherical coordinates and Euler angles.[1] Among other applications, those functions permit \"synthesis\" (evaluation of the spin-weighted spherical functions) of spin-weighted spherical harmonic coefficients on regular or distorted grids.  This package also includes functions enabling efficient \"analysis\" (decomposition into mode coefficients) of functions evaluated on regular grids to high order and accuracy.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"These quantities are computed using recursion relations, which makes it possible to compute to very high ℓ values.  Unlike direct evaluation of individual elements, which would generally cause overflow or underflow beyond ℓ≈30 when using double precision, these recursion relations should be valid for far higher ℓ values.  More precisely, when using this package, Inf values appear starting at ℓ=128 for Float16, but I have not yet found any for values up to at least ℓ=1024 with Float32, and presumably far higher for Float64. BigFloat also works, and presumably will not overflow for any ℓ value that could reasonably fit into computer memory — though it is far slower.  Also note that DoubleFloats will work, and achieve significantly greater accuracy (but no greater ℓ range) than Float64.  In all cases, results are typically accurate to roughly ℓ times the precision of the input quaternion.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The conventions for this package are mostly inherited from — and are described in detail by — its predecessors found here and here.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note that numerous other packages cover some of these use cases, including FastTransforms.jl, FastSphericalHarmonics.jl, WignerSymbols.jl, and WignerFamilies.jl.  However, I need support for quaternions (via Quaternionic.jl) and for higher-precision numbers — even at the cost of a very slight decrease in speed in some cases — which are what this package provides.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1]: Euler angles are quite generally a very poor choice for computing with rotations.  (The only context in which they may be preferred is when analytically integrating some analytically known functions.)  Almost universally, it is best to use quaternions when computing with rotations. All the computations done within this package use quaternions; the user interfaces involving Euler angles essentially convert to/from quaternions. While the calculations needed for those conversions would still need to be done if this package used Euler angles internally — meaning that this approach is as efficient as any — that work can be avoided entirely if you work with quaternions directly.","category":"page"}]
}
