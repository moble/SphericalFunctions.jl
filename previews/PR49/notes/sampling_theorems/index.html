<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sampling theorems and transformations of spin-weighted spherical harmonics ¬∑ SphericalFunctions.jl</title><meta name="title" content="Sampling theorems and transformations of spin-weighted spherical harmonics ¬∑ SphericalFunctions.jl"/><meta property="og:title" content="Sampling theorems and transformations of spin-weighted spherical harmonics ¬∑ SphericalFunctions.jl"/><meta property="twitter:title" content="Sampling theorems and transformations of spin-weighted spherical harmonics ¬∑ SphericalFunctions.jl"/><meta name="description" content="Documentation for SphericalFunctions.jl."/><meta property="og:description" content="Documentation for SphericalFunctions.jl."/><meta property="twitter:description" content="Documentation for SphericalFunctions.jl."/><meta property="og:url" content="https://moble.github.io/SphericalFunctions.jl/stable/notes/sampling_theorems/"/><meta property="twitter:url" content="https://moble.github.io/SphericalFunctions.jl/stable/notes/sampling_theorems/"/><link rel="canonical" href="https://moble.github.io/SphericalFunctions.jl/stable/notes/sampling_theorems/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SphericalFunctions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../transformations/"><span>$s$</span>-SHT Transformations</a></li><li><a class="tocitem" href="../../wigner_matrices/">Wigner&#39;s <span>$ùîá$</span> and <span>$d$</span> matrices</a></li><li><a class="tocitem" href="../../sYlm/"><span>${}_{s}Y_{\ell,m}$</span> functions</a></li><li><a class="tocitem" href="../../operators/">Differential operators</a></li><li><a class="tocitem" href="../../utilities/">Utilities</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../internal/">Internal functions</a></li><li><a class="tocitem" href="../../functions/">Complete function list</a></li></ul></li><li><span class="tocitem">Conventions</span><ul><li><a class="tocitem" href="../../conventions/conventions/">Conventions</a></li><li><a class="tocitem" href="../../conventions/comparisons/">Comparisons</a></li></ul></li><li><span class="tocitem">Notes</span><ul><li><a class="tocitem" href="../H_recursions/">Algorithm for computing <span>$H$</span></a></li><li class="is-active"><a class="tocitem" href>Sampling theorems and transformations of spin-weighted spherical harmonics</a><ul class="internal"><li><a class="tocitem" href="#EKKM-analysis"><span>EKKM analysis</span></a></li><li><a class="tocitem" href="#Discretizing-the-Fourier-transform"><span>Discretizing the Fourier transform</span></a></li><li><a class="tocitem" href="#Matrix-representation"><span>Matrix representation</span></a></li><li><a class="tocitem" href="#De-aliasing"><span>De-aliasing</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Notes</a></li><li class="is-active"><a href>Sampling theorems and transformations of spin-weighted spherical harmonics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sampling theorems and transformations of spin-weighted spherical harmonics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/moble/SphericalFunctions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/moble/SphericalFunctions.jl/blob/main/docs/src/notes/sampling_theorems.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Sampling-theorems-and-transformations-of-spin-weighted-spherical-harmonics"><a class="docs-heading-anchor" href="#Sampling-theorems-and-transformations-of-spin-weighted-spherical-harmonics">Sampling theorems and transformations of spin-weighted spherical harmonics</a><a id="Sampling-theorems-and-transformations-of-spin-weighted-spherical-harmonics-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-theorems-and-transformations-of-spin-weighted-spherical-harmonics" title="Permalink"></a></h1><p><a href="../../references/#McEwen_2011">McEwen and Wiaux [13]</a> (MW) provide a very thorough review of the literature on sampling theorems related to spin-weighted spherical harmonics up to 2011.  <a href="../../references/#Reinecke_2013">Reinecke and Seljebotn [3]</a> (RS) outlined one of the more efficient and accurate implementations of spin-weighted spherical harmonic transforms (<span>$s$</span>SHT) currently available as <code>libsharp</code>, but their algorithm is <span>$‚àº4L¬≤$</span>, whereas McEwen and Wiaux&#39;s is<span>$‚àº2L¬≤$</span>, while <a href="../../references/#Elahi_2018">Elahi <em>et al.</em> [2]</a> (EKKM) have obtained the optimal result that scales as <span>$‚àºL¬≤$</span>.</p><p>The downside of the EKKM algorithm is that the <span>$Œ∏$</span> values at which to sample have to be obtained by iteratively minimizing the condition numbers of various matrices (which are involved in the computation itself).  This expensive step only has to be performed once per choice of spin <span>$s$</span> and maximum <span>$‚Ñì$</span> value <span>$L$</span>.  Otherwise, the results of this algorithm seem to be relatively good ‚Äî at least for <span>$L$</span> up to 64.  This does not compare favorably with the MW algorithm, which has slowly growing errors through <span>$L = 4096$</span>.</p><h2 id="EKKM-analysis"><a class="docs-heading-anchor" href="#EKKM-analysis">EKKM analysis</a><a id="EKKM-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#EKKM-analysis" title="Permalink"></a></h2><p>The EKKM analysis looks like the following (with some notational changes).  We begin by defining</p><p class="math-container">\[  {}_{s}\tilde{f}_{\theta}(m) := \int_0^{2\pi} {}_sf(\theta, \phi)\, e^{-im\phi}\, d\phi.\]</p><p>We will denote the vector of these quantities for all values of <span>$\theta$</span> as <span>${}_{s}\tilde{\mathbf{f}}_m$</span>.  Inserting the <span>${}_sY_{\ell,m}$</span> expansion for <span>${}_sf(\theta, \phi)$</span>, and performing the integration using orthogonality of complex exponentials, we can find that</p><p class="math-container">\[  {}_{s}\tilde{f}_{\theta}(m) = (-1)^s\, 2\pi \sum_{\ell=\Delta}^L \sqrt{\frac{2\ell+1}{4\pi}}\, d_{m,-s}^{\ell}(\theta)\, {}_sf_{\ell,m}.\]</p><p>Now, denoting the vector of <span>${}_sf_{\ell,m}$</span> for all values of <span>$\ell$</span> as <span>${}_s\mathbf{f}_m$</span>, we can write this as a matrix-vector equation:</p><p class="math-container">\[  {}_{s}\tilde{\mathbf{f}}_m = (-1)^s\, 2\pi\, {}_s\mathbf{d}_{m}\, {}_s\mathbf{f}_m.\]</p><p>We are effectively measuring the <span>${}_{s}\tilde{\mathbf{f}}_m$</span> values, we can easily construct the <span>${}_s\mathbf{d}_{m}$</span> matrix, and we are seeking the <span>${}_s\mathbf{f}_m$</span> values, so we can just invert this equation to solve for the latter.</p><h2 id="Discretizing-the-Fourier-transform"><a class="docs-heading-anchor" href="#Discretizing-the-Fourier-transform">Discretizing the Fourier transform</a><a id="Discretizing-the-Fourier-transform-1"></a><a class="docs-heading-anchor-permalink" href="#Discretizing-the-Fourier-transform" title="Permalink"></a></h2><p>Now, the only flaw in this analysis is that we have undersampled everywhere except <span>$\ell = L$</span>, which means that the second equation (re-expressing the Fourier transforms as a sum using orthogonality of complex exponentials) isn&#39;t quite right; in general there is some folding due to aliasing of higher-frequency modes, so we need an additional sum over <span>$|m&#39;|&gt;|m|$</span>.  Or perhaps more precisely, the first equation isn&#39;t actually what we implement.  It should look more like this:</p><p class="math-container">\[  {}_{s}\tilde{f}_{j}(m) := \sum_{k=0}^{2j} {}_sf(\theta_j, \phi_k)\, e^{-im\phi_k}\, \Delta \phi,\]</p><p>where <span>$\phi_k = \frac{2\pi k}{2j+1}$</span>, and <span>$\Delta \phi = \frac{2\pi}{2j+1}$</span>.  (Recall the subtle notational distinction common in time-frequency analysis that <span>$\tilde{s}(t_j) = \Delta t \tilde{s}_j$</span>, which would suggest we use <span>${}_{s}\tilde{f}_{j}(m) = \Delta \phi\, {}_{s}\tilde{f}_{j,m}$</span>.)  Next, we can insert the expansion for <span>${}_sf(\theta, \phi)$</span>:</p><p class="math-container">\[\begin{aligned}
    {}_{s}\tilde{f}_{j}(m)
    &amp;= \sum_{k=0}^{2j} \sum_{\ell,m&#39;} {}_sf_{\ell,m&#39;}\, {}_sY_{\ell,m&#39;}(\theta_j, \phi_k)\, e^{-im\phi_k}\, \Delta \phi \\
    &amp;= \sum_{k=0}^{2j} \sum_{\ell,m&#39;} {}_sf_{\ell,m&#39;}\, (-1)^{s}\, \sqrt{\frac{2\ell+1}{4\pi}}\, d_{\ell}^{m&#39;,-s}(\theta_j) e^{i m&#39; \phi_k}\, e^{-im\phi_k}\, \frac{2\pi}{2j+1} \\
    &amp;= (-1)^{s}\, \frac{2\pi}{2j+1} \sum_{\ell,m&#39;} {}_sf_{\ell,m&#39;}\, \sqrt{\frac{2\ell+1}{4\pi}}\, d_{\ell}^{m&#39;,-s}(\theta_j) \sum_{k=0}^{2j}e^{i (m&#39;-m) \phi_k}.
\end{aligned}\]</p><p>We can evaluate this last sum easily:</p><p class="math-container">\[  \sum_{k=0}^{2j}e^{i (m&#39;-m) \phi_k} = \begin{cases}
    2j+1 &amp; m&#39;-m = n(2j+1)\ \mathrm{for}\ n\in\mathbb{Z}, \\
    0 &amp; \mathrm{otherwise}.
  \end{cases}\]</p><p>This allows us to simplify as</p><p class="math-container">\[\begin{aligned}
    {}_{s}\tilde{f}_{j}(m) = (-1)^{s}\, 2\pi \sum_{\ell,m&#39;} {}_sf_{\ell,m&#39;}\, \sqrt{\frac{2\ell+1}{4\pi}}\, d_{\ell}^{m&#39;,-s}(\theta_j),
\end{aligned}\]</p><p>where <span>$m&#39;$</span> ranges over <span>$m + n(2j+1)$</span> for all <span>$n\in \mathbb{Z}$</span> such that <span>$|m + n(2j+1)| \leq \ell$</span> ‚Äî¬†that is, all <span>$n\in \mathbb{Z}$</span> such that</p><p class="math-container">\[  \left \lceil \frac{-\ell-m}{2j+1} \right \rceil \leq n \leq \left \lfloor \frac{\ell-m}{2j+1} \right \rfloor.\]</p><h2 id="Matrix-representation"><a class="docs-heading-anchor" href="#Matrix-representation">Matrix representation</a><a id="Matrix-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-representation" title="Permalink"></a></h2><p>Usually, we would take the sum over <span>$\ell$</span> ranging from <span>$\mathrm{max}(|m|,|s|)$</span> to <span>$L$</span>, and the sum over <span>$m&#39;$</span> ranging over <span>$m + n(2j+1)$</span> for all <span>$n\in \mathbb{Z}$</span> such that <span>$|m + n(2j+1)| \leq \ell$</span>. However, we can also consider these sums to range over all possible values of <span>$\ell, m&#39;$</span>, and just set the coefficient to zero whenever these conditions are not satisfied.  In that case, we can again think of this as a (much larger) vector-matrix equation reading</p><p class="math-container">\[  {}_s\tilde{\mathbf{f}} = (-1)^s\, 2\pi\, {}_s\mathbf{d}\, {}_s\mathbf{f},\]</p><p>where the index on <span>${}_s\tilde{\mathbf{f}}$</span> loops over <span>$j$</span> and <span>$m$</span>, the index on <span>${}_s\mathbf{f}$</span> loops over <span>$\ell$</span> and <span>$m&#39;$</span>, and the indices on <span>${}_s\mathbf{d}$</span> loop over each of those pairs.</p><h2 id="De-aliasing"><a class="docs-heading-anchor" href="#De-aliasing">De-aliasing</a><a id="De-aliasing-1"></a><a class="docs-heading-anchor-permalink" href="#De-aliasing" title="Permalink"></a></h2><p>While it is <em>far</em> simpler to simply invert the full <span>${}_s\mathbf{d}$</span> matrix, its size scales as <span>$L^4$</span>, which means that it very quickly becomes impractical to store and manipulate the full matrix.  In CMB astronomy, for example, it is not uncommon to use <span>$L$</span> into the tens of thousands, which would make the full matrix utterly impractical to use.</p><p>However, the matrix has a fairly sparse structure, with the number of <em>nonzero</em> elements scaling as <span>$L^3$</span>.  More particularly, the sparsity has a fairly special structure, where the full matrix is mostly block diagonal, along with some sparse upper triangular elements.  Of course, the goal is to solve the linear equation.  For that, the first obvious choice is an LU decomposition.  Unfortunately, the L and U components are <em>not</em> sparse.  A second obvious choice is the QR decomposition, which is more tailored to the structure of this matrix ‚Äî the Q factor being essentially just the block diagonal, and the R factor being a somewhat less sparse upper triangle.</p><p>In principle, this alone could delay the impracticality threshold ‚Äî though still not enough for CMB astronomy.  We can use the unusual structure to solve the linear equation in a more piecewise fashion, with fairly low memory overhead.  Essentially, we start with the highest-<span>$|k|$</span> values, and solve for the corresponding highest-<span>$|m|$</span> values.  Those harmonics will alias to other frequencies in <span>$\theta_j$</span> rings with <span>$j &lt; |k|$</span>.  But crucially, we know <em>how</em> they alias, and can simply remove them from the Fourier transforms of those rings.  We then repeat, solving for the next-highest <span>$|k|$</span> values, and so on.</p><p>The following pseudo-code summarizes the analysis algorithm, modifying the input in place:</p><pre><code class="language-julia hljs"># Iterate over rings, doing Fourier decompositions on each
for j ‚àà abs(s):‚Ñì‚Çò‚Çê‚Çì
    fft!(‚Çõf[j])  # Perform in-place FFT
    fftshift!(‚Çõf[j])  # Cycle order of FFT elements in place to match order of modes
    ‚Çõf[j] *= 2œÄ / (2j+1)  # Change normalization
end

for m ‚àà AlternatingCountdown(‚Ñì‚Çò‚Çê‚Çì)  # Iterate over +m, then -m, down to m=0
    Œî = max(abs(s), abs(m))

    # Gather the `m` data from each ring into a temporary workspace
    for j ‚àà Œî:‚Ñì‚Çò‚Çê‚Çì
        ‚Çõf‚Çò[j] = ‚Çõf[Yindex(j, m, abs(s))]
    end

    # Solve for the mode weights from the Fourier components
    ‚ÇõfÃÉ‚Çò[Œî:‚Ñì‚Çò‚Çê‚Çì] = ‚ÇõŒõ[m] \ ‚Çõf‚Çò[Œî:‚Ñì‚Çò‚Çê‚Çì]

    # Distribute the data back into the output
    for ‚Ñì ‚àà Œî:‚Ñì‚Çò‚Çê‚Çì
        ‚Çõf[Yindex(‚Ñì, m, abs(s))] = ‚ÇõfÃÉ‚Çò[‚Ñì]
    end

    # De-alias Fourier components from rings with values of j &lt; Œî
    for j‚Ä≤ ‚àà abs(s):m-1
        m‚Ä≤ = mod(j‚Ä≤+m, 2j‚Ä≤+1)-j‚Ä≤  # `m` aliases into `(j‚Ä≤, m‚Ä≤)`
        Œ± = 2œÄ * sum(
            ùíØ.‚ÇõfÃÉ‚Çò[‚Ñì] * ‚ÇõŒª‚Çó‚Çò
            for (‚Ñì, ‚ÇõŒª‚Çó‚Çò) ‚àà zip(Œî:‚Ñì‚Çò‚Çê‚Çì, Œª_iterator(ùíØ.Œ∏[j‚Ä≤], s, m))
        )
        ‚Çõf[Yindex(j‚Ä≤, m‚Ä≤, abs(s))] -= Œ±
    end

end</code></pre><p>The following pseudo-code summarizes the synthesis algorithm, modifying the input in place:</p><pre><code class="language-julia hljs">for m ‚àà AlternatingCountup(‚Ñì‚Çò‚Çê‚Çì)  # Iterate over +m, then -m, up from m=0
    Œî = max(abs(s), abs(m))

    # Iterate over rings, combining contributions for this `m` value
    for j ‚àà Œî:‚Ñì‚Çò‚Çê‚Çì
        # We will accumulate into ùíØ.‚Çõf‚Çò, and write it out at the end of the loop
        ‚Çõf‚Çò[j] = false

        # Direct (non-aliased) contributions from m‚Ä≤ == m
        Œª = Œª_iterator(ùíØ.Œ∏[j], s, m)
        for (‚Ñì, ‚ÇõŒª‚Çó‚Çò) ‚àà zip(Œî:‚Ñì‚Çò‚Çê‚Çì, Œª)
            ‚Çõf‚Çò[j] += ‚ÇõfÃÉ[Yindex(‚Ñì, m, abs(s))] * ‚ÇõŒª‚Çó‚Çò
        end

        # Aliased contributions from |m‚Ä≤| &gt; j &gt; |m|
        for ‚Ñì‚Ä≤ ‚àà j:‚Ñì‚Çò‚Çê‚Çì
            for n ‚àà cld(-‚Ñì‚Ä≤-m, 2j+1):fld(‚Ñì‚Ä≤-m, 2j+1)
                m‚Ä≤ = m + n*(2j+1)
                if abs(m‚Ä≤) &gt; j
                    ‚ÇõŒª‚Çó‚Ä≤‚Çò‚Ä≤ = ‚ÇõŒõ[m‚Ä≤][j,‚Ñì‚Ä≤]
                    ùíØ.‚Çõf‚Çò[j] += ‚ÇõfÃÉ[Yindex(‚Ñì‚Ä≤, m‚Ä≤, abs(s))] * ‚ÇõŒª‚Çó‚Ä≤‚Çò‚Ä≤
                end
            end
        end

    end  # j

    # Distribute the data back into the output
    @threads for j ‚àà Œî:‚Ñì‚Çò‚Çê‚Çì
        ‚ÇõfÃÉ[Yindex(j, m, abs(s))] = ùíØ.‚Çõf‚Çò[j]
    end

end  # m

# Iterate over rings, doing Fourier decompositions on each
for j ‚àà abs(s):‚Ñì‚Çò‚Çê‚Çì
    ifftshift!(‚ÇõfÃÉ[j]) # Cycle order of modes in place to match order of FFT elements
    bfft!(‚ÇõfÃÉ‚±º[j]) # Perform in-place BFFT
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../H_recursions/">¬´ Algorithm for computing <span>$H$</span></a><a class="docs-footer-nextpage" href="../../references/">References ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 24 December 2024 05:47">Tuesday 24 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
