<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal functions ¬∑ SphericalFunctions.jl</title><meta name="title" content="Internal functions ¬∑ SphericalFunctions.jl"/><meta property="og:title" content="Internal functions ¬∑ SphericalFunctions.jl"/><meta property="twitter:title" content="Internal functions ¬∑ SphericalFunctions.jl"/><meta name="description" content="Documentation for SphericalFunctions.jl."/><meta property="og:description" content="Documentation for SphericalFunctions.jl."/><meta property="twitter:description" content="Documentation for SphericalFunctions.jl."/><meta property="og:url" content="https://moble.github.io/SphericalFunctions.jl/stable/internal/"/><meta property="twitter:url" content="https://moble.github.io/SphericalFunctions.jl/stable/internal/"/><link rel="canonical" href="https://moble.github.io/SphericalFunctions.jl/stable/internal/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../assets/extras.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SphericalFunctions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../transformations/"><span>$s$</span>-SHT Transformations</a></li><li><a class="tocitem" href="../wigner_matrices/">Wigner&#39;s <span>$ùîá$</span> and <span>$d$</span> matrices</a></li><li><a class="tocitem" href="../sYlm/"><span>${}_{s}Y_{\ell,m}$</span> functions</a></li><li><a class="tocitem" href="../operators/">Differential operators</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href>Internal functions</a><ul class="internal"><li><a class="tocitem" href="#H-recursion-and-ALFs"><span><span>$H$</span> recursion and ALFs</span></a></li><li><a class="tocitem" href="#Y,-d,-and-D"><span><span>$Y$</span>, <span>$d$</span>, and <span>$D$</span></span></a></li><li class="toplevel"><a class="tocitem" href="#Transformation"><span>Transformation</span></a></li></ul></li><li><a class="tocitem" href="../functions/">Complete function list</a></li></ul></li><li><span class="tocitem">Conventions</span><ul><li><a class="tocitem" href="../conventions/summary/">Summary</a></li><li><a class="tocitem" href="../conventions/details/">Details</a></li><li><a class="tocitem" href="../conventions/comparisons/">Comparisons</a></li><li><input class="collapse-toggle" id="menuitem-8-4" type="checkbox"/><label class="tocitem" for="menuitem-8-4"><span class="docs-label">Comparisons</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../literate_output/conventions_comparisons/condon_shortley_1935/">Condon-Shortley (1935)</a></li><li><a class="tocitem" href="../literate_output/conventions_comparisons/lalsuite_2025/">LALSuite (2025)</a></li><li><a class="tocitem" href="../literate_output/conventions_comparisons/ninja_2011/">NINJA (2011)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5" type="checkbox"/><label class="tocitem" for="menuitem-8-5"><span class="docs-label">Calculations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../literate_output/euler_angular_momentum/"><span>$L_j$</span> and <span>$R_j$</span> with Euler angles</a></li></ul></li></ul></li><li><span class="tocitem">Notes</span><ul><li><a class="tocitem" href="../notes/H_recursions/">Algorithm for computing <span>$H$</span></a></li><li><a class="tocitem" href="../notes/sampling_theorems/">Sampling theorems and transformations of spin-weighted spherical harmonics</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Internal functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internal functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/moble/SphericalFunctions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/moble/SphericalFunctions.jl/blob/main/docs/src/internal.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-functions"><a class="docs-heading-anchor" href="#Internal-functions">Internal functions</a><a id="Internal-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-functions" title="Permalink"></a></h1><p>There are various functions that are only used internally, some of which are likely to be deprecated in the near future.  These are documented here for completeness.</p><h2 id="H-recursion-and-ALFs"><a class="docs-heading-anchor" href="#H-recursion-and-ALFs"><span>$H$</span> recursion and ALFs</a><a id="H-recursion-and-ALFs-1"></a><a class="docs-heading-anchor-permalink" href="#H-recursion-and-ALFs" title="Permalink"></a></h2><p>The fundamental algorithm is the <span>$H$</span> recursion, which is the core computation needed for Wigner&#39;s <span>$d$</span> and <span>$ùîá$</span> matrices, and the spin-weighted spherical harmonics <span>${}_{s}Y_{\ell,m}$</span>, as well as <code>map2salm</code> functions.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.H!-Union{Tuple{T}, Tuple{AbstractVector, Complex{T}, Any, Any, Any}, Tuple{AbstractVector, Complex{T}, Vararg{Any, 4}}} where T&lt;:Real" href="#SphericalFunctions.H!-Union{Tuple{T}, Tuple{AbstractVector, Complex{T}, Any, Any, Any}, Tuple{AbstractVector, Complex{T}, Vararg{Any, 4}}} where T&lt;:Real"><code>SphericalFunctions.H!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">H!(H, expiŒ≤, ‚Ñì‚Çò‚Çê‚Çì, m‚Ä≤‚Çò‚Çê‚Çì, H_rec_coeffs)
H!(H, expiŒ≤, ‚Ñì‚Çò‚Çê‚Çì, m‚Ä≤‚Çò‚Çê‚Çì, H_rec_coeffs, Hindex)</code></pre><p>Compute the <span>$H$</span> matrix defined by <a href="../references/#Gumerov_2015">Gumerov and Duraiswami [8]</a>.</p><p>This computation forms the basis for computing Wigner&#39;s <span>$d$</span> and <span>$ùîá$</span> matrices via <a href="../wigner_matrices/#SphericalFunctions.d_matrices!"><code>d_matrices!</code></a> and <a href="../wigner_matrices/#SphericalFunctions.D_matrices!"><code>D_matrices!</code></a>, the spin-weighted spherical harmonics via <a href="../sYlm/#SphericalFunctions.sYlm_values!"><code>sYlm_values!</code></a>, and for transforming from values of spin-weighted spherical functions evaluated on a grid to the corresponding mode weights via <a href="#SphericalFunctions.map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, Int64, Int64, Any}} where T&lt;:Real"><code>map2salm</code></a>.</p><p>Due to symmetries, we only need to compute ~1/4 of the elements of this matrix, so only those elements with <span>$m ‚â• |m‚Ä≤|$</span> are computed.  The relevant indices of the <code>H</code> vector are computed based on the <code>Hindex</code> function ‚Äî which defaults to <code>WignerHindex</code>, but could reasonably be <code>WignerDindex</code> if the input <code>H</code> vector contains all valid indices.  However, it is assumed that the storage scheme used for <code>H</code> is such that the successive <span>$m$</span> values are located in successive elements.</p><p>If <span>$m‚Ä≤‚Çò‚Çê‚Çì &lt; ‚Ñì‚Çò‚Çê‚Çì$</span>, we don&#39;t even need 1/4 of the elements, and only values with <span>$|m‚Ä≤| ‚â§ m‚Ä≤‚Çò‚Çê‚Çì$</span> will be computed.  This is particularly useful for computing spin-weighted spherical harmonics.</p><p>Note that the recursion coefficients <code>H_rec_coeffs</code> should be the quantity returned by <a href="#SphericalFunctions.H_recursion_coefficients-Union{Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:Real"><code>H_recursion_coefficients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/3210700df4686711a7032b124d5e4bd2a4b0f952/src/Hrecursion.jl#L28-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.H_recursion_coefficients-Union{Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:Real" href="#SphericalFunctions.H_recursion_coefficients-Union{Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:Real"><code>SphericalFunctions.H_recursion_coefficients</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">H_recursion_coefficients(‚Ñì‚Çò‚Çê‚Çì, T)</code></pre><p>Pre-compute constants used in Wigner H recursion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/3210700df4686711a7032b124d5e4bd2a4b0f952/src/Hrecursion.jl#L11-L16">source</a></section></article><p>Internally, the <span>$H$</span> recursion relies on calculation of the Associated Legendre Functions (ALFs), which can also be called on their own:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.ALFcompute!-Union{Tuple{T}, Tuple{Vector{T}, Complex{T}, Int64, ALFRecursionCoefficients{T}}} where T&lt;:Real" href="#SphericalFunctions.ALFcompute!-Union{Tuple{T}, Tuple{Vector{T}, Complex{T}, Int64, ALFRecursionCoefficients{T}}} where T&lt;:Real"><code>SphericalFunctions.ALFcompute!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ALFcompute(expiŒ≤, nmax)
ALFcompute!(PÃÑ, expiŒ≤, nmax)
ALFcompute(expiŒ≤, nmax, recursion_coefficients)
ALFcompute!(PÃÑ, expiŒ≤, nmax, recursion_coefficients)</code></pre><p>Compute the &quot;fully normalized&quot; Associated Legendre Functions up to some maximum <code>n</code> value <code>nmax</code>.</p><p>These functions can take a vector PÃÑ, to store the data, stored in order of increasing <code>m</code> most rapidly varying and then increasing <code>n</code>.  If not supplied, PÃÑ will be constructed for you and returned.</p><p>The optional <code>recursion_coefficients</code> argument must be an <code>ALFRecursionCoefficients</code>, which stores various constant coefficients used in the recursion.  This object requires more than 3x the memory and more than 20x the time to compute a single PÃÑ vector without this argument, but passing it will typically speed up the calculation of each PÃÑ by a factor of 8x or so.  Thus, if you expect to compute PÃÑ more than a few times, it will take less time to pre-compute those factors, and pass them to this function.</p><p>Note that the base real type will be inferred from the (complex) type of <code>expiŒ≤</code>.  If present, the base types of <code>PÃÑ</code> and <code>recursion_coefficients</code> must agree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/3210700df4686711a7032b124d5e4bd2a4b0f952/src/associated_legendre.jl#L105-L127">source</a></section></article><p>The function <span>${}_{s}\lambda_{\ell,m}$</span> is defined as essentially <span>${}_{s}Y_{\ell,0}$</span>, and is important internally for computing the ALFs.  We have some important utilities for computing it:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.Œª_recursion_initialize" href="#SphericalFunctions.Œª_recursion_initialize"><code>SphericalFunctions.Œª_recursion_initialize</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Œª_recursion_initialize(cosŒ∏, sin¬ΩŒ∏, cos¬ΩŒ∏, s, ‚Ñì, m)</code></pre><p>This provides initial values for the recursion to find <span>${}_{s}\lambda_{\ell,m}$</span> along indices of increasing <span>$\ell$</span>, due to <a href="../references/#Kostelec_2008">Kostelec &amp; Rockmore</a> Specifically, this function computes values with <span>$\ell=m$</span>.</p><p class="math-container">\[{}_{s}\lambda_{\ell,m}(\theta)
    := {}_{s}Y_{\ell,m}(\theta, 0)
    = (-1)^m\, \sqrt{\frac{2\ell+1}{4\pi}} d^\ell_{-m,s}(\theta)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/3210700df4686711a7032b124d5e4bd2a4b0f952/src/iterators.jl#L260-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.Œª_iterator" href="#SphericalFunctions.Œª_iterator"><code>SphericalFunctions.Œª_iterator</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Œª_iterator(Œ∏, s, m)</code></pre><p>Construct an object to iterate over ‚ÇõŒª‚Çó‚Çò values.</p><p>The <span>$‚ÇõŒª‚Çó‚Çò(Œ∏)$</span> function is defined as the spin-weighted spherical harmonic evaluated at spherical coordinates <span>$(Œ∏, œï)$</span>, with <span>$œï=0$</span>.  In particular, note that it is real-valued. The return type is determined by the type of <code>Œ∏</code> (or more precisely, cos¬ΩŒ∏).</p><p>This algorithm by <a href="../references/#Kostelec_2008">Kostelec &amp; Rockmore</a> allows us to iterate over increasing <span>$‚Ñì$</span> values, for given fixed <span>$s$</span> and <span>$m$</span> values.</p><p>Note that this iteration has no inherent bound, so if you try to iterate over all values, you will end up in an infinite loop.  Instead, you can <code>zip</code> this iterator with another:</p><pre><code class="language-julia hljs">Œ∏ = 0.1
s = -2
m = 1
Œª = Œª_iterator(Œ∏, s, m)
Œî = max(abs(s), abs(m))
for (‚Ñì, ‚ÇõŒª‚Çó‚Çò) ‚àà zip(Œî:Œî+5, Œª)
    @show (‚Ñì, ‚ÇõŒª‚Çó‚Çò)
end</code></pre><p>Alternatively, you could use <code>Iterates.take(Œª, 6)</code>, for example.</p><p>Note that the iteration always begins with <code>‚Ñì = Œî = max(abs(s), abs(m))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/3210700df4686711a7032b124d5e4bd2a4b0f952/src/iterators.jl#L303-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.AlternatingCountdown" href="#SphericalFunctions.AlternatingCountdown"><code>SphericalFunctions.AlternatingCountdown</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Simple iterator to count down to 0, with alternating signs</p><pre><code class="language-julia hljs">julia&gt; collect(AlternatingCountdown(5))
11-element Vector{Int64}:
  5
 -5
  4
 -4
  3
 -3
  2
 -2
  1
 -1
  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/3210700df4686711a7032b124d5e4bd2a4b0f952/src/iterators.jl#L373-L391">source</a></section></article><h2 id="Y,-d,-and-D"><a class="docs-heading-anchor" href="#Y,-d,-and-D"><span>$Y$</span>, <span>$d$</span>, and <span>$D$</span></a><a id="Y,-d,-and-D-1"></a><a class="docs-heading-anchor-permalink" href="#Y,-d,-and-D" title="Permalink"></a></h2><p>Various <code>d</code>, <code>D</code>, and <code>sYlm</code> functions are important in the main API.  Their names and signatures have been tweaked from older versions of this package.  The only one with remaining documentation is <a href="#SphericalFunctions.‚Çõùêò"><code>‚Çõùêò</code></a>, which could probably be replaced by <a href="../sYlm/#SphericalFunctions.sYlm_values"><code>sYlm_values</code></a>, except that the default pixelization is <a href="../transformations/#SphericalFunctions.golden_ratio_spiral_rotors-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T"><code>golden_ratio_spiral_rotors</code></a>, which makes it very convenient for interacting with <a href="../transformations/#SphericalFunctions.SSHT"><code>SSHT</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.‚Çõùêò" href="#SphericalFunctions.‚Çõùêò"><code>SphericalFunctions.‚Çõùêò</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">‚Çõùêò(s, ‚Ñì‚Çò‚Çê‚Çì, [T=Float64], [RŒ∏œï=golden_ratio_spiral_rotors(s, ‚Ñì‚Çò‚Çê‚Çì, T)])</code></pre><p>Construct a matrix of <span>$‚ÇõY‚Çó‚Çò(RŒ∏œï)$</span> values for the input <code>s</code> and all nontrivial <span>$(\ell, m)$</span> up to <code>‚Ñì‚Çò‚Çê‚Çì</code>.</p><p>This is a fast and accurate method for mapping between the vector of spin-weighted spherical-harmonic mode weights <span>$‚Çõùêü‚Çó‚Çò$</span> and the vector of function values on the sphere <span>$‚Çõùêü‚±º‚Çñ$</span>, as</p><p class="math-container">\[‚Çõùêü‚±º‚Çñ = ‚Çõùêò\, ‚Çõùêü‚Çó‚Çò,\]</p><p>where the right-hand side represents the matrix-vector product.  As usual, we assume that the <span>$‚Çõùêü‚Çó‚Çò$</span> modes are ordered by increasing <span>$m ‚àà [-‚Ñì:‚Ñì]$</span>, and <span>$‚Ñì ‚àà [|s|:‚Ñì‚Çò‚Çê‚Çì]$</span>.  The ordering of the <span>$‚Çõùêü‚±º‚Çñ$</span> values will be determined by the ordering of the argument <code>RŒ∏œï</code>.</p><p>Note that the number of modes need not be the same as the number of points on which the function is evaluated, which would imply that the output matrix is not square.  To be able to invert the relationship, however, we need the number of points <span>$‚Çõùêü‚±º‚Çñ$</span> to be <em>at least as large</em> as the number of modes <span>$‚Çõùêü‚Çó‚Çò$</span>.</p><p>Note that the usefulness of this approach is limited by the fact that the size of this matrix scales as ‚Ñì‚Çò‚Çê‚Çì‚Å¥.  As such, it is mostly useful only for ‚Ñì‚Çò‚Çê‚Çì of order dozens, rather than ‚Äî say ‚Äî the tens of thousands that CMB astronomy or lensing require, for example.</p><p>Direct application and inversion of this matrix are used in the &quot;direct&quot; methods of <span>$s$</span>-SHT transformations.  See <a href="../transformations/#SphericalFunctions.SSHTDirect"><code>SSHTDirect</code></a> for details about the implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/3210700df4686711a7032b124d5e4bd2a4b0f952/src/evaluate.jl#L610-L639">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.Y" href="#SphericalFunctions.Y"><code>SphericalFunctions.Y</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Y(‚Ñì, m, Œ∏, œï)
Y(s, ‚Ñì, m, Œ∏, œï)</code></pre><p>NOTE: This function is primarily a test function just to make comparisons between this package&#39;s spherical harmonics and other references&#39; more clear.  It is inefficient, both in terms of memory and computation time, and should generally not be used in production code.</p><p>Computes a single (complex) value of the spherical harmonic <span>$(\ell, m)$</span> at the given spherical coordinate <span>$(\theta, \phi)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/3210700df4686711a7032b124d5e4bd2a4b0f952/src/evaluate.jl#L650-L660">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.d" href="#SphericalFunctions.d"><code>SphericalFunctions.d</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">d(‚Ñì, m‚Ä≤, m, Œ≤)
d(‚Ñì, m‚Ä≤, m, expiŒ≤)</code></pre><p>NOTE: This function is primarily a test function just to make comparisons between this package&#39;s Wigner <span>$d$</span> function and other references&#39; more clear.  It is inefficient, both in terms of memory and computation time, and should generally not be used in production code.</p><p>Computes a single (complex) value of the <span>$d$</span> matrix <span>$(\ell, m&#39;, m)$</span> at the given angle <span>$(\iota)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/3210700df4686711a7032b124d5e4bd2a4b0f952/src/evaluate.jl#L182-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.D" href="#SphericalFunctions.D"><code>SphericalFunctions.D</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">D(‚Ñì, m‚Ä≤, m, Œ≤)
D(‚Ñì, m‚Ä≤, m, expiŒ≤)</code></pre><p>NOTE: This function is primarily a test function just to make comparisons between this package&#39;s Wigner <span>$D$</span> function and other references&#39; more clear.  It is inefficient, both in terms of memory and computation time, and should generally not be used in production code.</p><p>Computes a single (complex) value of the <span>$D$</span> matrix <span>$(\ell, m&#39;, m)$</span> at the given angle <span>$(\iota)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/3210700df4686711a7032b124d5e4bd2a4b0f952/src/evaluate.jl#L389-L400">source</a></section></article><h1 id="Transformation"><a class="docs-heading-anchor" href="#Transformation">Transformation</a><a id="Transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Transformation" title="Permalink"></a></h1><p>The newer <a href="../transformations/#SphericalFunctions.SSHT"><code>SSHT</code></a> interface is more efficient for most purposes, but this package used to use functions named <code>map2salm</code>, which is still present, but may be deprecated.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.map2salm!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, Int64, Int64, Any}} where T&lt;:Real" href="#SphericalFunctions.map2salm!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, Int64, Int64, Any}} where T&lt;:Real"><code>SphericalFunctions.map2salm!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map2salm!(salm, map, spin, ‚Ñìmax)
map2salm!(salm, map, plan)</code></pre><p>Transform <code>map</code> values sampled on the sphere to <span>${}_sa_{\ell, m}$</span> modes in place.</p><p>For details, see <a href="#SphericalFunctions.map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, Int64, Int64, Any}} where T&lt;:Real"><code>map2salm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/3210700df4686711a7032b124d5e4bd2a4b0f952/src/map2salm.jl#L27-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, Int64, Int64, Any}} where T&lt;:Real" href="#SphericalFunctions.map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, Int64, Int64, Any}} where T&lt;:Real"><code>SphericalFunctions.map2salm</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map2salm(map, spin, ‚Ñìmax)
map2salm(map, plan)</code></pre><p>Transform <code>map</code> values sampled on the sphere to <span>${}_sa_{\ell, m}$</span> modes.</p><p>The <code>map</code> array should have size NœÜ along its first dimension and Nœë along its second; any number of dimensions may follow.  The <code>spin</code> must be entered explicitly, and <code>‚Ñìmax</code> is the highest ‚Ñì value you want in the output.</p><p>For repeated applications of this function with different values of <code>map</code>, it is more efficient to pre-compute <code>plan</code> using <a href="#SphericalFunctions.plan_map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, Int64, Int64}} where T&lt;:Real"><code>plan_map2salm</code></a>.  These functions will create a new <code>salm</code> array on each call.  To operate in place on a pre-allocated <code>salm</code> array, use <a href="#SphericalFunctions.map2salm!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, Int64, Int64, Any}} where T&lt;:Real"><code>map2salm!</code></a>.</p><p>The core of this function follows the method described by <a href="../references/#Reinecke_2013">Reinecke and Seljebotn</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/3210700df4686711a7032b124d5e4bd2a4b0f952/src/map2salm.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SphericalFunctions.plan_map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, Int64, Int64}} where T&lt;:Real" href="#SphericalFunctions.plan_map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, Int64, Int64}} where T&lt;:Real"><code>SphericalFunctions.plan_map2salm</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plan_map2salm(map, spin, ‚Ñìmax)</code></pre><p>Precompute values to use in executing <a href="#SphericalFunctions.map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, Int64, Int64, Any}} where T&lt;:Real"><code>map2salm</code></a> or <a href="#SphericalFunctions.map2salm!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, Int64, Int64, Any}} where T&lt;:Real"><code>map2salm!</code></a>.</p><p>The arguments to this function exactly mirror those of the first form of <a href="#SphericalFunctions.map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, Int64, Int64, Any}} where T&lt;:Real"><code>map2salm</code></a>, and all but the first argument in the first form of <a href="#SphericalFunctions.map2salm!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, Int64, Int64, Any}} where T&lt;:Real"><code>map2salm!</code></a>.  The <code>plan</code> returned by this function can be passed to the second forms of those functions to avoid some computation and allocation costs.</p><p>Note that the <code>plan</code> object is not thread safe; a separate <code>plan</code> should be created for each thread that will use one, or locks should be used to ensure that a single <code>plan</code> is not used at the same time on different threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/SphericalFunctions.jl/blob/3210700df4686711a7032b124d5e4bd2a4b0f952/src/map2salm.jl#L46-L61">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../utilities/">¬´ Utilities</a><a class="docs-footer-nextpage" href="../functions/">Complete function list ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Sunday 2 March 2025 19:16">Sunday 2 March 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
