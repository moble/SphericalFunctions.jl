@doc raw"""
    golden_ratio_spiral_pixels(s, â„“â‚˜â‚â‚“, [T=Float64])

Cover the sphere ð•ŠÂ² with pixels generated by the golden-ratio spiral.
Successive pixels are separated by the azimuthal angle ``Î”Ï• =
2Ï€(2-Ï†)``, and are uniformly distributed in ``\cos Î¸``.

Visually, this is a very reasonable-looking pixelization, with fairly uniform
distance between neighbors, and approximate isotropy.  No two pixels will share
the same values of either ``Î¸`` or ``Ï•``.  Also note that no point is present
on either the North or South poles.

The returned quantity is a vector of 2-SVectors providing the spherical
coordinates of each pixel.  See also [`golden_ratio_spiral_rotors`](@ref) for
the corresponding `Rotor`s.
"""
function golden_ratio_spiral_pixels(s, â„“â‚˜â‚â‚“, ::Type{T}=Float64) where T
    let Ï€ = T(Ï€), Ï† = T(MathConstants.Ï†)
        N = (â„“â‚˜â‚â‚“+1)^2 - s^2
        Î”Ï• = 2Ï€ * (2 - Ï†)
        Ï• = (0:N-1) * Î”Ï•
        cosÎ¸ = range(1, -1, length=N+1)[begin:end-1] .- 1/T(N)
        [@SVector [acos(cosÎ¸), Ï•] for (cosÎ¸, Ï•) in zip(cosÎ¸, Ï•)]
    end
end

@doc raw"""
    golden_ratio_spiral_rotors(s, â„“â‚˜â‚â‚“, [T=Float64])

Cover the sphere ð•ŠÂ² with pixels generated by the golden-ratio spiral.

See [`golden_ratio_spiral_pixels`](@ref) for more detailed explanation.  The
quantity returned by this function is a vector of `Rotor`s providing each pixel.
"""
function golden_ratio_spiral_rotors(s, â„“â‚˜â‚â‚“, ::Type{T}=Float64) where T
    from_spherical_coordinates.(golden_ratio_spiral_pixels(s, â„“â‚˜â‚â‚“, T))
end

@doc raw"""
    sorted_rings(s, â„“â‚˜â‚â‚“, [T=Float64])

Compute locations of a series of rings labelled by ``j âˆˆ |s|:â„“â‚˜â‚â‚“`` (analogous
to ``â„“``), where each ring will contain ``k = 2j+1`` (analogous to ``m``)
pixels distributed evenly around the ring.  These rings are then sorted, so
that the ring with the most pixels (``j = â„“â‚˜â‚â‚“``) is closest to the equator,
and the next-largest ring is placed just above or below the equator (depending
on the sign of ``s``), the next just below or above, and so on.  This is
generally a fairly good first guess when minimizing the condition number of
matrices used to solve for mode weights from function values.  In particular, I
use this to initialize the Minimal algorithm, which is then fed into an
optimizer to fine-tune the positions of the rings.

This function does not provide the individual pixels; it just provides the
colatitude values of the rings on which the pixels will be placed.  The pixels
themselves are provided by [`sorted_ring_pixels`](@ref).
"""
function sorted_rings(s, â„“â‚˜â‚â‚“, ::Type{T}=Float64) where T
    let Ï€o2 = prevfloat(T(Ï€)/2, s)
        sort(
            collect(LinRange(T(0), T(Ï€), 2+â„“â‚˜â‚â‚“-abs(s)+1))[begin+1:end-1],
            lt=(x,y)->(abs(x-Ï€o2)<abs(y-Ï€o2)),
            rev=true
        )
    end
end


"""
    sorted_ring_pixels(s, â„“â‚˜â‚â‚“, [T=Float64])

Cover the sphere ð•ŠÂ² with ``(â„“â‚˜â‚â‚“+1)Â²-sÂ²`` pixels distributed in rings provided
by [`sorted_rings`](@ref); see that function's documentation for more
description.

The returned quantity is a vector of 2-SVectors containing the spherical
coordinates of each pixel.  See also [`sorted_ring_rotors`](@ref) for the
corresponding `Rotor`s.
"""
function sorted_ring_pixels(s, â„“â‚˜â‚â‚“, ::Type{T}=Float64) where T
    Î¸rings = sorted_rings(s, â„“â‚˜â‚â‚“, T)
    [
        @SVector [Î¸, Ï•]
        for (j,Î¸) âˆˆ zip(abs(s):â„“â‚˜â‚â‚“, Î¸rings)
        for Ï• âˆˆ LinRange(T(0), 2T(Ï€), 2j+2)[begin:end-1]
    ]
end

"""
    sorted_ring_rotors(s, â„“â‚˜â‚â‚“, [T=Float64])

Cover the sphere ð•ŠÂ² with ``(â„“â‚˜â‚â‚“+1)Â²-sÂ²`` pixels distributed in rings provided
by [`sorted_rings`](@ref); see that function's documentation for more
description.

The returned quantity is a vector of `Rotor`s.  See also [`sorted_ring_rotors`](@ref) for
the corresponding spherical coordinates.
"""
function sorted_ring_rotors(s, â„“â‚˜â‚â‚“, ::Type{T}=Float64) where T
    from_spherical_coordinates.(sorted_ring_pixels(s, â„“â‚˜â‚â‚“, T))
end

"""
    fejer1_rings(N, [T=Float64])

Values of the colatitude coordinate (``Î¸``) appropriate for quadrature by
FejÃ©r's first rule, using weights provided by [`fejer1`](@ref).

Note that the first argument to this function is `N`, rather than the
`â„“â‚˜â‚â‚“` used in some other functions.  For spin-weighted spherical
harmonics, you may want to use `N=2â„“â‚˜â‚â‚“+1`.
"""
function fejer1_rings(N, ::Type{T}=Float64) where T
    # Eq. (12) of Reinecke and Seljebotn
    let Ï€ = T(Ï€)
        [(2n+1)*Ï€/2N for n âˆˆ 0:N-1]
    end
end

"""
    fejer2_rings(N, [T=Float64])

Values of the colatitude coordinate (``Î¸``) appropriate for quadrature by
FejÃ©r's second rule, using weights provided by [`fejer2`](@ref).

Note that the first argument to this function is `N`, rather than the
`â„“â‚˜â‚â‚“` used in some other functions.  For spin-weighted spherical
harmonics, you may want to use `N=2â„“â‚˜â‚â‚“+1`.
"""
function fejer2_rings(N, ::Type{T}=Float64) where T
    # Eq. (13) of Reinecke and Seljebotn, with N adjusted to reflect actual number of elements
    let Ï€ = T(Ï€)
        [n*Ï€/(N+1) for n âˆˆ 1:N]
    end
end

"""
    clenshaw_curtis_rings(N, [T=Float64])

Values of the colatitude coordinate (``Î¸``) appropriate for quadrature by the
Clenshaw-Curtis rule, using weights provided by [`clenshaw_curtis`](@ref).

Note that the first argument to this function is `N`, rather than the
`â„“â‚˜â‚â‚“` used in some other functions.  For spin-weighted spherical
harmonics, you may want to use `N=2â„“â‚˜â‚â‚“+1`.
"""
function clenshaw_curtis_rings(N, ::Type{T}=Float64) where T
    # Eq. (14) of Reinecke and Seljebotn, with N adjusted to reflect actual number of elements
    let Ï€ = T(Ï€)
        [n*Ï€/(N-1) for n âˆˆ 0:N-1]
    end
end
