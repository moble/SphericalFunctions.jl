@doc raw"""
    golden_ratio_spiral(s, â„“â‚˜â‚â‚“, [T=Float64])

Cover the sphere ð•ŠÂ² with pixels generated by the golden-ratio spiral.
Successive pixels are separated by the azimuthal angle ``Î”Ï• =
2Ï€(2-Ï†)``, and are uniformly distributed in ``\cos Î¸``.

Visually, this is a very reasonable-looking pixelization, with fairly uniform
distance between neighbors, and approximate isotropy.  No two pixels will share
the same values of either ``Î¸`` or ``Ï•``.  Also note that no point is present
on either the North or South poles.

The returned quantity is a vector of `Rotor`s providing each pixel.

"""
function golden_ratio_spiral(s, â„“â‚˜â‚â‚“, T=Float64)
    let Ï€ = T(Ï€), Ï† = T(MathConstants.Ï†)
        N = (â„“â‚˜â‚â‚“+1)^2 - s^2
        Î”Ï• = 2Ï€ * (2 - Ï†)
        Ï• = (0:N-1) * Î”Ï•
        cosÎ¸ = range(1, -1, length=N+1)[begin:end-1] .- 1/T(N)
        [from_spherical_coordinates(acos(cosÎ¸), Ï•) for (cosÎ¸, Ï•) in zip(cosÎ¸, Ï•)]
    end
end

@doc raw"""
    sorted_rings(s, â„“â‚˜â‚â‚“, [T=Float64])

Compute locations of a series of rings labelled by ``j âˆˆ |s|:â„“â‚˜â‚â‚“`` (analogous
to ``â„“``), where each ring will contain ``k = 2j+1`` (analogous to ``m``)
pixels distributed evenly around the ring.  These rings are then sorted, so
that the ring with the most pixels (``j = â„“â‚˜â‚â‚“``) is closest to the equator,
and the next-largest ring is placed just above or below the equator (depending
on the sign of ``s``), the next just below or above, and so on.  This is
generally a fairly good first guess when minimizing the condition number of
matrices used to solve for mode weughts from function values.  In particular, I
use this to initialize the modified EKKM algorithm, which is then fed into an
optimizer to fine-tune the positions of the rings.

This function does not provide the individual pixels; it just provides the
colatitude values of the rings on which the pixels will be placed.  The pixels
themselves are provided by [`sorted_ring_pixels`](@ref).

"""
function sorted_rings(s, â„“â‚˜â‚â‚“, T=Float64)
    let Ï€o2 = prevfloat(T(Ï€)/2, s)
        sort(
            collect(LinRange(T(0), T(Ï€), 2+â„“â‚˜â‚â‚“-abs(s)+1))[begin+1:end-1],
            lt=(x,y)->(abs(x-Ï€o2)<abs(y-Ï€o2)),
            rev=true
        )
    end
end


"""
    sorted_ring_pixels(s, â„“â‚˜â‚â‚“, [T=Float64])

Cover the sphere ð•ŠÂ² with ``(â„“â‚˜â‚â‚“+1)Â²-sÂ²`` pixels distributed in rings provided
by [`sorted_rings`](@ref); see that function's documentation for more
description.

The returned quantity is a vector of `Rotor`s providing each pixel.

"""
function sorted_ring_pixels(s, â„“â‚˜â‚â‚“, T=Float64)
    Î¸rings = sorted_rings(s, â„“â‚˜â‚â‚“, T)
    [
        from_spherical_coordinates(Î¸, Ï•)
        for (j,Î¸) âˆˆ zip(abs(s):â„“â‚˜â‚â‚“, Î¸rings)
        for Ï• âˆˆ LinRange(T(0), 2T(Ï€), 2j+2)[begin:end-1]
    ]
end

"""
    fejer1_rings(s, â„“â‚˜â‚â‚“, [T=Float64])

Values of the colatitude coordinate (``Î¸``) appropriate for quadrature by
FejÃ©r's first rule, using weights provided by [`fejer1`](@ref).
"""
function fejer1_rings(s, â„“â‚˜â‚â‚“, T=Float64)
    # Eq. (12) of Reinecke and Seljebotn
    N = 2â„“â‚˜â‚â‚“ + 1
    let Ï€ = T(Ï€)
        [(2n+1)*Ï€/2N for n âˆˆ 0:N-1]
    end
end

"""
    fejer2_rings(s, â„“â‚˜â‚â‚“, [T=Float64])

Values of the colatitude coordinate (``Î¸``) appropriate for quadrature by
FejÃ©r's second rule, using weights provided by [`fejer2`](@ref).
"""
function fejer2_rings(s, â„“â‚˜â‚â‚“, T=Float64)
    # Eq. (13) of Reinecke and Seljebotn
    N = 2â„“â‚˜â‚â‚“ + 1
    let Ï€ = T(Ï€)
        [n*Ï€/N for n âˆˆ 1:N-1]
    end
end

"""
    clenshaw_curtis_rings(s, â„“â‚˜â‚â‚“, [T=Float64])

Values of the colatitude coordinate (``Î¸``) appropriate for quadrature by the
Clenshaw-Curtis rule, using weights provided by [`clenshaw_curtis`](@ref).
"""
function clenshaw_curtis_rings(s, â„“â‚˜â‚â‚“, T=Float64)
    # Eq. (14) of Reinecke and Seljebotn
    N = 2â„“â‚˜â‚â‚“ + 1
    let Ï€ = T(Ï€)
        [n*Ï€/N for n âˆˆ 0:N]
    end
end
