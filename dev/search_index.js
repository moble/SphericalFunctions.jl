var documenterSearchIndex = {"docs":
[{"location":"operators/#Differential-operators","page":"Differential operators","title":"Differential operators","text":"","category":"section"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Spin-weighted spherical functions cannot be defined on the sphere S^2, but are well defined on the group mathrmSpin(3) cong mathrmSU(2) or the rotation group mathrmSO(3).  (See this paper for the explanation.)  However, this also allows us to define a variety of differential operators acting on these functions, relating to infinitesimal motions in these groups, acting either from the left or the right on their arguments.  Right or left matters because the groups mentioned above are all non-commutative groups.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"In general, the left Lie derivative of a function f(Q) over the unit quaternions with respect to a generator of rotation g is defined as","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_g(f)Q = frac12i left fracfleft(exp(tg) Qright)dt right_t=0","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Note that the exponential multiplies Q on the left — hence the name.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"So, for example, a rotation about the z axis has the quaternion z as its generator of rotation, and L_z defined in this way agrees with the usual angular-momentum operator L_z familiar from spherical-harmonic theory, and reduces to it when the function has spin weight 0, but also applies to functions of general spin weight.  Similarly, we can compute L_x and L_y, and take appropriate combinations to find the usual raising and lowering (ladder) operators L_+ and L_-.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"In just the same way, we can define the right Lie derivative of a function f(Q) over the unit quaternions with respect to a generator of rotation g as","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"R_g(f)Q = frac12i left fracfleft(Q exp(tg)right)dt right_t=0","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Note that the exponential multiplies Q on the right — hence the name.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"This operator is less common in physics, because it represents the dependence of the function on the choice of frame (or coordinate system), which is not usually of interest. Multiplication on the left represents a rotation of the physical system, while rotation on the right represents a rotation of the coordinate system.  However, this dependence on coordinate system is precisely what defines the spin weight of a function, so this class of operators is relevant in discussions of spin-weighted spherical functions.  In particular, the operators R_pm correspond (up to a sign) to the spin-raising and -lowering operators eth and bareth originally introduced by Newman and Penrose, as explained in greater detail in this paper.","category":"page"},{"location":"operators/#Commutators","page":"Differential operators","title":"Commutators","text":"","category":"section"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"In general, for generators a and b, we have the commutator relations","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"left L_a L_b right = -frac12i L_ab\nqquad\nleft R_a R_b right = frac12i R_ab","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"where ab is the commutator of the two generators, which can be obtained directly as the commutator of the corresponding quaternions.  Note the sign difference between these two equations.  The factors of 12i are inherited directly from the definitions of L_g and R_g given above; the sign difference could be absorbed there instead by defining those operators with opposite signs.[1]  The arbitrary sign choices used here are purely for historical reasons.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"[1]: In fact, we can define the left and right Lie derivative operators quite generally, for functions on any Lie group and for the corresponding Lie algebra.  And in all cases (at least for finite-dimensional Lie algebras) we obtain the same commutator relations. The only potential difference is that it may not make sense to use the coefficient 12i in general; it was chosen here for consistency with the standard angular-momentum operators. If that coefficient is changed in the definitions of the Lie derivatives, the only change to the commutator relations would the substitution of that coefficient.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"The raising and lowering operators relative to L_z and R_z satisfy — by definition of raising and lowering operators — the relations","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_z L_pm = pm L_pm\nqquad\nR_z R_pm = pm R_pm","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"These allow us to solve — up to an overall factor — for those operators in terms of the basic generators (again, noting the sign difference):","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_pm = L_x pm i L_y\nqquad\nR_pm = R_x mp i R_y","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"In particular, this results in the commutator relations","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_+ L_- = 2L_z\nqquad\nR_+ R_- = 2R_z","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Here, the signs are similar because the two sign differences noted above essentially cancel each other out.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"In the functions listed below, these operators are returned as matrices acting on vectors of mode weights.  As such, we can actually evaluate these commutators as given to cross-validate the expressions and those functions.","category":"page"},{"location":"operators/#Transformations-of-functions-vs.-mode-weights","page":"Differential operators","title":"Transformations of functions vs. mode weights","text":"","category":"section"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"One important point to note is that mode weights transform \"contravariantly\" (very loosely speaking) relative to the spin-weighted spherical functions under some operators.  For example, take the action of the L_+ operator, which acts on a SWSH as","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_+ left_sY_ellmright (R) = sqrt(ell-m)(ell+m+1) _sY_ellm+1(R)","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"We can use this to derive the mode weights of a general spin-weighted function f under the action of this operator:[2]","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"beginaligned\nleftL_+ fright_ellm\n=\nint leftL_+ f(R)right _sbarY_ellm(R) dR \n=\nint leftL_+ sum_ellmf_ellm _sY_ellm(R)right _sbarY_ellm(R) dR \n=\nint sum_ellm f_ellm leftL_+ _sY_ellm(R)right _sbarY_ellm(R) dR \n=\nsum_ellm f_ellm int leftL_+ _sY_ellm(R)right _sbarY_ellm(R) dR \n=\nsum_ellm f_ellm int leftsqrt(ell-m)(ell+m+1) _sY_ellm+1(R)right _sbarY_ellm(R) dR \n=\nsum_ellm f_ellm sqrt(ell-m)(ell+m+1) int _sY_ellm+1(R) _sbarY_ellm(R) dR \n=\nsum_ellm f_ellm sqrt(ell-m)(ell+m+1) delta_ellell delta_mm+1 \n=\nf_ellm-1 sqrt(ell-m+1)(ell+m)\nendaligned","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Note that this expression (and in particular its signs) more resembles the expression for L_- left_sY_ellmright than for L_+ left_sY_ellmright.  Similar relations hold for the action of L_-.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"[2]: A technical note about the integrals above: the integrals should be taken over the appropriate space and with the appropriate weight such that the SWSHs are orthonormal.  In general, this integral should be over mathrmSpin(3) and weighted by 12pi so that the result will be either 0 or 1; in general the SWSHs are not truly orthonormal when integrated over an S^2 subspace (nor even is the integral invariant). However, if we know that the spins are the same in both cases, it is possible to integrate over an S^2 subspace.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"However, it is important to note that the same \"contravariance\" is not present for the spin-raising and -lowering operators:","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"beginaligned\nlefteth fright_ellm\n=\nint lefteth f(R)right _s+1barY_ellm(R) dR \n=\nint lefteth sum_ellmf_ellm _sY_ellm(R)right _s+1barY_ellm(R) dR \n=\nsum_ellm f_ellm int lefteth _sY_ellm(R)right _s+1barY_ellm(R) dR \n=\nsum_ellm f_ellm sqrt(ell-s)(ell+s+1) int _s+1Y_ellm(R) _s+1barY_ellm(R) dR \n=\nsum_ellm f_ellm sqrt(ell-s)(ell+s+1) delta_ellell delta_mm \n=\nf_ellm sqrt(ell-s)(ell+s+1)\nendaligned","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Similarly bareth — and R_pm of course — obey this more \"covariant\" form of transformation.","category":"page"},{"location":"operators/#Module-functions","page":"Differential operators","title":"Module functions","text":"","category":"section"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Modules = [SphericalFunctions]\nPages   = [\"operators.jl\"]","category":"page"},{"location":"operators/#SphericalFunctions.Lz","page":"Differential operators","title":"SphericalFunctions.Lz","text":"Lz(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the angular-momentum operator associated with the z direction.  This is the standard L_z operator, familiar from basic physics, extended to work with SWSHs.  Note that this is the left Lie derivative; see Rz for the equivalent right Lie derivative.  See the documentation for more details.\n\nIn terms of the SWSHs, we can write the action of L_z as\n\nL_z _sY_ellm = m _sY_ellm\n\nSee also L², L₊, L₋, R², Rz, R₊, R₋, ð, ð̄.\n\n\n\n\n\n","category":"function"},{"location":"operators/#SphericalFunctions.L²","page":"Differential operators","title":"SphericalFunctions.L²","text":"L²(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the total angular-momentum operator from ℓₘᵢₙ up to ℓₘₐₓ.  If not present, ℓₘᵢₙ is assumed to be abs(s).  The argument s is ignored; it is present only for consistency with other operators, and is assumed to be 0 if not present.\n\nThis is the standard L² operator, familiar from basic physics, extended to work with SWSHs.  It is also known as the Casimir operator, and is equal to\n\nL^2 = L_x^2 + L_y^2 + L_z^2 = fracL_+L_- + L_-L_+ + 2L_zL_z2\n\nNote that these are the left Lie derivatives, but L^2 = R^2, where R is the right Lie derivative.  See the documentation for more details.\n\nIn terms of the SWSHs, we can write the action of L^2 as\n\nL^2 _sY_ellm = ell(ell+1) _sY_ellm\n\nSee also Lz, L₊, L₋, R², Rz, R₊, R₋, ð, ð̄.\n\n\n\n\n\n","category":"function"},{"location":"operators/#SphericalFunctions.L₊","page":"Differential operators","title":"SphericalFunctions.L₊","text":"L₊(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the angular-momentum raising operator.  This is the standard L_+ operator, familiar from basic physics, extended to work with SWSHs.  Note that this is the left Lie derivative; see R₊ for the equivalent right Lie derivative.  See the documentation for more details.\n\nWe define L_+ to be the raising operator for the left Lie derivative with respect to rotation about z: L_z.  By definition, this implies the commutator relation L_z L_+ = L_+, which allows us to derive L_+ = L_x + i L_y\n\nIn terms of the SWSHs, we can write the action of L_+ as\n\nL_+ _sY_ellm = sqrt(ell-m)(ell+m+1) _sY_ellm+1\n\nConsequently, the mode weights of a function are affected as\n\nleftL_+(f)right_sellm = sqrt(ell+m)(ell-m+1)leftfright_sellm-1\n\nSee also L², Lz, L₋, R², Rz, R₊, R₋, ð, ð̄.\n\n\n\n\n\n","category":"function"},{"location":"operators/#SphericalFunctions.L₋","page":"Differential operators","title":"SphericalFunctions.L₋","text":"L₋(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the angular-momentum lowering operator.  This is the standard L_- operator, familiar from basic physics, extended to work with SWSHs.  Note that this is the left Lie derivative; see R₋ for the equivalent right Lie derivative.  See the documentation for more details.\n\nWe define L_- to be the lowering operator for the left Lie derivative with respect to rotation about z: L_z.  By definition, this implies the commutator relation L_z L_- = -L_-, which allows us to derive L_- = L_x - i L_y\n\nIn terms of the SWSHs, we can write the action of L_- as\n\nL_- _sY_ellm = sqrt(ell+m)(ell-m+1) _sY_ellm-1\n\nConsequently, the mode weights of a function are affected as\n\nleftL_-(f)right_sellm = sqrt(ell-m)(ell+m+1)leftfright_sellm+1\n\nSee also L², Lz, L₊, L₋, R², Rz, R₊, R₋, ð, ð̄.\n\n\n\n\n\n","category":"function"},{"location":"operators/#SphericalFunctions.Rz","page":"Differential operators","title":"SphericalFunctions.Rz","text":"Rz(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the right angular-momentum operator associated with the z direction.\n\nThis is the R_z operator, much like the L_z operator familiar from basic physics, but in terms of the right Lie derivative, and extended to work with SWSHs.  See Lz for the equivalent left Lie derivative.  See the documentation for more details.\n\nIn terms of the SWSHs, we can write the action of R_z as\n\nR_z _sY_ellm = -s _sY_ellm\n\nNote the unfortunate sign of s, which seems to be opposite to what we expect, and arises from the choice of definition of s in the original paper by Newman and Penrose.\n\nSee also L², Lz, L₊, L₋, R², R₊, R₋, ð, ð̄.\n\n\n\n\n\n","category":"function"},{"location":"operators/#SphericalFunctions.R²","page":"Differential operators","title":"SphericalFunctions.R²","text":"R²(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the total angular-momentum operator from ℓₘᵢₙ up to ℓₘₐₓ.  If not present, ℓₘᵢₙ is assumed to be abs(s).  The argument s is ignored; it is present only for consistency with other operators, and is assumed to be 0 if not present.\n\nThis is the R^2 operator, much like the L^2 operator familiar from basic physics, but in terms of the right Lie derivative, and extended to work with SWSHs.  It is also known as the Casimir operator, and is equal to\n\nR^2 = R_x^2 + R_y^2 + R_z^2 = fracR_+R_- + R_-R_+ + 2R_zR_z2\n\nNote that these are the right Lie derivatives, but L^2 = R^2, where L is the left Lie derivative.  See the documentation for more details.\n\nIn terms of the SWSHs, we can write the action of R^2 as\n\nR^2 _sY_ellm = ell(ell+1) _sY_ellm\n\nSee also L², Lz, L₊, L₋, Rz, R₊, R₋, ð, ð̄.\n\n\n\n\n\n","category":"function"},{"location":"operators/#SphericalFunctions.R₊","page":"Differential operators","title":"SphericalFunctions.R₊","text":"R₊(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the right angular-momentum raising operator.\n\nThis is the R_+ operator, much like the L_+ operator familiar from basic physics, but in terms of the right Lie derivative, and extended to work with SWSHs.  See L₊ for the equivalent left Lie derivative.  See the documentation for more details.\n\nWe define R_+ to be the raising operator for the right Lie derivative with respect to rotation about z: R_z.  By definition, this implies the commutator relation R_z R_+ = R_+, which allows us to derive R_+ = R_x - i R_y\n\nIn terms of the SWSHs, we can write the action of R_+ as\n\nR_+ _sY_ellm = sqrt(ell+s)(ell-s+1) _s-1Y_ellm\n\nConsequently, the mode weights of a function are affected as\n\nleftR_+(f)right_sellm = sqrt(ell+s)(ell-s+1)leftfright_s-1ellm\n\nBecause of the unfortunate sign of s arising from the choice of definition of s in the original paper by Newman and Penrose, this is a lowering operator for s, though it really is a raising operator for R_z, and raises the eigenvalue of the corresponding Wigner matrix.\n\nSee also L², Lz, L₊, L₋, R², Rz, R₋, ð, ð̄.\n\n\n\n\n\n","category":"function"},{"location":"operators/#SphericalFunctions.R₋","page":"Differential operators","title":"SphericalFunctions.R₋","text":"R₋(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the right angular-momentum lowering operator.\n\nThis is the R_- operator, much like the L_- operator familiar from basic physics, but in terms of the right Lie derivative, and extended to work with SWSHs.  See L₋ for the equivalent left Lie derivative.  See the documentation for more details.\n\nWe define R_- to be the raising operator for the right Lie derivative with respect to rotation about z: R_z.  By definition, this implies the commutator relation R_z R_- = -R_-, which allows us to derive R_- = R_x + i R_y\n\nIn terms of the SWSHs, we can write the action of R_- as\n\nR_- _sY_ellm = sqrt(ell-s)(ell+s+1) _s+1Y_ellm\n\nConsequently, the mode weights of a function are affected as\n\nleftR_-(f)right_sellm = sqrt(ell-s)(ell+s+1)leftfright_s+1ellm\n\nBecause of the unfortunate sign of s arising from the choice of definition of s in the original paper by Newman and Penrose, this is a raising operator for s, though it really is a lowering operator for R_z, and lowers the eigenvalue of the corresponding Wigner matrix - though that raises the eigenvalue of the corresponding Wigner matrix.\n\nSee also L², Lz, L₊, L₋, R², Rz, R₊, ð, ð̄.\n\n\n\n\n\n","category":"function"},{"location":"operators/#SphericalFunctions.ð","page":"Differential operators","title":"SphericalFunctions.ð","text":"ð(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute coefficients for the spin-raising operator eth.\n\nThis operator was originally defined by Newman and Penrose, but is more completely defined in this paper.  It is identical to R₋.  Refer to that function's documentation for more details.\n\nBy definition, the spin-raising operator satisfies the commutator relation S eth = eth (where S is the spin operator, which just multiplies the function by its spin). In terms of the SWSHs, we can write the action of eth as\n\n    eth _sY_ellm = sqrt(ell-s)(ell+s+1) _s+1Y_ellm\n\nConsequently, the mode weights of a function are affected as\n\nlefteth fright_sellm = sqrt(ell-s)(ell+s+1)leftfright_s+1ellm\n\nSee also ð̄,  L², Lz, L₊, L₋, R², Rz, R₊.\n\n\n\n\n\n","category":"function"},{"location":"operators/#SphericalFunctions.ð̄","page":"Differential operators","title":"SphericalFunctions.ð̄","text":"ð̄(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute coefficients for the spin-lowering operator bareth.\n\nThis operator was originally defined by Newman and Penrose, but is more completely defined in this paper.  It is opposite to R₊ — meaning that bareth = -R.  Refer to that function's documentation for more details.\n\nBy definition, the spin-lowering operator satisfies the commutator relation S bareth = -bareth (where S is the spin operator, which just multiplies the function by its spin).  In terms of the SWSHs, we can write the action of bareth as\n\nbareth _sY_ellm = -sqrt(ell+s)(ell-s+1) _s-1Y_ellm\n\nConsequently, the mode weights of a function are affected as\n\nleftbareth fright_sellm\n= -sqrt(ell-s)(ell+s+1)leftfright_s+1ellm\n\nSee also ð,  L², Lz, L₊, L₋, R², Rz, R₊.\n\n\n\n\n\n","category":"function"},{"location":"notes/sampling_theorems/#Sampling-theorems-and-transformations-of-spin-weighted-spherical-harmonics","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"","category":"section"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"McEwen and Wiaux (MW) provide a very thorough review of the literature on sampling theorems related to spin-weighted spherical harmonics up to 2011. Reinecke and Seljebotn (RS) outlined one of the more efficient and accurate implementations of spin-weighted spherical harmonic transforms (sSHT) currently available as libsharp, but their algorithm is 4L², whereas McEwen and Wiaux's is2L², while Elahi, Khalid, Kennedy, and McEwen (EKKM) have obtained the optimal result that scales as L².","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"The downside of the EKKM algorithm is that the θ values at which to sample have to be obtained by iteratively minimizing the condition numbers of various matrices (which are involved in the computation itself).  This expensive step only has to be performed once per choice of spin s and maximum ℓ value L.  Otherwise, the results of this algorithm seem to be relatively good — at least for L up to 64.  This does not compare favorably with the MW algorithm, which has slowly growing errors through L = 4096.","category":"page"},{"location":"notes/sampling_theorems/#EKKM-analysis","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"EKKM analysis","text":"","category":"section"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"The EKKM analysis looks like the following (with some notational changes).  We begin by defining","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  _stildef_theta(m) = int_0^2pi _sf(theta phi) e^-imphi dphi","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"We will denote the vector of these quantities for all values of theta as _stildemathbff_m.  Inserting the _sY_ellm expansion for _sf(theta phi), and performing the integration using orthogonality of complex exponentials, we can find that","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  _stildef_theta(m) = (-1)^s 2pi sum_ell=Delta^L sqrtfrac2ell+14pi d_m-s^ell(theta) _sf_ellm","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"Now, denoting the vector of _sf_ellm for all values of ell as _smathbff_m, we can write this as a matrix-vector equation:","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  _stildemathbff_m = (-1)^s 2pi _smathbfd_m _smathbff_m","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"We are effectively measuring the _stildemathbff_m values, we can easily construct the _smathbfd_m matrix, and we are seeking the _smathbff_m values, so we can just invert this equation to solve for the latter.","category":"page"},{"location":"notes/sampling_theorems/#Discretizing-the-Fourier-transform","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Discretizing the Fourier transform","text":"","category":"section"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"Now, the only flaw in this analysis is that we have undersampled everywhere except ell = L, which means that the second equation (re-expressing the Fourier transforms as a sum using orthogonality of complex exponentials) isn't quite right; in general there is some folding due to aliasing of higher-frequency modes, so we need an additional sum over mm.  Or perhaps more precisely, the first equation isn't actually what we implement.  It should look more like this:","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  _stildef_j(m) = sum_k=0^2j _sf(theta_j phi_k) e^-imphi_k Delta phi","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"where phi_k = frac2pi k2j+1, and Delta phi = frac2pi2j+1.  (Recall the subtle notational distinction common in time-frequency analysis that tildes(t_j) = Delta t tildes_j, which would suggest we use _stildef_j(m) = Delta phi _stildef_jm.)  Next, we can insert the expansion for _sf(theta phi):","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"beginaligned\n    _stildef_j(m)\n    = sum_k=0^2j sum_ellm _sf_ellm _sY_ellm(theta_j phi_k) e^-imphi_k Delta phi \n    = sum_k=0^2j sum_ellm _sf_ellm (-1)^s sqrtfrac2ell+14pi d_ell^m-s(theta_j) e^i m phi_k e^-imphi_k frac2pi2j+1 \n    = (-1)^s frac2pi2j+1 sum_ellm _sf_ellm sqrtfrac2ell+14pi d_ell^m-s(theta_j) sum_k=0^2je^i (m-m) phi_k\nendaligned","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"We can evaluate this last sum easily:","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  sum_k=0^2je^i (m-m) phi_k = begincases\n    2j+1  m-m = n(2j+1) mathrmfor ninmathbbZ \n    0  mathrmotherwise\n  endcases","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"This allows us to simplify as","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"beginaligned\n    _stildef_j(m) = (-1)^s 2pi sum_ellm _sf_ellm sqrtfrac2ell+14pi d_ell^m-s(theta_j)\nendaligned","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"where m ranges over m + n(2j+1) for all nin mathbbZ such that m + n(2j+1) leq ell — that is, all nin mathbbZ such that","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  left lceil frac-ell-m2j+1 right rceil leq n leq left lfloor fracell-m2j+1 right rfloor","category":"page"},{"location":"notes/sampling_theorems/#Matrix-representation","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Matrix representation","text":"","category":"section"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"Usually, we would take the sum over ell ranging from mathrmmax(ms) to L, and the sum over m ranging over m + n(2j+1) for all nin mathbbZ such that m + n(2j+1) leq ell. However, we can also consider these sums to range over all possible values of ell m, and just set the coefficient to zero whenever these conditions are not satisfied.  In that case, we can again think of this as a (much larger) vector-matrix equation reading","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  _stildemathbff = (-1)^s 2pi _smathbfd _smathbff","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"where the index on _stildemathbff loops over j and m, the index on _smathbff loops over ell and m, and the indices on _smathbfd loop over each of those pairs.","category":"page"},{"location":"notes/sampling_theorems/#De-aliasing","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"De-aliasing","text":"","category":"section"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"While it is far simpler to simply invert the full _smathbfd matrix, its size scales as L^4, which means that it very quickly becomes impractical to store and manipulate the full matrix. In CMB astronomy, for example, it is not uncommon to use L into the tens of thousands, which would make the full matrix utterly impractical to use.","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"However, the matrix has a fairly sparse structure, with the number of nonzero elements scaling as L^3.  More particularly, the sparsity has a fairly special structure, where the full matrix is mostly block diagonal, along with some sparse upper triangular elements.  Of course, the goal is to solve the linear equation.  For that, the first obvious choice is an LU decomposition. Unfortunately, the L and U components are not sparse.  A second obvious choice is the QR decomposition, which is more tailored to the structure of this matrix — the Q factor being essentially just the block diagonal, and the R factor being a somewhat less sparse upper triangle.","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"In principle, this alone could delay the impracticality threshold — though still not enough for CMB astronomy.  We can use the unusual structure to solve the linear equation in a more piecewise fashion, with fairly low memory overhead.  Essentially, we start with the highest-k values, and solve for the corresponding highest-m values.  Those harmonics will alias to other frequencies in theta_j rings with j  k.  But crucially, we know how they alias, and can simply remove them from the Fourier transforms of those rings.  We then repeat, solving for the next-highest k values, and so on.","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"The following pseudo-code summarizes the analysis algorithm, modifying the input in place:","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"# Iterate over rings, doing Fourier decompositions on each\nfor j ∈ abs(s):ℓₘₐₓ\n    fft!(ₛf[j])  # Perform in-place FFT\n    fftshift!(ₛf[j])  # Cycle order of FFT elements in place to match order of modes\n    ₛf[j] *= 2π / (2j+1)  # Change normalization\nend\n\nfor m ∈ AlternatingCountdown(ℓₘₐₓ)  # Iterate over +m, then -m, down to m=0\n    Δ = max(abs(s), abs(m))\n\n    # Gather the `m` data from each ring into a temporary workspace\n    for j ∈ Δ:ℓₘₐₓ\n        ₛfₘ[j] = ₛf[Yindex(j, m, abs(s))]\n    end\n\n    # Solve for the mode weights from the Fourier components\n    ₛf̃ₘ[Δ:ℓₘₐₓ] = ₛΛ[m] \\ ₛfₘ[Δ:ℓₘₐₓ]\n\n    # Distribute the data back into the output\n    for ℓ ∈ Δ:ℓₘₐₓ\n        ₛf[Yindex(ℓ, m, abs(s))] = ₛf̃ₘ[ℓ]\n    end\n\n    # De-alias Fourier components from rings with values of j < Δ\n    for j′ ∈ abs(s):m-1\n        m′ = mod(j′+m, 2j′+1)-j′  # `m` aliases into `(j′, m′)`\n        α = 2π * sum(\n            𝒯.ₛf̃ₘ[ℓ] * ₛλₗₘ\n            for (ℓ, ₛλₗₘ) ∈ zip(Δ:ℓₘₐₓ, λiterator(𝒯.θ[j′], s, m))\n        )\n        ₛf[Yindex(j′, m′, abs(s))] -= α\n    end\n\nend","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"The following pseudo-code summarizes the synthesis algorithm, modifying the input in place:","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"for m ∈ AlternatingCountup(ℓₘₐₓ)  # Iterate over +m, then -m, up from m=0\n    Δ = max(abs(s), abs(m))\n\n    # Iterate over rings, combining contributions for this `m` value\n    for j ∈ Δ:ℓₘₐₓ\n        # We will accumulate into 𝒯.ₛfₘ, and write it out at the end of the loop\n        ₛfₘ[j] = false\n\n        # Direct (non-aliased) contributions from m′ == m\n        λ = λiterator(𝒯.θ[j], s, m)\n        for (ℓ, ₛλₗₘ) ∈ zip(Δ:ℓₘₐₓ, λ)\n            ₛfₘ[j] += ₛf̃[Yindex(ℓ, m, abs(s))] * ₛλₗₘ\n        end\n\n        # Aliased contributions from |m′| > j > |m|\n        for ℓ′ ∈ j:ℓₘₐₓ\n            for n ∈ cld(-ℓ′-m, 2j+1):fld(ℓ′-m, 2j+1)\n                m′ = m + n*(2j+1)\n                if abs(m′) > j\n                    ₛλₗ′ₘ′ = ₛΛ[m′][j,ℓ′]\n                    𝒯.ₛfₘ[j] += ₛf̃[Yindex(ℓ′, m′, abs(s))] * ₛλₗ′ₘ′\n                end\n            end\n        end\n\n    end  # j\n\n    # Distribute the data back into the output\n    @threads for j ∈ Δ:ℓₘₐₓ\n        ₛf̃[Yindex(j, m, abs(s))] = 𝒯.ₛfₘ[j]\n    end\n\nend  # m\n\n# Iterate over rings, doing Fourier decompositions on each\nfor j ∈ abs(s):ℓₘₐₓ\n    ifftshift!(ₛf̃[j]) # Cycle order of modes in place to match order of FFT elements\n    bfft!(ₛf̃ⱼ[j]) # Perform in-place BFFT\nend","category":"page"},{"location":"manual/#Function-calculators","page":"Primary functions","title":"Function calculators","text":"","category":"section"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"Typically, when calculating special functions, we will use recursion relations along with some coefficients — which frequently requires significant setup processing.  That processing can be cached, so that the calculations themselves consist primarily of memory accesses and simple arithmetic.","category":"page"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"Similarly, some computations require a certain amount of \"workspace\" — significant amounts of memory that are needed for the computation, but are not part of the core result (and don't even need to be returned).  Rather than allocating this memory on each call to the computation, we can allocate once and pass the workspace in as an argument.","category":"page"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"These two patterns — pre-computed coefficients and pre-allocated workspaces — will appear as possible call signatures in each of the following functions.  Note that we also have helper functions like Dprep, Dstorage, etc., which construct the necessary coefficients and/or workspaces, as well as the actual results for in-place computations, to make it easier to call the corresponding calculator functions.","category":"page"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"Note that these functions impose assumptions about the ordering of arrays as vectors.  For example, the series of Wigner 𝔇 matrices will be stored as a single vector.  And for particular values of (ℓ n m), the element 𝔇ˡₙₘ will have to be accessed as some linearly indexed element of that vector.  These formats, along with utility functions for accessing particular elements, are described here.","category":"page"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"The fundamental algorithm is the H recursion, which is the core computation needed for Wigner's d and 𝔇 matrices, and the spin-weighted spherical harmonics _sY_ellm, as well as map2salm functions.","category":"page"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"Modules = [SphericalFunctions]\nPages   = [\"Hrecursion.jl\"]","category":"page"},{"location":"manual/#SphericalFunctions.H!-Union{Tuple{T}, Tuple{AbstractVector, Complex{T}, Any, Any, Any}, Tuple{AbstractVector, Complex{T}, Any, Any, Any, Any}} where T<:Real","page":"Primary functions","title":"SphericalFunctions.H!","text":"H!(H, expiβ, ℓₘₐₓ, m′ₘₐₓ, H_rec_coeffs)\nH!(H, expiβ, ℓₘₐₓ, m′ₘₐₓ, H_rec_coeffs, Hindex)\n\nCompute the H matrix defined by Gumerov and Duraiswami.\n\nThis computation forms the basis for computing Wigner's d and 𝔇 matrices via d! and D!, the spin-weighted spherical harmonics via Y!, and for transforming from values of spin-weighted spherical functions evaluated on a grid to the corresponding mode weights via map2salm.\n\nDue to symmetries, we only need to compute ~1/4 of the elements of this matrix, so only those elements with m  m are computed.  The relevant indices of the H vector are computed based on the Hindex function — which defaults to WignerHindex, but could reasonably be WignerDindex if the input H vector contains all valid indices.  However, it is assumed that the storage scheme used for H is such that the successive m values are located in successive elements.\n\nIf mₘₐₓ  ℓₘₐₓ, we don't even need 1/4 of the elements, and only values with m  mₘₐₓ will be computed.  This is particularly useful for computing spin-weighted spherical harmonics.\n\nNote that the recursion coefficients H_rec_coeffs should be the quantity returned by H_recursion_coefficients.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.H_recursion_coefficients-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:Real","page":"Primary functions","title":"SphericalFunctions.H_recursion_coefficients","text":"H_recursion_coefficients(ℓₘₐₓ, T)\n\nPre-compute constants used in Wigner H recursion.\n\n\n\n\n\n","category":"method"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"Internally, the H recursion relies on calculation of the Associated Legendre Functions (ALFs), which can also be called on their own:","category":"page"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"Modules = [SphericalFunctions]\nPages   = [\"associated_legendre.jl\"]","category":"page"},{"location":"manual/#SphericalFunctions.ALFcompute!-Union{Tuple{T}, Tuple{Vector{T}, Complex{T}, Int64, ALFRecursionCoefficients{T}}} where T<:Real","page":"Primary functions","title":"SphericalFunctions.ALFcompute!","text":"ALFcompute(expiβ, nmax)\nALFcompute!(P̄, expiβ, nmax)\nALFcompute(expiβ, nmax, recursion_coefficients)\nALFcompute!(P̄, expiβ, nmax, recursion_coefficients)\n\nCompute the \"fully normalized\" Associated Legendre Functions up to some maximum n value nmax.\n\nThese functions can take a vector P̄, to store the data, stored in order of increasing m most rapidly varying and then increasing n.  If not supplied, P̄ will be constructed for you and returned.\n\nThe optional recursion_coefficients argument must be an ALFRecursionCoefficients, which stores various constant coefficients used in the recursion.  This object requires more than 3x the memory and more than 20x the time to compute a single P̄ vector without this argument, but passing it will typically speed up the calculation of each P̄ by a factor of 8x or so.  Thus, if you expect to compute P̄ more than a few times, it will take less time to pre-compute those factors, and pass them to this function.\n\nNote that the base real type will be inferred from the (complex) type of expiβ.  If present, the base types of P̄ and recursion_coefficients must agree.\n\n\n\n\n\n","category":"method"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"Based on those, we have the d!, D!, and Y! functions:","category":"page"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"Modules = [SphericalFunctions]\nPages   = [\"evaluate.jl\"]","category":"page"},{"location":"manual/#SphericalFunctions.D!-Tuple{Any, Quaternionic.AbstractQuaternion, Any, Any, Any, Any}","page":"Primary functions","title":"SphericalFunctions.D!","text":"D!(𝔇, R, ℓₘₐₓ, (aₙᵐ,bₙᵐ,dₙᵐ), expimα, expimγ)\n\nCompute Wigner's 𝔇 matrix\n\nThis function implements the preferred method of computing the 𝔇 matrix for large ell values.  In particular, above ell≈32 standard formulas become completely unusable because of numerical instabilities and overflow.  This function uses stable recursion methods instead, and should be usable beyond ell≈1000.\n\nThis function computes 𝔇ˡₘₚ,ₘ(R).  The result is returned in a 1-dimensional array ordered as\n\n[\n    𝔇(ell, mp, m, R)\n    for ell in range(ell_max+1)\n    for mp in range(-min(ℓ, mp_max), min(ℓ, mp_max)+1)\n    for m in range(-ell, ell+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.Dprep-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:Real","page":"Primary functions","title":"SphericalFunctions.Dprep","text":"Dprep(ℓₘₐₓ, T)\n\nConstruct space and pre-compute recursion coefficients to compute Wigner's 𝔇 matrix in place.\n\nThis returns the (D, H_rec_coeffs, expimα, expimγ) arguments needed by D!.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.Dstorage-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:Real","page":"Primary functions","title":"SphericalFunctions.Dstorage","text":"Dstorage(ℓₘₐₓ, T)\n\nConstruct space to compute Wigner's 𝔇 matrix in place.\n\nThis returns the D argument needed by D!.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.Y!","page":"Primary functions","title":"SphericalFunctions.Y!","text":"Y!(Y, R, ℓₘₐₓ, spin, H_rec_coeffs, Hwedge, expimϕ, ℓₘᵢₙ=0)\nY!(Y, expiθ, expiϕ, ℓₘₐₓ, spin, H_rec_coeffs, Hwedge, expimϕ, ℓₘᵢₙ=0)\nY!(Y, expiϕ, expiθ, expiγ, ℓₘₐₓ, spin, H_rec_coeffs, Hwedge, expimϕ, ℓₘᵢₙ=0)\n\nEvaluate (and write into Y, if present) the values of _sY_ell m(R) for the input value of s, for all (ell m) throughout the range specified by wigner.  R is assumed to be a unit quaternion (which may be Rotor, or simply a Quaternion).  If R does not have unit magnitude, the output elements will be too large by a factor R^ell.  If Y is not present, a new array will be created.\n\nThe spherical harmonics of spin weight s are related to Wigner's mathfrakD matrix as\n\nbeginaligned\n_sY_ell m(R)\n  = (-1)^s sqrtfrac2ell+14pi mathfrakD^(ell)_m -s(R) \n  = (-1)^s sqrtfrac2ell+14pi barmathfrakD^(ell)_-s m(barR)\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"manual/#SphericalFunctions.Yprep-Union{Tuple{T}, Tuple{Any, Any, Type{T}}, Tuple{Any, Any, Type{T}, Any}} where T<:Real","page":"Primary functions","title":"SphericalFunctions.Yprep","text":"Yprep(ℓₘₐₓ, sₘₐₓ, T, ℓₘᵢₙ)\n\nPrepare the storage, recursion coefficients, and workspace to compute ₛYₗ,ₘ data up to the maximum sizes given.\n\nReturns a tuple of Y, H_rec_coeffs, Hwedge, expimϕ, which can be passed to the correspondingly named arguments of Y!.\n\nNote that the same results of this function can be passed to Y!, even if the value of ℓₘₐₓ passed to that function is smaller than the value passed to this function, or the value of spin passed to that function is smaller (in absolute value) than the sₘₐₓ passed to this function.  However, the value of ℓₘᵢₙ passed to that function must not be smaller than the value passed to this function (unless one of the other sizes is sufficiently smaller).\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.Ystorage-Union{Tuple{T}, Tuple{Any, Type{T}}, Tuple{Any, Type{T}, Any}} where T<:Real","page":"Primary functions","title":"SphericalFunctions.Ystorage","text":"Ystorage(ℓₘₐₓ, T)\nYstorage(ℓₘₐₓ, T, ℓₘᵢₙ)\n\nConstruct space to compute the spin-weighted spherical harmonics ₛYₗₘ in place.\n\nThis returns the Y argument needed by Y!.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.d!-Tuple{Any, Complex, Any, Any}","page":"Primary functions","title":"SphericalFunctions.d!","text":"d!(d, expiβ, ℓₘₐₓ, H_rec_coeffs)\nd!(d, expiβ, ℓₘₐₓ)\nd!(d, β, ℓₘₐₓ, H_rec_coeffs)\nd!(d, β, ℓₘₐₓ)\nd(expiβ, ℓₘₐₓ)\nd(β, ℓₘₐₓ)\n\nCompute Wigner's d matrix dˡₘₚ,ₘ(β)\n\nNotes\n\nThis function is the preferred method of computing the d matrix for large ell values.  In particular, above ell≈32 standard formulas become completely unusable because of numerical instabilities and overflow.  This function uses stable recursion methods instead, and should be usable beyond ell≈1000.\n\nThe result is returned in a 1-dimensional array ordered as\n\n[\n    d(ell, mp, m, β)\n    for ell in range(ell_max+1)\n    for mp in range(-min(ℓ, mp_max), min(ℓ, mp_max)+1)\n    for m in range(-ell, ell+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.dprep-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:Real","page":"Primary functions","title":"SphericalFunctions.dprep","text":"dprep(ℓₘₐₓ, T)\n\nConstruct space and pre-compute recursion coefficients to compute Wigner's d matrix in place.\n\nThis returns the (d, H_rec_coeffs) arguments needed by d!.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.dstorage-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:Real","page":"Primary functions","title":"SphericalFunctions.dstorage","text":"dstorage(ℓₘₐₓ, T)\n\nConstruct space to compute Wigner's d matrix in place.\n\nThis returns the d argument needed by d!.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.ₛ𝐘","page":"Primary functions","title":"SphericalFunctions.ₛ𝐘","text":"ₛ𝐘(s, ℓₘₐₓ, [T=Float64], [Rθϕ=golden_ratio_spiral_rotors(s, ℓₘₐₓ, T)])\n\nConstruct a matrix of ₛYₗₘ(Rθϕ) values for the input s and all nontrivial (ell m) up to ℓₘₐₓ.\n\nThis is a fast and accurate method for mapping between the vector of spin-weighted spherical-harmonic mode weights ₛ𝐟ₗₘ and the vector of function values on the sphere ₛ𝐟ⱼₖ, as\n\nₛ𝐟ⱼₖ = ₛ𝐘 ₛ𝐟ₗₘ\n\nwhere the right-hand side represents the matrix-vector product.  As usual, we assume that the ₛ𝐟ₗₘ modes are ordered by increasing m  -ℓℓ, and ℓ  sℓₘₐₓ.  The ordering of the ₛ𝐟ⱼₖ values will be determined by the ordering of the argument Rθϕ.\n\nNote that the number of modes need not be the same as the number of points on which the function is evaluated, which would imply that the output matrix is not square.  To be able to invert the relationship, however, we need the number of points ₛ𝐟ⱼₖ to be at least as large as the number of modes ₛ𝐟ₗₘ.\n\nNote that the usefulness of this approach is limited by the fact that the size of this matrix scales as ℓₘₐₓ⁴.  As such, it is mostly useful only for ℓₘₐₓ of order dozens, rather than — say — the tens of thousands that CMB astronomy or lensing require, for example.\n\nDirect application and inversion of this matrix are used in the \"direct\" methods of s-SHT transformations.  See SSHTDirect for details about the implementation.\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"In all cases, the returned (or overwritten) data are stored linearly, as a single Vector ranging over all indices.  To access subarrays based on certain ℓ values, for example, we also have iterators that return conveniently shaped views into these linear vectors:","category":"page"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"Modules = [SphericalFunctions]\nPages   = [\"iterators.jl\"]","category":"page"},{"location":"manual/#SphericalFunctions.AlternatingCountdown","page":"Primary functions","title":"SphericalFunctions.AlternatingCountdown","text":"Simple iterator to count down to 0, with alternating signs\n\njulia> collect(AlternatingCountdown(5))\n11-element Vector{Int64}:\n  5\n -5\n  4\n -4\n  3\n -3\n  2\n -2\n  1\n -1\n  0\n\n\n\n\n\n","category":"type"},{"location":"manual/#SphericalFunctions.Diterator","page":"Primary functions","title":"SphericalFunctions.Diterator","text":"Diterator(D, ℓₘₐₓ, [ℓₘᵢₙ])\n\nConstruct an Iterator that returns sub-matrices of D, each of which consists of elements (ℓ-ℓ-ℓ) through (ℓℓℓ), for ℓ from ℓₘᵢₙ through ℓₘₐₓ.  By default, ℓₘᵢₙ is 0.\n\nNote that the returned objects are views into the original D data — meaning that you may alter their values.\n\nBecause the result is a matrix restricted to a particular ℓ value, you can index the (ℓ m m) element as [ℓ+m′+1, ℓ+m+1].  For example, you might use this as something like\n\nfor (ℓ, Dˡ) in zip(ℓₘᵢₙ:ℓₘₐₓ, Diterator(D, ℓₘₐₓ))\n    for m′ in -ℓ:ℓ\n        for m in -ℓ:ℓ\n            Dˡ[ℓ+m′+1, ℓ+m+1] = <...>\n        end\n    end\nend\n\nAlso note that no bounds checking is done, either at instantiation time or during iteration.  You are responsible for ensuring that the size of D and the values of ℓₘₐₓ and ℓₘᵢₙ make sense.\n\n\n\n\n\n","category":"type"},{"location":"manual/#SphericalFunctions.Yiterator","page":"Primary functions","title":"SphericalFunctions.Yiterator","text":"Yiterator(Y, ℓₘₐₓ, [ℓₘᵢₙ, [iₘᵢₙ]])\n\nConstruct an Iterator that returns sub-vectors of Y, each of which consists of elements (ℓ-ℓ) through (ℓℓ), for ℓ from ℓₘᵢₙ through ℓₘₐₓ.\n\nNote that the returned objects are views into the original Y data — meaning that you may alter their values.\n\nBecause the result is a vector restricted to a particular ℓ value, you can index the (ℓ m) element as [ℓ+m+1].  For example, you might use this as something like\n\nfor (ℓ, Yˡ) in zip(ℓₘᵢₙ:ℓₘₐₓ, Yiterator(Y, ℓₘₐₓ))\n    for m in -ℓ:ℓ\n        Yˡ[ℓ+m+1] = <...>\n    end\nend\n\nBy default, Y is assumed to contain all possible values, beginning with (0,0).  However, if ℓₘᵢₙ is not 0, this can be ambiguous: do we mean that Y really starts with the (0,0) element and we are just asking to begin the iteration higher?  Or do we mean that Y doesn't even contain data for lower ℓ values?  We can resolve this using iₘᵢₙ, which gives the index of ℓₘᵢₙ in Y.  By default, we assume the first case, and set iₘᵢₙ=Ysize(ℓₘᵢₙ-1)+1. However, if Y doesn't contain data below ℓₘᵢₙ, we could use iₘᵢₙ=1 to indicate the index in Y at which to find (ℓₘᵢₙ-ℓₘᵢₙ).\n\nAlso note that no bounds checking is done, either at instantiation time or during iteration.  You are responsible for ensuring that the size of Y and the values of ℓₘₐₓ, ℓₘᵢₙ, and iₘᵢₙ make sense.\n\n\n\n\n\n","category":"type"},{"location":"manual/#SphericalFunctions.diterator","page":"Primary functions","title":"SphericalFunctions.diterator","text":"diterator(d, ℓₘₐₓ, [ℓₘᵢₙ])\n\nConstruct an Iterator that returns sub-matrices of d, each of which consists of elements (ℓ-ℓ-ℓ) through (ℓℓℓ), for ℓ from ℓₘᵢₙ through ℓₘₐₓ.  By default, ℓₘᵢₙ is 0.\n\nNote that the returned objects are views into the original d data — meaning that you may alter their values.\n\nBecause the result is a matrix restricted to a particular ℓ value, you can index the (ℓ m m) element as [ℓ+m′+1, ℓ+m+1].  For example, you might use this as something like\n\nfor (ℓ, dˡ) in zip(ℓₘᵢₙ:ℓₘₐₓ, diterator(d, ℓₘₐₓ))\n    for m′ in -ℓ:ℓ\n        for m in -ℓ:ℓ\n            dˡ[ℓ+m′+1, ℓ+m+1] = <...>\n        end\n    end\nend\n\nAlso note that no bounds checking is done, either at instantiation time or during iteration.  You are responsible for ensuring that the size of d and the values of ℓₘₐₓ and ℓₘᵢₙ make sense.\n\n\n\n\n\n","category":"type"},{"location":"manual/#SphericalFunctions.λiterator","page":"Primary functions","title":"SphericalFunctions.λiterator","text":"λiterator(θ, s, m)\n\nConstruct an object to iterate over ₛλₗₘ values.\n\nThe ₛλₗₘ(θ) function is defined as the spin-weighted spherical harmonic evaluated at spherical coordinates (θ ϕ), with ϕ=0.  In particular, note that it is real-valued. The return type is determined by the type of θ (or more precisely, cos½θ).\n\nThis algorithm by Kostelec & Rockmore allows us to iterate over increasing ℓ values, for given fixed s and m values.\n\nNote that this iteration has no inherent bound, so if you try to iterate over all values, you will end up in an infinite loop.  Instead, you can zip this iterator with another:\n\nθ = 0.1\ns = -2\nm = 1\nλ = λiterator(θ, s, m)\nΔ = max(abs(s), abs(m))\nfor (ℓ, ₛλₗₘ) ∈ zip(Δ:Δ+5, λ)\n    @show (ℓ, ₛλₗₘ)\nend\n\nAlternatively, you could use Iterates.take(λ, 6), for example.\n\nNote that the iteration always begins with ℓ = Δ = max(abs(s), abs(m)).\n\n\n\n\n\n","category":"type"},{"location":"manual/#SphericalFunctions.λ_recursion_initialize-Union{Tuple{T}, Tuple{T, T, Any, Any, Any}} where T","page":"Primary functions","title":"SphericalFunctions.λ_recursion_initialize","text":"λ_recursion_initialize(cosθ, sin½θ, cos½θ, s, ℓ, m)\n\nThis provides initial values for the recursion to find _slambda_ellm along indices of increasing ell, due to Kostelec & Rockmore. Specifically, this function computes values with ell=m.\n\n_slambda_ellm(theta)\n    = _sY_ellm(theta 0)\n    = (-1)^m sqrtfrac2ell+14pi d^ell_-ms(theta)\n\n\n\n\n\n","category":"method"},{"location":"manual/#Transformation","page":"Primary functions","title":"Transformation","text":"","category":"section"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"The functions above — especially Y! — allow us to evaluate mode weights (often denoted salm) of a spin-weighted spherical-harmonic expansion as a function of a particular point (often denoted map).  This process is frequently referred to as \"synthesis\", and is also called salm2map.","category":"page"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"We can also perform the reverse process of going from the function evaluated on some kind of grid, back to the corresponding mode weights — also called \"analysis\" or map2salm.","category":"page"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"Modules = [SphericalFunctions]\nPages   = [\"map2salm.jl\"]","category":"page"},{"location":"manual/#SphericalFunctions.map2salm!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, Int64, Int64, Any}} where T<:Real","page":"Primary functions","title":"SphericalFunctions.map2salm!","text":"map2salm!(salm, map, spin, ℓmax)\nmap2salm!(salm, map, plan)\n\nTransform map values sampled on the sphere to _sa_ell m modes in place.\n\nFor details, see map2salm.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, Int64, Int64, Any}} where T<:Real","page":"Primary functions","title":"SphericalFunctions.map2salm","text":"map2salm(map, spin, ℓmax)\nmap2salm(map, plan)\n\nTransform map values sampled on the sphere to _sa_ell m modes.\n\nThe map array should have size Nφ along its first dimension and Nϑ along its second; any number of dimensions may follow.  The spin must be entered explicitly, and ℓmax is the highest ℓ value you want in the output.\n\nFor repeated applications of this function with different values of map, it is more efficient to pre-compute plan using plan_map2salm.  These functions will create a new salm array on each call.  To operate in place on a pre-allocated salm array, use map2salm!.\n\nThe core of this function follows the method described by Reinecke and Seljebotn.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.plan_map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, Int64, Int64}} where T<:Real","page":"Primary functions","title":"SphericalFunctions.plan_map2salm","text":"plan_map2salm(map, spin, ℓmax)\n\nPrecompute values to use in executing map2salm or map2salm!.\n\nThe arguments to this function exactly mirror those of the first form of map2salm, and all but the first argument in the first form of map2salm!.  The plan returned by this function can be passed to the second forms of those functions to avoid some computation and allocation costs.\n\nNote that the plan object is not thread safe; a separate plan should be created for each thread that will use one, or locks should be used to ensure that a single plan is not used at the same time on different threads.\n\n\n\n\n\n","category":"method"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"A newer interface allows simpler syntax, akin to that of FFTW.jl, whereby a transformation object 𝒯 can be used to transform between function values 𝐟 and mode weights 𝐦 as either","category":"page"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"𝐟 = 𝒯 * 𝐦","category":"page"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"or","category":"page"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"𝐦 = 𝒯 \\ 𝐟","category":"page"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"Modules = [SphericalFunctions]\nPages   = [\"ssht.jl\", \"ssht/direct.jl\", \"ssht/minimal.jl\", \"ssht/rs.jl\"]","category":"page"},{"location":"manual/#SphericalFunctions.SSHT","page":"Primary functions","title":"SphericalFunctions.SSHT","text":"Supertype of storage for spin-spherical-harmonic transforms\n\n\n\n\n\n","category":"type"},{"location":"manual/#SphericalFunctions.SSHT-Tuple{Any, Any}","page":"Primary functions","title":"SphericalFunctions.SSHT","text":"SSHT(s, ℓₘₐₓ; [method=\"Direct\"], [T=Float64], [kwargs...])\n\nConstruct an SSHT object to transform between spin-weighted spherical-harmonic mode weights and function values — performing an s-SHT.\n\nThis object behaves similarly to an AbstractFFTs.Plan object — specfically in the ability to use the semantics of algebra to perform transforms.  For example, if the function values are stored as a vector f, the mode weights as f̃, and the SSHT as 𝒯, then we can compute the function values from the mode weights as\n\nf = 𝒯 * f̃\n\nor solve for the mode weights from the function values as\n\nf̃ = 𝒯 \\ f\n\nThe first dimensions of f̃ must index the mode weights (as usual, for ℓ∈abs(m):ℓₘₐₓ and m∈-ℓ:ℓ) and the first index of f must index the locations at which the function is evaluated.  Any following dimensions will be broadcast over.  Note that certain types will broadcast using Julia threads, while others will broadcast using BLAS threads.  The relevant number of threads must be set appropriately.\n\nCertain SSHT types (currently, only Minimal and Direct) also have an option to always act in place — meaning that they simply re-use the input storage, even when used in an expression like 𝒯 \\ f.  The option must be passed as the inplace argument to the constructors, and part of the type of the resulting object.  Regardless of the value of that option, for those types where the option exists, it is also possible to use mul! and ldiv! from the LinearAlgebra package to force operation in place.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.pixels","page":"Primary functions","title":"SphericalFunctions.pixels","text":"pixels(𝒯)\n\nReturn the spherical coordinates (θ, ϕ) on which the spin-weighted spherical harmonics are evaluated.  See also rotors, which provides the actual Rotors on which they are evaluated.\n\n\n\n\n\n","category":"function"},{"location":"manual/#SphericalFunctions.rotors","page":"Primary functions","title":"SphericalFunctions.rotors","text":"rotors(𝒯)\n\nReturn the Rotors on which the spin-weighted spherical harmonics are evaluated.  See also pixels, which provides the corresponding spherical coordinates.\n\n\n\n\n\n","category":"function"},{"location":"manual/#SphericalFunctions.SSHTDirect","page":"Primary functions","title":"SphericalFunctions.SSHTDirect","text":"SSHTDirect(s, ℓₘₐₓ; decomposition=LinearAlgebra.qr, T=Float64, Rθϕ=golden_ratio_spiral_rotors(s, ℓₘₐₓ, T), inplace=true)\n\nConstruct an s-SHT object that uses the \"Direct\" method; see ₛ𝐘 for details about the method and optional arguments.  Also see SSHT for general information about how to use these objects.\n\nBy default, this uses precisely optimal sampling — meaning that the number of points on which the function is evaluated, represented by Rθϕ, is equal to the number of modes.  However, it is equally possible to evaluate on more points than there are modes.  This can be useful, for example, when processing multiple fields with different spin weights; the function could be evaluated on points appropriate for the lowest value of s, and therefore could also be used to solve for fields of all other spin weights.\n\nNote that in-place operation is possible for this type when the length of the input Rθϕ is equal to the number of modes given s and ℓₘₐₓ — and is the default behavior when possible.  See SSHT for description of in-place operation.\n\nThis method is typically better than other current implementations for ℓₘₐₓ  24, both in terms of speed and accuracy.  However, this advantage quickly falls away.  A warning will be issued if ℓₘₐₓ is greater than about 64, because this method is not likely to be the most efficient or most accurate choice.\n\n\n\n\n\n","category":"type"},{"location":"manual/#SphericalFunctions.SSHTMinimal","page":"Primary functions","title":"SphericalFunctions.SSHTMinimal","text":"Storage for Minimal spin-spherical-harmonic transform\n\nThe Minimal algorithm was described in this paper, and allows for the minimal number of function samples.\n\n\n\n\n\n","category":"type"},{"location":"manual/#SphericalFunctions.SSHTRS","page":"Primary functions","title":"SphericalFunctions.SSHTRS","text":"Storage for  spin-spherical-harmonic transform\n\nThe algorithm was described in this paper by Reinecke and Seljebotn.\n\n\n\n\n\n","category":"type"},{"location":"manual/#SphericalFunctions.SSHTRS-Tuple{Any, Any}","page":"Primary functions","title":"SphericalFunctions.SSHTRS","text":"SSHTRS(s, ℓₘₐₓ; kwargs...)\n\nConstruct a SSHTRS object directly.  This may also be achieved by calling the main SSHT function with the same keywords, along with method=\"RS\".\n\nThis object uses the algorithm described in this paper by Reinecke and Seljebotn.\n\nThe basic floating-point number type may be adjusted with the keyword argument T, which defaults to Float64.\n\nThe SSHs are evaluated on a series of \"rings\" at constant colatitude.  Their locations are specified by the θ keyword argument, which defaults to fejer1_rings(2ℓₘₐₓ+1, T).  If this is changed, the user should also provide the corresponding quadrature_weights argument — the default being fejer1(length(θ), T).\n\nOn each of these rings, an FFT is performed.  To reach the band limit of m =  ℓₘₐₓ, the number of points along each ring must therefore be at least 2ℓₘₐₓ+1, but may be greater.  For example, if 2ℓₘₐₓ+1 does not factorize neatly into a product of small primes, it may be preferable to use 2ℓₘₐₓ+2 points along each ring.  (In that case, whenever ℓₘₐₓ is 1 less than a power of 2, the number of points will be exactly a power of 2, which is usually particularly efficient.)  The number of points on each ring can be modified independently, if given as a vector with the same length as θ, or as a single number which is assumed to be the same for all rings.\n\nWhenever T is either Float64 or Float32, the keyword arguments plan_fft_flags and plan_fft_timelimit may also be useful for obtaining more efficient FFTs.  They default to FFTW.ESTIMATE and Inf, respectively.  They are passed to AbstractFFTs.plan_fft.\n\n\n\n\n\n","category":"method"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"The SSHT types use various pixelizations that may be computed as follows:","category":"page"},{"location":"manual/","page":"Primary functions","title":"Primary functions","text":"Modules = [SphericalFunctions]\nPages   = [\"pixelizations.jl\"]","category":"page"},{"location":"manual/#SphericalFunctions.clenshaw_curtis_rings","page":"Primary functions","title":"SphericalFunctions.clenshaw_curtis_rings","text":"clenshaw_curtis_rings(N, [T=Float64])\n\nValues of the colatitude coordinate (θ) appropriate for quadrature by the Clenshaw-Curtis rule, using weights provided by clenshaw_curtis.\n\nNote that the first argument to this function is N, rather than the ℓₘₐₓ used in some other functions.  For spin-weighted spherical harmonics, you may want to use N=2ℓₘₐₓ+1.\n\n\n\n\n\n","category":"function"},{"location":"manual/#SphericalFunctions.fejer1_rings","page":"Primary functions","title":"SphericalFunctions.fejer1_rings","text":"fejer1_rings(N, [T=Float64])\n\nValues of the colatitude coordinate (θ) appropriate for quadrature by Fejér's first rule, using weights provided by fejer1.\n\nNote that the first argument to this function is N, rather than the ℓₘₐₓ used in some other functions.  For spin-weighted spherical harmonics, you may want to use N=2ℓₘₐₓ+1.\n\n\n\n\n\n","category":"function"},{"location":"manual/#SphericalFunctions.fejer2_rings","page":"Primary functions","title":"SphericalFunctions.fejer2_rings","text":"fejer2_rings(N, [T=Float64])\n\nValues of the colatitude coordinate (θ) appropriate for quadrature by Fejér's second rule, using weights provided by fejer2.\n\nNote that the first argument to this function is N, rather than the ℓₘₐₓ used in some other functions.  For spin-weighted spherical harmonics, you may want to use N=2ℓₘₐₓ+1.\n\n\n\n\n\n","category":"function"},{"location":"manual/#SphericalFunctions.golden_ratio_spiral_pixels","page":"Primary functions","title":"SphericalFunctions.golden_ratio_spiral_pixels","text":"golden_ratio_spiral_pixels(s, ℓₘₐₓ, [T=Float64])\n\nCover the sphere 𝕊² with pixels generated by the golden-ratio spiral. Successive pixels are separated by the azimuthal angle Δϕ = 2π(2-φ), and are uniformly distributed in cos θ.\n\nVisually, this is a very reasonable-looking pixelization, with fairly uniform distance between neighbors, and approximate isotropy.  No two pixels will share the same values of either θ or ϕ.  Also note that no point is present on either the North or South poles.\n\nThe returned quantity is a vector of 2-SVectors providing the spherical coordinates of each pixel.  See also golden_ratio_spiral_rotors for the corresponding Rotors.\n\n\n\n\n\n","category":"function"},{"location":"manual/#SphericalFunctions.golden_ratio_spiral_rotors","page":"Primary functions","title":"SphericalFunctions.golden_ratio_spiral_rotors","text":"golden_ratio_spiral_rotors(s, ℓₘₐₓ, [T=Float64])\n\nCover the sphere 𝕊² with pixels generated by the golden-ratio spiral.\n\nSee golden_ratio_spiral_pixels for more detailed explanation.  The quantity returned by this function is a vector of Rotors providing each pixel.\n\n\n\n\n\n","category":"function"},{"location":"manual/#SphericalFunctions.sorted_ring_pixels","page":"Primary functions","title":"SphericalFunctions.sorted_ring_pixels","text":"sorted_ring_pixels(s, ℓₘₐₓ, [T=Float64])\n\nCover the sphere 𝕊² with (ℓₘₐₓ+1)²-s² pixels distributed in rings provided by sorted_rings; see that function's documentation for more description.\n\nThe returned quantity is a vector of 2-SVectors containing the spherical coordinates of each pixel.  See also sorted_ring_rotors for the corresponding Rotors.\n\n\n\n\n\n","category":"function"},{"location":"manual/#SphericalFunctions.sorted_ring_rotors","page":"Primary functions","title":"SphericalFunctions.sorted_ring_rotors","text":"sorted_ring_rotors(s, ℓₘₐₓ, [T=Float64])\n\nCover the sphere 𝕊² with (ℓₘₐₓ+1)²-s² pixels distributed in rings provided by sorted_rings; see that function's documentation for more description.\n\nThe returned quantity is a vector of Rotors.  See also sorted_ring_rotors for the corresponding spherical coordinates.\n\n\n\n\n\n","category":"function"},{"location":"manual/#SphericalFunctions.sorted_rings","page":"Primary functions","title":"SphericalFunctions.sorted_rings","text":"sorted_rings(s, ℓₘₐₓ, [T=Float64])\n\nCompute locations of a series of rings labelled by j  sℓₘₐₓ (analogous to ℓ), where each ring will contain k = 2j+1 (analogous to m) pixels distributed evenly around the ring.  These rings are then sorted, so that the ring with the most pixels (j = ℓₘₐₓ) is closest to the equator, and the next-largest ring is placed just above or below the equator (depending on the sign of s), the next just below or above, and so on.  This is generally a fairly good first guess when minimizing the condition number of matrices used to solve for mode weights from function values.  In particular, I use this to initialize the Minimal algorithm, which is then fed into an optimizer to fine-tune the positions of the rings.\n\nThis function does not provide the individual pixels; it just provides the colatitude values of the rings on which the pixels will be placed.  The pixels themselves are provided by sorted_ring_pixels.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"While not usually the star of the show, the following utilities can be quite helpful for actually using the rest of the code.","category":"page"},{"location":"utilities/#Complex-powers","page":"Utilities","title":"Complex powers","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"One common task we find when working with spherical functions is the computation of a range of integer powers of some complex number — so much so that it can be best to pre-compute the powers and cache their values.  While a naive approach is generally quite accurate, and reasonably fast, we can do a little better with a specialized routine.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"complex_powers.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#SphericalFunctions.complex_powers!-Tuple{Any, Any}","page":"Utilities","title":"SphericalFunctions.complex_powers!","text":"complex_powers!(zpowers, z)\n\nCompute integer powers of z from z^0 through z^m, recursively, where m is one less than the length of the input zpowers vector.\n\nNote that z is assumed to be normalized, with complex amplitude approximately 1.\n\nSee also: complex_powers\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.complex_powers-Tuple{Any, Int64}","page":"Utilities","title":"SphericalFunctions.complex_powers","text":"complex_powers(z, m)\n\nCompute integer powers of z from z^0 through z^m, recursively.\n\nNote that z is assumed to be normalized, with complex amplitude approximately 1.\n\nThis algorithm is mostly due to Stoer and Bulirsch in \"Introduction to Numerical Analysis\" (page 24) — with a little help from de Moivre's formula, which is essentially exp(iθ)ⁿ = exp(inθ), as well as my own alterations to deal with different behaviors in different quadrants.\n\nThere isn't usually a huge advantage to using this specialized function.  If you just need a particular power, it will generally be far more efficient and just as accurate to compute either exp(iθ)ⁿ or exp(inθ) explicitly.  However, if you need all powers from 0 to m, this function is about 10 or 5 times faster than those options, respectively, for large m.  Like those options, this function is numerically stable, in the sense that its errors are usually smaller than m times the error from machine-precision errors in the input argument — or at worst about 50% larger, which occurs as the phase approaches multiples of π/2.\n\nSee also: complex_powers!\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Quadrature-weights","page":"Utilities","title":"Quadrature weights","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"weights.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#SphericalFunctions.clenshaw_curtis-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"Utilities","title":"SphericalFunctions.clenshaw_curtis","text":"clenshaw_curtis(n, [T])\n\nCompute n weights for the Clenshaw-Curtis rule, corresponding to n evenly spaced nodes from 0 to π inclusive.  That is, the nodes are located at\n\ntheta_k = k fracpin-1 quad k=0 ldots n-1\n\nThis function uses Waldvogel's method.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.fejer1-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"Utilities","title":"SphericalFunctions.fejer1","text":"fejer1(n, [T])\n\nCompute n weights for Fejér's first rule, corresponding to n evenly spaced nodes from 0 to π inclusive.  That is, the nodes are located at\n\ntheta_k = k fracpin-1 quad k=0 ldots n-1\n\nThis function uses Waldvogel's method.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.fejer2-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"Utilities","title":"SphericalFunctions.fejer2","text":"fejer2(n, [T])\n\nCompute n weights for Fejér's second rule, corresponding to n evenly spaced nodes between 0 and π exclusive.  That is, the nodes are located at\n\ntheta_k = k fracpin+1 quad k=1 ldots n\n\nThis function uses Waldvogel's method.  However, contrary to Waldvogel's notation, this routine does not include the weight corresponding to the ϑ=0 or π nodes, which both have weight 0.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Y-and-D-data","page":"Utilities","title":"Y and D data","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"By Y data, we mean anything indexed like Y_ell m modes; by D data, we mean anything indexed like Wigner's mathfrakD matrices, or special subsets of them, like the H matrices.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"indexing.jl\", \"wigner_matrices/indexing.jl\", \"wigner_matrices/Hrecursions.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#SphericalFunctions.WignerDindex","page":"Utilities","title":"SphericalFunctions.WignerDindex","text":"WignerDindex(ℓ, m′, m, m′ₘₐₓ=ℓ)\n\nCompute index into Wigner 𝔇 matrix\n\nSee also WignerDrange and WignerDsize.\n\nNotes\n\nThis assumes that the Wigner 𝔇 matrix is arranged as\n\n[\n    𝔇(ℓ, m′, m)\n    for ℓ in range(ℓₘᵢₙ, ℓₘₐₓ+1)\n    for m′ in range(-min(ℓ, m′ₘₐₓ), min(ℓ, m′ₘₐₓ)+1)\n    for m in range(-ℓ, ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerDrange","page":"Utilities","title":"SphericalFunctions.WignerDrange","text":"WignerDrange(ℓₘₐₓ, m′ₘₐₓ=ℓₘₐₓ)\n\nCreate an array of (ℓ, m', m) indices as in 𝔇 array\n\nSee also WignerDsize and WignerDindex.\n\nNotes\n\nThis assumes that the Wigner 𝔇 matrix is arranged as\n\n[\n    𝔇(ℓ, m′, m)\n    for ℓ in range(ℓₘᵢₙ, ℓₘₐₓ+1)\n    for m′ in range(-min(ℓ, m′ₘₐₓ), min(ℓ, m′ₘₐₓ)+1)\n    for m in range(-ℓ, ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerDsize-Tuple{Any}","page":"Utilities","title":"SphericalFunctions.WignerDsize","text":"WignerDsize(ℓₘₐₓ, m′ₘₐₓ=ℓₘₐₓ)\n\nCompute total size of Wigner 𝔇 matrix\n\nSee also WignerDrange and WignerDindex.\n\nNotes\n\nThis assumes that the Wigner 𝔇 matrix is arranged as\n\n[\n    𝔇(ℓ, m′, m)\n    for ℓ in ℓₘᵢₙ:ℓₘₐₓ\n    for m′ in -min(ℓ, m′ₘₐₓ):min(ℓ, m′ₘₐₓ)\n    for m in -ℓ:ℓ\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.WignerHindex","page":"Utilities","title":"SphericalFunctions.WignerHindex","text":"WignerHindex(ℓ, m′, m, m′ₘₐₓ)\n\nIndex to \"wedge\" arrays\n\nSee also WignerHsize and WignerHrange.\n\nNotes\n\nHere, it is assumed that only data with m≥|m'| are stored, and only corresponding values are passed.  We also assume |m|≤ℓ and |m'|≤ℓ.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(ℓ, m′, m) for ℓ in range(ℓₘₐₓ+1)\n    for m′ in range(-min(ℓ, m′ₘₐₓ), min(ℓ, m′ₘₐₓ)+1)\n    for m in range(abs(m′), ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerHrange","page":"Utilities","title":"SphericalFunctions.WignerHrange","text":"WignerHrange(ℓₘₐₓ, m′ₘₐₓ=ℓₘₐₓ)\n\nCreate an array of (ℓ, m', m) indices as in H array\n\nSee also WignerHsize and WignerHindex\n\nNotes\n\nHere, it is assumed that only data with m≥|m'| are stored, and only corresponding values are passed.  We also assume |m|≤ℓ and |m'|≤ℓ.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(ℓ, m′, m) for ℓ in range(ℓₘₐₓ+1)\n    for m′ in range(-min(ℓ, m′ₘₐₓ), min(ℓ, m′ₘₐₓ)+1)\n    for m in range(abs(m′), ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerHsize-Tuple{Any}","page":"Utilities","title":"SphericalFunctions.WignerHsize","text":"WignerHsize(ℓₘₐₓ, m′ₘₐₓ=ℓₘₐₓ)\n\nTotal size of array of wedges of width m′ₘₐₓ up to ℓₘₐₓ.  If m′ₘₐₓ is not given, it defaults to ℓₘₐₓ.\n\nSee also WignerHrange and WignerHindex.\n\nNotes\n\nHere, it is assumed that only data with m≥|m′| are stored, and only corresponding values are passed.  We also assume |m|≤ℓ and |m′|≤ℓ.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(ℓ, m′, m) for ℓ in 0:ℓₘₐₓ\n    for m′ in -min(ℓ, m′ₘₐₓ):min(ℓ, m′ₘₐₓ)\n    for m in abs(m′):ℓ\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.Yindex","page":"Utilities","title":"SphericalFunctions.Yindex","text":"Yindex(ℓ, m, ℓₘᵢₙ=0)\n\nCompute index into array of mode weights\n\nParameters\n\nℓ : int     Integer satisfying ℓₘᵢₙ <= ℓ <= ℓₘₐₓ m : int     Integer satisfying -ℓ <= m <= ℓ ℓₘᵢₙ : int, optional     Integer satisfying 0 <= ℓₘᵢₙ.  Defaults to 0.\n\nReturns\n\ni : int     Index of a particular element of the mode-weight array as described below\n\nSee Also\n\nYsize : Total size of array of mode weights Yrange : Array of (ℓ, m) indices corresponding to this array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ℓ, m)\n    for ℓ in range(ℓₘᵢₙ, ℓₘₐₓ+1)\n    for m in range(-ℓ, ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.Yrange-Tuple{Any}","page":"Utilities","title":"SphericalFunctions.Yrange","text":"Yrange(ℓₘᵢₙ, ℓₘₐₓ)\n\nCreate an array of (ℓ, m) indices as in Y array\n\nParameters\n\nℓₘᵢₙ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ ℓₘₐₓ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ\n\nReturns\n\ni : int     Total size of array of mode weights arranged as described below\n\nSee Also\n\nYsize : Total size of array of mode weights Yindex : Index of a particular element of the mode weight array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ℓ, m)\n    for ℓ in range(ℓₘᵢₙ, ℓₘₐₓ+1)\n    for m in range(-ℓ, ℓ+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.Ysize-Tuple{Any}","page":"Utilities","title":"SphericalFunctions.Ysize","text":"Ysize(ℓₘₐₓ)\n\nCompute total size of array of mode weights\n\nSee Also\n\nYrange : Array of (ℓ, m) indices corresponding to this array Yindex : Index of a particular element of the mode weight array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ℓ, m)\n    for ℓ in range(ℓₘᵢₙ, ℓₘₐₓ+1)\n    for m in range(-ℓ, ℓ+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions._WignerHindex-NTuple{4, Any}","page":"Utilities","title":"SphericalFunctions._WignerHindex","text":"Helper function for WignerHindex\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.deduce_limits","page":"Utilities","title":"SphericalFunctions.deduce_limits","text":"deduce_limits(ysize, [ℓmin])\n\nDeduce the value of (ℓmin, ℓmax) that produces Y arrays of the given size.\n\nIf ℓmin is not given, it is assumed to be 0.  If it is set to nothing, the smallest possible value of ℓmin will be used.  However, note that this is not a well-posed problem; multiple combinations of (ℓmin, ℓmax) can give rise to Y arrays of the same size.\n\nSee also Ysize\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.phi_theta-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"Utilities","title":"SphericalFunctions.phi_theta","text":"phi_theta(Nϕ, Nθ, [T=Float64])\n\nConstruct (phi, theta) grid in order expected by this package.\n\nSee also theta_phi for the opposite ordering.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.theta_phi-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"Utilities","title":"SphericalFunctions.theta_phi","text":"theta_phi(Nθ, Nϕ, [T=Float64])\n\nConstruct (theta, phi) grid in spinsfast order.\n\nNote that this order is different from the one assumed by this package; use phi_theta for the opposite ordering.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Combinatorics","page":"Utilities","title":"Combinatorics","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Spherical functions frequently involve binomial coefficients and similar terms, with arguments proportional to ℓ, which we aim to allow to be very large — of order 1,000 or more. Unfortunately, due to combinatorical explosions, this is frequently infeasible with naive methods.  Here, we collect any specialized methods that help us beat the limits.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"utils.jl\"]","category":"page"},{"location":"utilities/#SphericalFunctions.sqrtbinomial","page":"Utilities","title":"SphericalFunctions.sqrtbinomial","text":"sqrtbinomial(n, k, [T])\n\nEvaluate the square-root of the binomial coefficient binomial(n,k) for large coefficients.\n\nOrdinarily, when n and k are standard Int arguments, the built-in binomial function will overflow around n=66, because it results in Ints.  We need much larger values. This function, which is based on a related one in SpecialFunctions.jl, returns reasonably accurate results up to n ≈ 1026 when k ≈ n/2 (which is the case of interest in many applications in this package).\n\nComputations are carried out (and returned) in type T, which defaults to Float64.\n\n\n\n\n\n","category":"function"},{"location":"notes/H_recursions/#Algorithm-for-computing-H","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"The H array, as given by Gumerov and Duraiswami, is related to Wigner's (small) d matrices — which is itself related to the (big) mathfrakD matrices and the various spin-weighted spherical harmonics _sY_ellm — via","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"d_ell^mm = epsilon_m epsilon_-m H_ell^mm","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"where","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"epsilon_k =\n  begincases\n    1  kleq 0 \n    (-1)^k  k  0\n  endcases","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"H has various advantages over d, including the fact that it can be efficiently and robustly valculated via recurrence relations, and the following symmetry relations:","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  H^m m_n(β) = H^m m_n(β) \n  H^m m_n(β) = H^-m -m_n(β) \n  H^m m_n(β) = (-1)^n+m+m H^-m m_n(π - β) \n  H^m m_n(β) = (-1)^m+m H^m m_n(-β)\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Because of these symmetries, we only need to evaluate at most 1/4 of all the elements.","category":"page"},{"location":"notes/H_recursions/#Steps-to-compute-H","page":"Algorithm for computing H","title":"Steps to compute H","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"The following describes various details that are not spelled out correctly by Gumerov and Duraiswami.  All equation numbers refer to that paper.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Because of the symmetries noted above, we only compute H^m m_n with m  m — roughly one quarter of all possible values.  Furthermore, for computations of spin-weighted spherical harmonics of weight s, we only need to compute values with m  s, which constitutes a dramatic savings when s  ℓₘₐₓ.  The data are stored in the array Hwedge.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"However, some parts of this calculation require calculating terms with m=n+1 — whereas such elements of d and mathfrakD are considered zero.  For this purpose, we need additional storage.  Rather than allocating extra space, or requiring some additional workspace to be passed in, we can actually use parts of the input H data space for temporary storage while these extra terms are needed, which is before those parts of the storage are needed.  Specifically, we need this additional storage for H^0 m_n_mathrmmax+1 with m in 0 n_mathrmmax+1, and we can use the storage destined for H^-1 m_n_mathrmmax with m in 1 n_mathrmmax.  But this leaves two more indices, which we just store as individual variables — HΩ and HΨ — representing the last and second-to-last of these additional elements stored.","category":"page"},{"location":"notes/H_recursions/#Step-1","page":"Algorithm for computing H","title":"Step 1","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Set H_0^00=1.","category":"page"},{"location":"notes/H_recursions/#Step-2","page":"Algorithm for computing H","title":"Step 2","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Compute values H^0m_n(β) for m=0ldotsn and H^0m_n+1(β) for m=0ldotsn+1.  Using Eq. (32), we see that within Gumerov and Duraiswami's conventions","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  H^0m_n(β) = (-1)^m sqrtfrac(n-m)(n+m) P^m_n(cos β) \n                 = frac1sqrtk_m (2n+1) P_nm(cos β)\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Here, k_0=1 and k_m=2 for m0, and P is defined as","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"  P_nm = sqrtfrack_m(2n+1)(n-m)(n+m) P_nm","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Note that the factor of (-1)^m in the first equation above is different from the convention used here, and is related to the Condon-Shortley phase. Note that Gumerov and Duraiswami use the notation P^m_n, whereas we are using the notation P_nm — which usually differ by a factor of (-1)^m.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"We use the \"fully normalized\" associated Legendre functions (fnALF) P because, as explained by Xing et al. (2020), it is possible to compute these values very efficiently and accurately, while also delaying the onset of overflow and underflow.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"The algorithm Xing et al. describe as the best for computing P is due to Belikov (1991), and is given by them as","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  P_00 = 1 \n  P_10 = sqrt3 cos β \n  P_11 = sqrt3 sin β \n  P_n0 = a_n cos β P_n-10 - b_n fracsin β2 P_n-11 \n  P_nm =\n    c_nm cos β P_n-1m\n    - sin β left d_nm P_n-1m+1 - e_nm P_n-1m-1 right\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"where the coefficients are given by","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  a_n = sqrtfrac2n+12n-1 \n  b_n = sqrtfrac2(n-1)(2n+1)n(2n-1) \n  c_nm = frac1n sqrtfrac(n+m)(n-m)(2n+1)2n-1 \n  d_nm = frac12n sqrtfrac(n-m)(n-m-1)(2n+1)2n-1 \n  e_nm = frac12n sqrtfrac22-delta_0^m-1 sqrtfrac(n+m)(n+m-1)(2n+1)2n-1\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Now, we can directly obtain a recurrence relation for H^0m_n = P_nm  sqrtk_m (2n+1) from those expressions:","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  H^00_0 = 1 \n  H^00_1 = cos β \n  H^01_1 = sqrt12 sin β \n  H^00_n = a_n cos β H^00_n-1 - b_n sin β H^01_n-1 \n  H^0m_n =\n    c_nm cos β H^0m_n-1\n    - sin β left d_nm H^0m+1_n-1 - e_nm H^0m-1_n-1 right\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"where the coefficients are given by","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  b_n = sqrtfracn-1n \n  c_nm = frac1n sqrt(n+m)*(n-m) \n  d_nm = frac12n sqrt(n-m)*(n-m-1) \n  e_nm = frac12n sqrt(n+m)*(n+m-1)\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Note that the coefficients all simplified (in fact, a_n disappeared), without any increase in the complexity of the recurrence relations themselves.  Rewriting Belikov's algorithm explicitly in terms of the H^0m_n also allows us to avoid an extra normalization step.","category":"page"},{"location":"notes/H_recursions/#Step-3","page":"Algorithm for computing H","title":"Step 3","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Compute H^1m_n(β) for m=1ldotsn using relation (41).  Symmetry and shift of the indices allow this relation to be written as","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"b^0_n+1 H^1 m_n\n  = fracb^m1_n+1 (1cos β)2 H^0 m+1_n+1\n   fracb^ m1_n+1 (1+cos β)2 H^0 m1_n+1\n   a^m_n sin β H^0 m_n+1","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Here the constants are defined by","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"a^m_n = sqrtfrac(n+m+1)(n-m+1) (2n+1)(2n+3)","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"b^m_n = mathrmsgn(m) sqrtfrac(n-m-1)(n-m) (2n-1)(2n+1)","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Note that all values are assumed to be zero whenever m  n, we use mathrmsgn(0)=1 (unlike the common convention that mathrmsgn(0)=0), and we have a^m_n = a^-m_n.  Also note that these coefficients only appear in this step, and because of how they appear (specifically, because b always appears with argument n+1), we can factor out the denominators in the definitions of the constants.  We obtain this simplified formula","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"H^1 m_n\n  = -frac1sqrtn(n+1) left\n      fracbarb^m1_n+1 (1cos β)2 H^0 m+1_n+1\n      + fracbarb^ m1_n+1 (1+cos β)2 H^0 m1_n+1\n      + bara^m_n sin β H^0 m_n+1\n    right","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"with","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"bara^m_n = sqrt(n+m+1)(n-m+1)","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"barb^m_n+1 = sqrt(n-m)(n-m+1)","category":"page"},{"location":"notes/H_recursions/#Step-4","page":"Algorithm for computing H","title":"Step 4","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Recursively compute H^m+1 m_n(β) for m=1ldotsn1, m=mn using relation (50) resolved with respect to H^m+1 m_n:","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"d^m_n H^m+1 m_n\n  = d^m1_n H^m1 m_n\n   d^m1_n H^m m1_n\n  + d^m_n H^m m+1_n","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"(where the last term drops out for m=n).  The constants are defined by","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"d^m_n = fracmathrmsgn(m)2 sqrt(n-m)(n+m+1)","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Note that we can drop the factor of 12, and for this case only the sign is always +1.","category":"page"},{"location":"notes/H_recursions/#Step-5","page":"Algorithm for computing H","title":"Step 5","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Recursively compute H^m1 m_n(β) for m=0ldotsn+1, m=mldotsn using relation (50) resolved with respect to H^m1 m_n:","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"d^m1_n H^m1 m_n\n  = d^m_n H^m+1 m_n\n  + d^m1_n H^m m1_n\n   d^m_n H^m m+1_n","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"(where the last term drops out for m=n).","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"NOTE: Although Gumerov and Duraiswami specify the loop over m to start at -1, I find it necessary to start at 0, or there will be missing information. This also requires setting the H^0 -1_n components (for all n) before beginning this loop.","category":"page"},{"location":"notes/H_recursions/#Pre-computing-constants-versus-computing-on-the-fly","page":"Algorithm for computing H","title":"Pre-computing constants versus computing on the fly","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Each of the constants a^m_n, b^m_n, and c^m_n involves divisions and square-roots, which can be very costly to compute.  It can be advantageous to pre-compute the constants, and simply index the pre-computed arrays rather than re-computing them on each recursion.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"If we include the cost of computing all these constants in a single call to the H recurrence, it can be much cheaper to compute each constant as needed within the algorithm, rather than computing them all at once at the beginning of the algorithm — but only for very small computations, such as those involving n_mathrmmax  10.  Beyond this, despite the storage penalties for all those constants, it turns out to be better to pre-compute them.  However, it should be noted that the fractional cost of storing the constants is sim 3n_mathrmmax compared to just storing H itself, so this will never be a very significant amount of space.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"On the other hand, if we can pre-compute the constants just once, and store them between multiple calls to the H recurrence, then it is always advantageous to do so — typically by factors of 2 or 3 in speed.  The only difficulty here is ensuring that each call to the recurrence has access to the constants, which can be a little awkward when using multiple processes and/or threads.  However, it should be thread safe, since we only need to read those constants within the H recurrence.  All in all, I conclude that it is probably not worth the effort to maintain separate versions of the recurrence for pre-computed and on-the-fly constants.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is a Julia package for evaluating and transforming Wigner's 𝔇 matrices, and spin-weighted spherical harmonics _sY_ellm (which includes the ordinary scalar spherical harmonics).  These functions are evaluated directly in terms of quaternions, as well as in the more standard forms of spherical coordinates and Euler angles.[1]  Among other applications, those functions permit \"synthesis\" (evaluation of the spin-weighted spherical functions) of spin-weighted spherical harmonic coefficients on regular or distorted grids. This package also includes functions enabling efficient \"analysis\" (decomposition into mode coefficients) of functions evaluated on regular grids to high order and accuracy.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"These quantities are computed using recursion relations, which makes it possible to compute to very high ℓ values.  Unlike direct evaluation of individual elements, which will generally cause overflow or underflow beyond ℓ≈30 when using double precision, these recursion relations should be valid for far higher ℓ values.  More precisely, when using this package, Inf values appear starting at ℓ=22 for Float16, ℓ=183 for Float32, and ℓ=1474 for Float64. Julia's built-in BigFloat type also works, achieves very high accuracy, and presumably will not overflow for any ℓ value that could reasonably fit into computer memory — though it is far slower due to the memory allocation inherent to this type.  Also note that DoubleFloats will work, and achieve significantly greater accuracy (but no greater range) than Float64. In all cases, results are typically accurate to roughly ℓ times the precision of the input quaternion.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The conventions for this package are described in detail on this page.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note that numerous other packages cover some of these use cases, including FastTransforms.jl, FastSphericalHarmonics.jl, WignerSymbols.jl, and WignerFamilies.jl.  However, I need support for quaternions (via Quaternionic.jl) and for higher-precision numbers — even at the cost of a very slight decrease in speed in some cases — which are what this package provides.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Depth = 4","category":"page"},{"location":"#Function-list","page":"Introduction","title":"Function list","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following list contains the public functions inside the SphericalFunctions module.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [SphericalFunctions]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1]: Euler angles are quite generally a very poor choice for computing with rotations.  (The only context in which they may be preferred is when analytically integrating some analytically known functions.)  Almost universally, it is best to use quaternions when computing with rotations. All the computations done within this package use quaternions; the user interfaces involving Euler angles essentially convert to/from quaternions. While the calculations needed for those conversions would still need to be done if this package used Euler angles internally — meaning that this approach is as efficient as any — that work can be avoided entirely if you work with quaternions directly.","category":"page"}]
}
