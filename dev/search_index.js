var documenterSearchIndex = {"docs":
[{"location":"manual/#Calculators","page":"Basics","title":"Calculators","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"Typically, when calculating special functions, we will use recurrence relations along with some coefficients — which frequently requires significant setup processing.  That processing can be cached, so that the calculations themselves consist primarily of memory accesses and simple arithmetic.  For this reason, we use \"calculator\" objects, which will be constructed with some indication of the largest indices you expect to use.  The calculators can then be called repeatedly for specific values of the arguments, which will compute the function values for all (or some subset of) indices.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [SphericalFunctions.AssociatedLegendreFunction]\nPages   = [\"src/associated_legendre/calculator.jl\"]","category":"page"},{"location":"manual/#SphericalFunctions.AssociatedLegendreFunction.ALFcompute!-Union{Tuple{T}, Tuple{Vector{T}, Complex{T}, Int64, ALFRecursionCoefficients{T}}} where T<:Real","page":"Basics","title":"SphericalFunctions.AssociatedLegendreFunction.ALFcompute!","text":"ALFcompute(expiβ, nmax)\nALFcompute!(P̄, expiβ, nmax)\nALFcompute(expiβ, nmax, recursion_coefficients)\nALFcompute!(P̄, expiβ, nmax, recursion_coefficients)\n\nCompute the \"fully normalized\" Associated Legendre Functions up to some maximum n value nmax.\n\nThese functions can take a vector P̄, to store the data, stored in order of increasing m most rapidly varying and then increasing n.  If not supplied, P̄ will be constructed for you and returned.\n\nThe optional recursion_coefficients argument must be an ALFRecursionCoefficients, which stores various constant coefficients used in the recursion.  This object requires more than 3x the memory and more than 20x the time to compute a single P̄ vector without this argument, but passing it will typically speed up the calculation of each P̄ by a factor of 8x or so.  Thus, if you expect to compute P̄ more than a few times, it will take less time to pre-compute those factors, and pass them to this function.\n\nNote that the base real type will be inferred from the (complex) type of expiβ.  If present, the base types of P̄ and recursion_coefficients must agree.\n\n\n\n\n\n","category":"method"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [WignerMatrices]\nPages   = [\"wigner_matrices/calculator.jl\", \"wigner_matrices/evaluate.jl\"]","category":"page"},{"location":"manual/#Transformation","page":"Basics","title":"Transformation","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [SphericalFunctions]\nPages   = [\"map2salm.jl\"]","category":"page"},{"location":"manual/#SphericalFunctions.map2salm!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, N} where N, AbstractArray{Complex{T}, N} where N, Int64, Int64}} where T<:Real","page":"Basics","title":"SphericalFunctions.map2salm!","text":"map2salm!(salm, map, spin, ℓmax, [ℓmin])\nmap2salm!(salm, map, plan)\n\nTransform map values sampled on the sphere to _sa_ell m modes in place.\n\nFor details, see map2salm.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, N} where N, Int64, Int64}} where T<:Real","page":"Basics","title":"SphericalFunctions.map2salm","text":"map2salm(map, spin, ℓmax, [ℓmin])\nmap2salm(map, plan)\n\nTransform map values sampled on the sphere to _sa_ell m modes.\n\nThe map array should have size Nφ along its first dimension and Nϑ along its second; any number of dimensions may follow.  The spin must be entered explicitly, and ℓmax is the highest ℓ value you want in the output.  The ℓmin represents the smallest ℓ value in the output and defaults to abs(spin); it generally should never be larger than this.\n\nFor repeated applications of this function with different values of map, it is more efficient to pre-compute plan using plan_map2salm.  These functions will create a new salm array on each call.  To operate in place on a pre-allocated salm array, use map2salm!.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.plan_map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, N} where N, Int64, Int64}, Tuple{AbstractArray{Complex{T}, N} where N, Int64, Int64, Int64}} where T<:Real","page":"Basics","title":"SphericalFunctions.plan_map2salm","text":"plan_map2salm(map, spin, ℓmax, [ℓmin])\n\nPrecompute values to use in executing map2salm or map2salm!.\n\nThe arguments to this function exactly mirror those of the first form map2salm.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"While not usually the star of the show, the following utilities can be quite helpful for actually using the rest of the code.","category":"page"},{"location":"utilities/#Complex-powers","page":"Utilities","title":"Complex powers","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"One common task we find when working with spherical functions is the computation of a range of integer powers of some complex number — so much so that it can be best to pre-compute the powers and cache their values.  While a naive approach is generally quite accurate, and reasonably fast, we can do a little better with a specialized routine.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"complex_powers.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#SphericalFunctions.complex_powers!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 1}, Complex{T}}} where T<:Real","page":"Utilities","title":"SphericalFunctions.complex_powers!","text":"complex_powers!(zpowers, z)\n\nCompute integer powers of z from z^0 through z^m, recursively, where m is one less than the length of the input zpowers vector.\n\nNote that z is assumed to be normalized, with complex amplitude approximately 1.\n\nSee also: complex_powers\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.complex_powers-Union{Tuple{T}, Tuple{Complex{T}, Int64}} where T<:Real","page":"Utilities","title":"SphericalFunctions.complex_powers","text":"complex_powers(z, m)\n\nCompute integer powers of z from z^0 through z^m, recursively.\n\nNote that z is assumed to be normalized, with complex amplitude approximately 1.\n\nThis algorithm is mostly due to Stoer and Bulirsch in \"Introduction to Numerical Analysis\" (page 24) — with a little help from de Moivre's formula, which is essentially exp(iθ)ⁿ = exp(inθ), as well as my own alterations to deal with different behaviors in different quadrants.\n\nThere isn't usually a huge advantage to using this specialized function.  If you just need a particular power, it will generally be far more efficient and just as accurate to compute either exp(iθ)ⁿ or exp(inθ) explicitly.  However, if you need all powers from 0 to m, this function is about 10 or 5 times faster than those options, respectively, for large m.  Like those options, this function is numerically stable, in the sense that its errors are usually smaller than m times the error from machine-precision errors in the input argument — or at worst about 50% larger, which occurs as the phase approaches multiples of π/2.\n\nSee also: complex_powers!\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Quadrature-weights","page":"Utilities","title":"Quadrature weights","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"weights.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#SphericalFunctions.clenshaw_curtis-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"Utilities","title":"SphericalFunctions.clenshaw_curtis","text":"clenshaw_curtis(n, [T])\n\nCompute n weights for the Clenshaw-Curtis rule, corresponding to n evenly spaced nodes from 0 to π inclusive.  That is, the nodes are located at\n\ntheta_k = k fracpin-1 quad k=0 ldots n-1\n\nThis function uses Waldvogel's method.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.fejer1-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"Utilities","title":"SphericalFunctions.fejer1","text":"fejer1(n, [T])\n\nCompute n weights for Fejér's first rule, corresponding to n evenly spaced nodes from 0 to π inclusive.  That is, the nodes are located at\n\ntheta_k = k fracpin-1 quad k=0 ldots n-1\n\nThis function uses Waldvogel's method.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.fejer2-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"Utilities","title":"SphericalFunctions.fejer2","text":"fejer2(n, [T])\n\nCompute n weights for Fejér's second rule, corresponding to n evenly spaced nodes between 0 and π exclusive.  That is, the nodes are located at\n\ntheta_k = k fracpin+1 quad k=1 ldots n\n\nThis function uses Waldvogel's method.  However, contrary to Waldvogel's notation, this routine does not include the weight corresponding to the ϑ=0 or π nodes, which both have weight 0.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Y-data","page":"Utilities","title":"Y data","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"By Y data, we mean anything indexed like Y_ell m modes.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"indexing.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#SphericalFunctions.WignerDindex","page":"Utilities","title":"SphericalFunctions.WignerDindex","text":"WignerDindex(ℓ, m′, m, ℓₘᵢₙ=0, m′ₘₐₓ=-1)\n\nCompute index into Wigner 𝔇 matrix\n\nParameters\n\nℓ : int     Integer satisfying ℓₘᵢₙ <= ℓ <= ℓₘₐₓ m′ : int     Integer satisfying -min(ℓₘₐₓ, m′ₘₐₓ) <= m′ <= min(ℓₘₐₓ, m′ₘₐₓ) m : int     Integer satisfying -ℓ <= m <= ℓ ℓₘᵢₙ : int, optional     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ.  Defaults to 0. m′ₘₐₓ : int, optional     Integer satisfying 0 <= m′ₘₐₓ.  Defaults to ℓ.\n\nReturns\n\ni : int     Index into Wigner 𝔇 matrix arranged as described below\n\nSee Also\n\nWignerDsize : Total size of the 𝔇 matrix WignerDrange : Array of (ℓ, m', m) indices corresponding to the 𝔇 matrix\n\nNotes\n\nThis assumes that the Wigner 𝔇 matrix is arranged as\n\n[\n    𝔇(ℓ, m′, m)\n    for ℓ in range(ℓₘᵢₙ, ℓₘₐₓ+1)\n    for m′ in range(-min(ℓ, m′ₘₐₓ), min(ℓ, m′ₘₐₓ)+1)\n    for m in range(-ℓ, ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerDrange","page":"Utilities","title":"SphericalFunctions.WignerDrange","text":"WignerDrange(ℓₘᵢₙ, m′ₘₐₓ, ℓₘₐₓ=-1)\n\nCreate an array of (ℓ, m', m) indices as in 𝔇 array\n\nParameters\n\nℓₘᵢₙ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ m′ₘₐₓ : int, optional     Integer satisfying 0 <= m′ₘₐₓ.  Default is ℓₘₐₓ. ℓₘₐₓ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ\n\nSee Also\n\nWignerDsize : Total size of 𝔇 array WignerDindex : Index inside these wedges\n\nNotes\n\nThis assumes that the Wigner 𝔇 matrix is arranged as\n\n[\n    𝔇(ℓ, m′, m)\n    for ℓ in range(ℓₘᵢₙ, ℓₘₐₓ+1)\n    for m′ in range(-min(ℓ, m′ₘₐₓ), min(ℓ, m′ₘₐₓ)+1)\n    for m in range(-ℓ, ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerDsize","page":"Utilities","title":"SphericalFunctions.WignerDsize","text":"WignerDsize(ℓₘᵢₙ, m′ₘₐₓ, ℓₘₐₓ=-1)\n\nCompute total size of Wigner 𝔇 matrix\n\nParameters\n\nℓₘᵢₙ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ m′ₘₐₓ : int, optional     Integer satisfying 0 <= m′ₘₐₓ.  Defaults to ℓₘₐₓ. ℓₘₐₓ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ\n\nReturns\n\ni : int     Total size of Wigner 𝔇 matrix arranged as described below\n\nSee Also\n\nWignerDrange : Array of (ℓ, m', m) indices corresponding to the 𝔇 matrix WignerDindex : Index of a particular element of the 𝔇 matrix\n\nNotes\n\nThis assumes that the Wigner 𝔇 matrix is arranged as\n\n[\n    𝔇(ℓ, m′, m)\n    for ℓ in range(ℓₘᵢₙ, ℓₘₐₓ+1)\n    for m′ in range(-min(ℓ, m′ₘₐₓ), min(ℓ, m′ₘₐₓ)+1)\n    for m in range(-ℓ, ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerHindex","page":"Utilities","title":"SphericalFunctions.WignerHindex","text":"WignerHindex(ℓ, m′, m, m′ₘₐₓ)\n\nIndex to \"wedge\" arrays\n\nParameters\n\nℓ : int m′ : int m : int m′ₘₐₓ : int, optional     If nothing, it is assumed to be at least ℓ\n\nSee Also\n\nWignerHsize : Total size of wedge array WignerHrange : Array of (ℓ, m', m) indices corresponding to this wedge\n\nNotes\n\nHere, it is assumed that only data with m≥|m'| are stored, and only corresponding values are passed.  We also assume |m|≤ℓ and |m'|≤ℓ.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(ℓ, m′, m) for ℓ in range(ℓₘₐₓ+1)\n    for m′ in range(-min(ℓ, m′ₘₐₓ), min(ℓ, m′ₘₐₓ)+1)\n    for m in range(abs(m′), ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerHrange","page":"Utilities","title":"SphericalFunctions.WignerHrange","text":"WignerHrange(m′ₘₐₓ, ℓₘₐₓ=-1)\n\nCreate an array of (ℓ, m', m) indices as in H array\n\nParameters\n\nℓₘₐₓ : int m′ₘₐₓ : int, optional     If nothing, it is assumed to be at least ℓ\n\nSee Also\n\nWignerHsize : Total size of wedge array WignerHindex : Index inside these wedges\n\nNotes\n\nHere, it is assumed that only data with m≥|m'| are stored, and only corresponding values are passed.  We also assume |m|≤ℓ and |m'|≤ℓ.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(ℓ, m′, m) for ℓ in range(ℓₘₐₓ+1)\n    for m′ in range(-min(ℓ, m′ₘₐₓ), min(ℓ, m′ₘₐₓ)+1)\n    for m in range(abs(m′), ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerHsize","page":"Utilities","title":"SphericalFunctions.WignerHsize","text":"WignerHsize(m′ₘₐₓ, ℓₘₐₓ=-2)\n\nTotal size of array of wedges of width m′ₘₐₓ up to ℓₘₐₓ\n\nParameters\n\nℓₘₐₓ : int m′ₘₐₓ : int, optional     If nothing, it is assumed to be at least ℓ\n\nSee Also\n\nWignerHrange : Array of (ℓ, m', m) indices corresponding to this wedge WignerHindex : Index inside these wedges\n\nNotes\n\nHere, it is assumed that only data with m≥|m'| are stored, and only corresponding values are passed.  We also assume |m|≤ℓ and |m'|≤ℓ.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(ℓ, m′, m) for ℓ in range(ℓₘₐₓ+1)\n    for m′ in range(-min(ℓ, m′ₘₐₓ), min(ℓ, m′ₘₐₓ)+1)\n    for m in range(abs(m′), ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.Yindex","page":"Utilities","title":"SphericalFunctions.Yindex","text":"Yindex(ℓ, m, ℓₘᵢₙ=0)\n\nCompute index into array of mode weights\n\nParameters\n\nℓ : int     Integer satisfying ℓₘᵢₙ <= ℓ <= ℓₘₐₓ m : int     Integer satisfying -ℓ <= m <= ℓ ℓₘᵢₙ : int, optional     Integer satisfying 0 <= ℓₘᵢₙ.  Defaults to 0.\n\nReturns\n\ni : int     Index of a particular element of the mode-weight array as described below\n\nSee Also\n\nYsize : Total size of array of mode weights Yrange : Array of (ℓ, m) indices corresponding to this array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ℓ, m)\n    for ℓ in range(ℓₘᵢₙ, ℓₘₐₓ+1)\n    for m in range(-ℓ, ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.Yrange-Tuple{Any, Any}","page":"Utilities","title":"SphericalFunctions.Yrange","text":"Yrange(ℓₘᵢₙ, ℓₘₐₓ)\n\nCreate an array of (ℓ, m) indices as in Y array\n\nParameters\n\nℓₘᵢₙ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ ℓₘₐₓ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ\n\nReturns\n\ni : int     Total size of array of mode weights arranged as described below\n\nSee Also\n\nYsize : Total size of array of mode weights Yindex : Index of a particular element of the mode weight array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ℓ, m)\n    for ℓ in range(ℓₘᵢₙ, ℓₘₐₓ+1)\n    for m in range(-ℓ, ℓ+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.Ysize-Tuple{Any, Any}","page":"Utilities","title":"SphericalFunctions.Ysize","text":"Ysize(ℓₘᵢₙ, ℓₘₐₓ)\n\nCompute total size of array of mode weights\n\nParameters\n\nℓₘᵢₙ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ ℓₘₐₓ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ\n\nReturns\n\ni : int     Total size of array of mode weights arranged as described below\n\nSee Also\n\nYrange : Array of (ℓ, m) indices corresponding to this array Yindex : Index of a particular element of the mode weight array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ℓ, m)\n    for ℓ in range(ℓₘᵢₙ, ℓₘₐₓ+1)\n    for m in range(-ℓ, ℓ+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.deduce_limits","page":"Utilities","title":"SphericalFunctions.deduce_limits","text":"deduce_limits(ysize, [ℓmin])\n\nDeduce the value of (ℓmin, ℓmax) that produces Y arrays of the given size.\n\nIf ℓmin is not given, it is assumed to be 0.  If it is set to nothing, the smallest possible value of ℓmin will be used.  However, note that this is not a well-posed problem; multiple combinations of (ℓmin, ℓmax) can give rise to Y arrays of the same size.\n\nSee also Ysize\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.phi_theta","page":"Utilities","title":"SphericalFunctions.phi_theta","text":"phi_theta(Nϕ, Nθ, [T=Float64])\n\nConstruct (phi, theta) grid in order expected by this package.\n\nSee also theta_phi for the opposite ordering.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.theta_phi","page":"Utilities","title":"SphericalFunctions.theta_phi","text":"theta_phi(Nθ, Nϕ, [T=Float64])\n\nConstruct (theta, phi) grid in spinsfast order.\n\nNote that this order is different from the one assumed by this package; use phi_theta for the opposite ordering.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#D-data","page":"Utilities","title":"D data","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"By D data, we mean anything indexed like Wigner's mathfrakD matrices, or special subsets of them, like the H matrices.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"wigner_matrices/indexing.jl\", \"wigner_matrices/Hrecursions.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#SphericalFunctions.H!-Tuple{WignerMatrixCalculator, Complex}","page":"Utilities","title":"SphericalFunctions.H!","text":"H!(w, expiβ)\n\nCompute (a quarter of) the H matrix\n\nWARNING: The returned array will be a view into the workspace variable (see below for an explanation of that).  If you need to call this function again using the same workspace before extracting all information from the first call, you should use numpy.copy to make a separate copy of the result.\n\nParameters\n\nexpiβ : array_like     Value of exp(i*β) on which to evaluate the H matrix.\n\nReturns\n\nHwedge : array     This is a 1-dimensional array of floats; see below. workspace : arraylike, optional     A working array like the one returned by Wigner.newworkspace().  If not     present, this object's default workspace will be used.  Note that it is not     safe to use the same workspace on multiple threads.  Also see the WARNING     above.\n\nSee Also\n\nd : Compute the full Wigner d matrix D : Compute the full Wigner 𝔇 matrix rotate : Avoid computing the full 𝔇 matrix and rotate modes directly evaluate : Avoid computing the full 𝔇 matrix and evaluate modes directly\n\nNotes\n\nH is related to Wigner's (small) d via\n\ndₗⁿᵐ = ϵₙ ϵ₋ₘ Hₗⁿᵐ,\n\nwhere\n\n     ⎧ 1 for k≤0\nϵₖ = ⎨\n     ⎩ (-1)ᵏ for k>0\n\nH has various advantages over d, including the fact that it can be efficiently and robustly valculated via recurrence relations, and the following symmetry relations:\n\nH^{m', m}_n(β) = H^{m, m'}_n(β)\nH^{m', m}_n(β) = H^{-m', -m}_n(β)\nH^{m', m}_n(β) = (-1)^{n+m+m'} H^{-m', m}_n(π - β)\nH^{m', m}_n(β) = (-1)^{m+m'} H^{m', m}_n(-β)\n\nBecause of these symmetries, we only need to evaluate at most 1/4 of all the elements.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.nabsm_index-Tuple{Any, Any}","page":"Utilities","title":"SphericalFunctions.nabsm_index","text":"Return flat index into arrray of [n, abs(m)] pairs\n\nAssumes array is ordered as\n\n[\n    [n, m]\n    for n in range(n_max+1)\n    for m in range(n+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.nm_index-Tuple{Any, Any}","page":"Utilities","title":"SphericalFunctions.nm_index","text":"Return flat index into arrray of [n, m] pairs.\n\nAssumes array is ordered as\n\n[\n    [n, m]\n    for n in range(n_max+1)\n    for m in range(-n, n+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.nmpm_index-Tuple{Any, Any, Any}","page":"Utilities","title":"SphericalFunctions.nmpm_index","text":"Return flat index into arrray of [n, mp, m]\n\nAssumes array is ordered as\n\n[\n    [n, mp, m]\n    for n in range(n_max+1)\n    for mp in range(-n, n+1)\n    for m in range(-n, n+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia package for evaluating and transforming Wigner's 𝔇 matrices, and spin-weighted spherical harmonics (which includes the ordinary scalar spherical harmonics).  These functions are evaluated directly in terms of quaternions, as well as in the more standard forms of spherical coordinates and Euler angles.[1]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"These quantities are computed using recursion relations, which makes it possible to compute to very high ℓ values.  Unlike direct evaluation of individual elements, which will generally cause overflow or underflow beyond ℓ≈30 when using double precision, these recursion relations should be valid for far higher ℓ values.  More precisely, Inf values appear starting at ℓ=22 for Float16, ℓ=183 for Float32, and ℓ=1474 for Float64.  BigFloat also works, and presumably will not overflow for any ℓ value that could reasonably fit into computer memory — though it is far slower.  Also note that DoubleFloats will work, and achieve significantly greater accuracy (but no greater range) than Float64.  The results are accurate to roughly ℓ times the precision of the input quaternion.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The conventions for this package are described in detail on this page.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note that numerous other packages cover some of these use cases, including FastTransforms.jl, FastSphericalHarmonics.jl, and this package.  However, I need support for higher-precision numbers — even at the cost of some speed — which is what this package provides.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Depth = 4","category":"page"},{"location":"#Function-list","page":"Introduction","title":"Function list","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following list contains the public functions inside the SphericalFunctions module.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [SphericalFunctions]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1]: Euler angles are quite generally a very poor choice for computing with rotations.  (The only context in which they may be preferred is when analytically integrating some analytically known functions.)  Almost universally, it is best to use quaternions when computing with rotations.  All the computations done within this package use quaternions; the user interfaces involving Euler angles essentially convert to/from quaternions.  While the calculations needed for those conversions would still need to be done if this package used Euler angles internally — meaning that this approach is as efficient as any — that work can be avoided entirely if you work with quaternions directly.","category":"page"}]
}
