var documenterSearchIndex = {"docs":
[{"location":"manual/#Calculators","page":"Basics","title":"Calculators","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"Typically, when calculating special functions, we will use recurrence relations along with some coefficients ‚Äî which frequently requires significant setup processing.  That processing can be cached, so that the calculations themselves consist primarily of memory accesses and simple arithmetic.  For this reason, we use \"calculator\" objects, which will be constructed with some indication of the largest indices you expect to use.  The calculators can then be called repeatedly for specific values of the arguments, which will compute the function values for all (or some subset of) indices.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [SphericalFunctions.AssociatedLegendreFunction]\nPages   = [\"src/associated_legendre/calculator.jl\"]","category":"page"},{"location":"manual/#SphericalFunctions.AssociatedLegendreFunction.ALFcompute!-Union{Tuple{T}, Tuple{Vector{T}, Complex{T}, Int64, ALFRecursionCoefficients{T}}} where T<:Real","page":"Basics","title":"SphericalFunctions.AssociatedLegendreFunction.ALFcompute!","text":"ALFcompute(expiŒ≤, nmax)\nALFcompute!(PÃÑ, expiŒ≤, nmax)\nALFcompute(expiŒ≤, nmax, recursion_coefficients)\nALFcompute!(PÃÑ, expiŒ≤, nmax, recursion_coefficients)\n\nCompute the \"fully normalized\" Associated Legendre Functions up to some maximum n value nmax.\n\nThese functions can take a vector PÃÑ, to store the data, stored in order of increasing m most rapidly varying and then increasing n.  If not supplied, PÃÑ will be constructed for you and returned.\n\nThe optional recursion_coefficients argument must be an ALFRecursionCoefficients, which stores various constant coefficients used in the recursion.  This object requires more than 3x the memory and more than 20x the time to compute a single PÃÑ vector without this argument, but passing it will typically speed up the calculation of each PÃÑ by a factor of 8x or so.  Thus, if you expect to compute PÃÑ more than a few times, it will take less time to pre-compute those factors, and pass them to this function.\n\nNote that the base real type will be inferred from the (complex) type of expiŒ≤.  If present, the base types of PÃÑ and recursion_coefficients must agree.\n\n\n\n\n\n","category":"method"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [WignerMatrices]\nPages   = [\"wigner_matrices/calculator.jl\", \"wigner_matrices/evaluate.jl\"]","category":"page"},{"location":"manual/#Transformation","page":"Basics","title":"Transformation","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [SphericalFunctions]\nPages   = [\"map2salm.jl\"]","category":"page"},{"location":"manual/#SphericalFunctions.map2salm!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, N} where N, AbstractArray{Complex{T}, N} where N, Int64, Int64}} where T<:Real","page":"Basics","title":"SphericalFunctions.map2salm!","text":"map2salm!(salm, map, spin, ‚Ñìmax, [‚Ñìmin])\nmap2salm!(salm, map, plan)\n\nTransform map values sampled on the sphere to _sa_ell m modes in place.\n\nFor details, see map2salm.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, N} where N, Int64, Int64}} where T<:Real","page":"Basics","title":"SphericalFunctions.map2salm","text":"map2salm(map, spin, ‚Ñìmax, [‚Ñìmin])\nmap2salm(map, plan)\n\nTransform map values sampled on the sphere to _sa_ell m modes.\n\nThe map array should have size NœÜ along its first dimension and Nœë along its second; any number of dimensions may follow.  The spin must be entered explicitly, and ‚Ñìmax is the highest ‚Ñì value you want in the output.  The ‚Ñìmin represents the smallest ‚Ñì value in the output and defaults to abs(spin); it generally should never be larger than this.\n\nFor repeated applications of this function with different values of map, it is more efficient to pre-compute plan using plan_map2salm.  These functions will create a new salm array on each call.  To operate in place on a pre-allocated salm array, use map2salm!.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SphericalFunctions.plan_map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, N} where N, Int64, Int64}, Tuple{AbstractArray{Complex{T}, N} where N, Int64, Int64, Int64}} where T<:Real","page":"Basics","title":"SphericalFunctions.plan_map2salm","text":"plan_map2salm(map, spin, ‚Ñìmax, [‚Ñìmin])\n\nPrecompute values to use in executing map2salm or map2salm!.\n\nThe arguments to this function exactly mirror those of the first form map2salm.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"While not usually the star of the show, the following utilities can be quite helpful for actually using the rest of the code.","category":"page"},{"location":"utilities/#Complex-powers","page":"Utilities","title":"Complex powers","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"One common task we find when working with spherical functions is the computation of a range of integer powers of some complex number ‚Äî so much so that it can be best to pre-compute the powers and cache their values.  While a naive approach is generally quite accurate, and reasonably fast, we can do a little better with a specialized routine.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"complex_powers.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#SphericalFunctions.complex_powers!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 1}, Complex{T}}} where T<:Real","page":"Utilities","title":"SphericalFunctions.complex_powers!","text":"complex_powers!(zpowers, z)\n\nCompute integer powers of z from z^0 through z^m, recursively, where m is one less than the length of the input zpowers vector.\n\nNote that z is assumed to be normalized, with complex amplitude approximately 1.\n\nSee also: complex_powers\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.complex_powers-Union{Tuple{T}, Tuple{Complex{T}, Int64}} where T<:Real","page":"Utilities","title":"SphericalFunctions.complex_powers","text":"complex_powers(z, m)\n\nCompute integer powers of z from z^0 through z^m, recursively.\n\nNote that z is assumed to be normalized, with complex amplitude approximately 1.\n\nThis algorithm is mostly due to Stoer and Bulirsch in \"Introduction to Numerical Analysis\" (page 24) ‚Äî with a little help from de Moivre's formula, which is essentially exp(iŒ∏)‚Åø = exp(inŒ∏), as well as my own alterations to deal with different behaviors in different quadrants.\n\nThere isn't usually a huge advantage to using this specialized function.  If you just need a particular power, it will generally be far more efficient and just as accurate to compute either exp(iŒ∏)‚Åø or exp(inŒ∏) explicitly.  However, if you need all powers from 0 to m, this function is about 10 or 5 times faster than those options, respectively, for large m.  Like those options, this function is numerically stable, in the sense that its errors are usually smaller than m times the error from machine-precision errors in the input argument ‚Äî or at worst about 50% larger, which occurs as the phase approaches multiples of œÄ/2.\n\nSee also: complex_powers!\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Quadrature-weights","page":"Utilities","title":"Quadrature weights","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"weights.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#SphericalFunctions.clenshaw_curtis-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"Utilities","title":"SphericalFunctions.clenshaw_curtis","text":"clenshaw_curtis(n, [T])\n\nCompute n weights for the Clenshaw-Curtis rule, corresponding to n evenly spaced nodes from 0 to œÄ inclusive.  That is, the nodes are located at\n\ntheta_k = k fracpin-1 quad k=0 ldots n-1\n\nThis function uses Waldvogel's method.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.fejer1-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"Utilities","title":"SphericalFunctions.fejer1","text":"fejer1(n, [T])\n\nCompute n weights for Fej√©r's first rule, corresponding to n evenly spaced nodes from 0 to œÄ inclusive.  That is, the nodes are located at\n\ntheta_k = k fracpin-1 quad k=0 ldots n-1\n\nThis function uses Waldvogel's method.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.fejer2-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"Utilities","title":"SphericalFunctions.fejer2","text":"fejer2(n, [T])\n\nCompute n weights for Fej√©r's second rule, corresponding to n evenly spaced nodes between 0 and œÄ exclusive.  That is, the nodes are located at\n\ntheta_k = k fracpin+1 quad k=1 ldots n\n\nThis function uses Waldvogel's method.  However, contrary to Waldvogel's notation, this routine does not include the weight corresponding to the œë=0 or œÄ nodes, which both have weight 0.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Y-data","page":"Utilities","title":"Y data","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"By Y data, we mean anything indexed like Y_ell m modes.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"indexing.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#SphericalFunctions.WignerDindex","page":"Utilities","title":"SphericalFunctions.WignerDindex","text":"WignerDindex(‚Ñì, m‚Ä≤, m, ‚Ñì‚Çò·µ¢‚Çô=0, m‚Ä≤‚Çò‚Çê‚Çì=-1)\n\nCompute index into Wigner ùîá matrix\n\nParameters\n\n‚Ñì : int     Integer satisfying ‚Ñì‚Çò·µ¢‚Çô <= ‚Ñì <= ‚Ñì‚Çò‚Çê‚Çì m‚Ä≤ : int     Integer satisfying -min(‚Ñì‚Çò‚Çê‚Çì, m‚Ä≤‚Çò‚Çê‚Çì) <= m‚Ä≤ <= min(‚Ñì‚Çò‚Çê‚Çì, m‚Ä≤‚Çò‚Çê‚Çì) m : int     Integer satisfying -‚Ñì <= m <= ‚Ñì ‚Ñì‚Çò·µ¢‚Çô : int, optional     Integer satisfying 0 <= ‚Ñì‚Çò·µ¢‚Çô <= ‚Ñì‚Çò‚Çê‚Çì.  Defaults to 0. m‚Ä≤‚Çò‚Çê‚Çì : int, optional     Integer satisfying 0 <= m‚Ä≤‚Çò‚Çê‚Çì.  Defaults to ‚Ñì.\n\nReturns\n\ni : int     Index into Wigner ùîá matrix arranged as described below\n\nSee Also\n\nWignerDsize : Total size of the ùîá matrix WignerDrange : Array of (‚Ñì, m', m) indices corresponding to the ùîá matrix\n\nNotes\n\nThis assumes that the Wigner ùîá matrix is arranged as\n\n[\n    ùîá(‚Ñì, m‚Ä≤, m)\n    for ‚Ñì in range(‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì+1)\n    for m‚Ä≤ in range(-min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì), min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì)+1)\n    for m in range(-‚Ñì, ‚Ñì+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerDrange","page":"Utilities","title":"SphericalFunctions.WignerDrange","text":"WignerDrange(‚Ñì‚Çò·µ¢‚Çô, m‚Ä≤‚Çò‚Çê‚Çì, ‚Ñì‚Çò‚Çê‚Çì=-1)\n\nCreate an array of (‚Ñì, m', m) indices as in ùîá array\n\nParameters\n\n‚Ñì‚Çò·µ¢‚Çô : int     Integer satisfying 0 <= ‚Ñì‚Çò·µ¢‚Çô <= ‚Ñì‚Çò‚Çê‚Çì m‚Ä≤‚Çò‚Çê‚Çì : int, optional     Integer satisfying 0 <= m‚Ä≤‚Çò‚Çê‚Çì.  Default is ‚Ñì‚Çò‚Çê‚Çì. ‚Ñì‚Çò‚Çê‚Çì : int     Integer satisfying 0 <= ‚Ñì‚Çò·µ¢‚Çô <= ‚Ñì‚Çò‚Çê‚Çì\n\nSee Also\n\nWignerDsize : Total size of ùîá array WignerDindex : Index inside these wedges\n\nNotes\n\nThis assumes that the Wigner ùîá matrix is arranged as\n\n[\n    ùîá(‚Ñì, m‚Ä≤, m)\n    for ‚Ñì in range(‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì+1)\n    for m‚Ä≤ in range(-min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì), min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì)+1)\n    for m in range(-‚Ñì, ‚Ñì+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerDsize","page":"Utilities","title":"SphericalFunctions.WignerDsize","text":"WignerDsize(‚Ñì‚Çò·µ¢‚Çô, m‚Ä≤‚Çò‚Çê‚Çì, ‚Ñì‚Çò‚Çê‚Çì=-1)\n\nCompute total size of Wigner ùîá matrix\n\nParameters\n\n‚Ñì‚Çò·µ¢‚Çô : int     Integer satisfying 0 <= ‚Ñì‚Çò·µ¢‚Çô <= ‚Ñì‚Çò‚Çê‚Çì m‚Ä≤‚Çò‚Çê‚Çì : int, optional     Integer satisfying 0 <= m‚Ä≤‚Çò‚Çê‚Çì.  Defaults to ‚Ñì‚Çò‚Çê‚Çì. ‚Ñì‚Çò‚Çê‚Çì : int     Integer satisfying 0 <= ‚Ñì‚Çò·µ¢‚Çô <= ‚Ñì‚Çò‚Çê‚Çì\n\nReturns\n\ni : int     Total size of Wigner ùîá matrix arranged as described below\n\nSee Also\n\nWignerDrange : Array of (‚Ñì, m', m) indices corresponding to the ùîá matrix WignerDindex : Index of a particular element of the ùîá matrix\n\nNotes\n\nThis assumes that the Wigner ùîá matrix is arranged as\n\n[\n    ùîá(‚Ñì, m‚Ä≤, m)\n    for ‚Ñì in range(‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì+1)\n    for m‚Ä≤ in range(-min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì), min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì)+1)\n    for m in range(-‚Ñì, ‚Ñì+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerHindex","page":"Utilities","title":"SphericalFunctions.WignerHindex","text":"WignerHindex(‚Ñì, m‚Ä≤, m, m‚Ä≤‚Çò‚Çê‚Çì)\n\nIndex to \"wedge\" arrays\n\nParameters\n\n‚Ñì : int m‚Ä≤ : int m : int m‚Ä≤‚Çò‚Çê‚Çì : int, optional     If nothing, it is assumed to be at least ‚Ñì\n\nSee Also\n\nWignerHsize : Total size of wedge array WignerHrange : Array of (‚Ñì, m', m) indices corresponding to this wedge\n\nNotes\n\nHere, it is assumed that only data with m‚â•|m'| are stored, and only corresponding values are passed.  We also assume |m|‚â§‚Ñì and |m'|‚â§‚Ñì.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(‚Ñì, m‚Ä≤, m) for ‚Ñì in range(‚Ñì‚Çò‚Çê‚Çì+1)\n    for m‚Ä≤ in range(-min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì), min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì)+1)\n    for m in range(abs(m‚Ä≤), ‚Ñì+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerHrange","page":"Utilities","title":"SphericalFunctions.WignerHrange","text":"WignerHrange(m‚Ä≤‚Çò‚Çê‚Çì, ‚Ñì‚Çò‚Çê‚Çì=-1)\n\nCreate an array of (‚Ñì, m', m) indices as in H array\n\nParameters\n\n‚Ñì‚Çò‚Çê‚Çì : int m‚Ä≤‚Çò‚Çê‚Çì : int, optional     If nothing, it is assumed to be at least ‚Ñì\n\nSee Also\n\nWignerHsize : Total size of wedge array WignerHindex : Index inside these wedges\n\nNotes\n\nHere, it is assumed that only data with m‚â•|m'| are stored, and only corresponding values are passed.  We also assume |m|‚â§‚Ñì and |m'|‚â§‚Ñì.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(‚Ñì, m‚Ä≤, m) for ‚Ñì in range(‚Ñì‚Çò‚Çê‚Çì+1)\n    for m‚Ä≤ in range(-min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì), min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì)+1)\n    for m in range(abs(m‚Ä≤), ‚Ñì+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerHsize","page":"Utilities","title":"SphericalFunctions.WignerHsize","text":"WignerHsize(m‚Ä≤‚Çò‚Çê‚Çì, ‚Ñì‚Çò‚Çê‚Çì=-2)\n\nTotal size of array of wedges of width m‚Ä≤‚Çò‚Çê‚Çì up to ‚Ñì‚Çò‚Çê‚Çì\n\nParameters\n\n‚Ñì‚Çò‚Çê‚Çì : int m‚Ä≤‚Çò‚Çê‚Çì : int, optional     If nothing, it is assumed to be at least ‚Ñì\n\nSee Also\n\nWignerHrange : Array of (‚Ñì, m', m) indices corresponding to this wedge WignerHindex : Index inside these wedges\n\nNotes\n\nHere, it is assumed that only data with m‚â•|m'| are stored, and only corresponding values are passed.  We also assume |m|‚â§‚Ñì and |m'|‚â§‚Ñì.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(‚Ñì, m‚Ä≤, m) for ‚Ñì in range(‚Ñì‚Çò‚Çê‚Çì+1)\n    for m‚Ä≤ in range(-min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì), min(‚Ñì, m‚Ä≤‚Çò‚Çê‚Çì)+1)\n    for m in range(abs(m‚Ä≤), ‚Ñì+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.Yindex","page":"Utilities","title":"SphericalFunctions.Yindex","text":"Yindex(‚Ñì, m, ‚Ñì‚Çò·µ¢‚Çô=0)\n\nCompute index into array of mode weights\n\nParameters\n\n‚Ñì : int     Integer satisfying ‚Ñì‚Çò·µ¢‚Çô <= ‚Ñì <= ‚Ñì‚Çò‚Çê‚Çì m : int     Integer satisfying -‚Ñì <= m <= ‚Ñì ‚Ñì‚Çò·µ¢‚Çô : int, optional     Integer satisfying 0 <= ‚Ñì‚Çò·µ¢‚Çô.  Defaults to 0.\n\nReturns\n\ni : int     Index of a particular element of the mode-weight array as described below\n\nSee Also\n\nYsize : Total size of array of mode weights Yrange : Array of (‚Ñì, m) indices corresponding to this array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ‚Ñì, m)\n    for ‚Ñì in range(‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì+1)\n    for m in range(-‚Ñì, ‚Ñì+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.Yrange-Tuple{Any, Any}","page":"Utilities","title":"SphericalFunctions.Yrange","text":"Yrange(‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì)\n\nCreate an array of (‚Ñì, m) indices as in Y array\n\nParameters\n\n‚Ñì‚Çò·µ¢‚Çô : int     Integer satisfying 0 <= ‚Ñì‚Çò·µ¢‚Çô <= ‚Ñì‚Çò‚Çê‚Çì ‚Ñì‚Çò‚Çê‚Çì : int     Integer satisfying 0 <= ‚Ñì‚Çò·µ¢‚Çô <= ‚Ñì‚Çò‚Çê‚Çì\n\nReturns\n\ni : int     Total size of array of mode weights arranged as described below\n\nSee Also\n\nYsize : Total size of array of mode weights Yindex : Index of a particular element of the mode weight array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ‚Ñì, m)\n    for ‚Ñì in range(‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì+1)\n    for m in range(-‚Ñì, ‚Ñì+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.Ysize-Tuple{Any, Any}","page":"Utilities","title":"SphericalFunctions.Ysize","text":"Ysize(‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì)\n\nCompute total size of array of mode weights\n\nParameters\n\n‚Ñì‚Çò·µ¢‚Çô : int     Integer satisfying 0 <= ‚Ñì‚Çò·µ¢‚Çô <= ‚Ñì‚Çò‚Çê‚Çì ‚Ñì‚Çò‚Çê‚Çì : int     Integer satisfying 0 <= ‚Ñì‚Çò·µ¢‚Çô <= ‚Ñì‚Çò‚Çê‚Çì\n\nReturns\n\ni : int     Total size of array of mode weights arranged as described below\n\nSee Also\n\nYrange : Array of (‚Ñì, m) indices corresponding to this array Yindex : Index of a particular element of the mode weight array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ‚Ñì, m)\n    for ‚Ñì in range(‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì+1)\n    for m in range(-‚Ñì, ‚Ñì+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.deduce_limits","page":"Utilities","title":"SphericalFunctions.deduce_limits","text":"deduce_limits(ysize, [‚Ñìmin])\n\nDeduce the value of (‚Ñìmin, ‚Ñìmax) that produces Y arrays of the given size.\n\nIf ‚Ñìmin is not given, it is assumed to be 0.  If it is set to nothing, the smallest possible value of ‚Ñìmin will be used.  However, note that this is not a well-posed problem; multiple combinations of (‚Ñìmin, ‚Ñìmax) can give rise to Y arrays of the same size.\n\nSee also Ysize\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.phi_theta","page":"Utilities","title":"SphericalFunctions.phi_theta","text":"phi_theta(Nœï, NŒ∏, [T=Float64])\n\nConstruct (phi, theta) grid in order expected by this package.\n\nSee also theta_phi for the opposite ordering.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.theta_phi","page":"Utilities","title":"SphericalFunctions.theta_phi","text":"theta_phi(NŒ∏, Nœï, [T=Float64])\n\nConstruct (theta, phi) grid in spinsfast order.\n\nNote that this order is different from the one assumed by this package; use phi_theta for the opposite ordering.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#D-data","page":"Utilities","title":"D data","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"By D data, we mean anything indexed like Wigner's mathfrakD matrices, or special subsets of them, like the H matrices.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"wigner_matrices/indexing.jl\", \"wigner_matrices/Hrecursions.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#SphericalFunctions.H!-Tuple{WignerMatrixCalculator, Complex}","page":"Utilities","title":"SphericalFunctions.H!","text":"H!(w, expiŒ≤)\n\nCompute (a quarter of) the H matrix\n\nWARNING: The returned array will be a view into the workspace variable (see below for an explanation of that).  If you need to call this function again using the same workspace before extracting all information from the first call, you should use numpy.copy to make a separate copy of the result.\n\nParameters\n\nexpiŒ≤ : array_like     Value of exp(i*Œ≤) on which to evaluate the H matrix.\n\nReturns\n\nHwedge : array     This is a 1-dimensional array of floats; see below. workspace : arraylike, optional     A working array like the one returned by Wigner.newworkspace().  If not     present, this object's default workspace will be used.  Note that it is not     safe to use the same workspace on multiple threads.  Also see the WARNING     above.\n\nSee Also\n\nd : Compute the full Wigner d matrix D : Compute the full Wigner ùîá matrix rotate : Avoid computing the full ùîá matrix and rotate modes directly evaluate : Avoid computing the full ùîá matrix and evaluate modes directly\n\nNotes\n\nH is related to Wigner's (small) d via\n\nd‚Çó‚Åø·µê = œµ‚Çô œµ‚Çã‚Çò H‚Çó‚Åø·µê,\n\nwhere\n\n     ‚éß 1 for k‚â§0\nœµ‚Çñ = ‚é®\n     ‚é© (-1)·µè for k>0\n\nH has various advantages over d, including the fact that it can be efficiently and robustly valculated via recurrence relations, and the following symmetry relations:\n\nH^{m', m}_n(Œ≤) = H^{m, m'}_n(Œ≤)\nH^{m', m}_n(Œ≤) = H^{-m', -m}_n(Œ≤)\nH^{m', m}_n(Œ≤) = (-1)^{n+m+m'} H^{-m', m}_n(œÄ - Œ≤)\nH^{m', m}_n(Œ≤) = (-1)^{m+m'} H^{m', m}_n(-Œ≤)\n\nBecause of these symmetries, we only need to evaluate at most 1/4 of all the elements.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.nabsm_index-Tuple{Any, Any}","page":"Utilities","title":"SphericalFunctions.nabsm_index","text":"Return flat index into arrray of [n, abs(m)] pairs\n\nAssumes array is ordered as\n\n[\n    [n, m]\n    for n in range(n_max+1)\n    for m in range(n+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.nm_index-Tuple{Any, Any}","page":"Utilities","title":"SphericalFunctions.nm_index","text":"Return flat index into arrray of [n, m] pairs.\n\nAssumes array is ordered as\n\n[\n    [n, m]\n    for n in range(n_max+1)\n    for m in range(-n, n+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.nmpm_index-Tuple{Any, Any, Any}","page":"Utilities","title":"SphericalFunctions.nmpm_index","text":"Return flat index into arrray of [n, mp, m]\n\nAssumes array is ordered as\n\n[\n    [n, mp, m]\n    for n in range(n_max+1)\n    for mp in range(-n, n+1)\n    for m in range(-n, n+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia package for evaluating and transforming Wigner's ùîá matrices, and spin-weighted spherical harmonics (which includes the ordinary scalar spherical harmonics).  These functions are evaluated directly in terms of quaternions, as well as in the more standard forms of spherical coordinates and Euler angles.[1]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"These quantities are computed using recursion relations, which makes it possible to compute to very high ‚Ñì values.  Unlike direct evaluation of individual elements, which will generally cause overflow or underflow beyond ‚Ñì‚âà30 when using double precision, these recursion relations should be valid for far higher ‚Ñì values.  More precisely, Inf values appear starting at ‚Ñì=22 for Float16, ‚Ñì=183 for Float32, and ‚Ñì=1474 for Float64.  BigFloat also works, and presumably will not overflow for any ‚Ñì value that could reasonably fit into computer memory ‚Äî though it is far slower.  Also note that DoubleFloats will work, and achieve significantly greater accuracy (but no greater range) than Float64.  The results are accurate to roughly ‚Ñì times the precision of the input quaternion.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The conventions for this package are described in detail on this page.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note that numerous other packages cover some of these use cases, including FastTransforms.jl, FastSphericalHarmonics.jl, and this package.  However, I need support for higher-precision numbers ‚Äî even at the cost of some speed ‚Äî which is what this package provides.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Depth = 4","category":"page"},{"location":"#Function-list","page":"Introduction","title":"Function list","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following list contains the public functions inside the SphericalFunctions module.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [SphericalFunctions]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1]: Euler angles are quite generally a very poor choice for computing with rotations.  (The only context in which they may be preferred is when analytically integrating some analytically known functions.)  Almost universally, it is best to use quaternions when computing with rotations.  All the computations done within this package use quaternions; the user interfaces involving Euler angles essentially convert to/from quaternions.  While the calculations needed for those conversions would still need to be done if this package used Euler angles internally ‚Äî meaning that this approach is as efficient as any ‚Äî that work can be avoided entirely if you work with quaternions directly.","category":"page"}]
}
