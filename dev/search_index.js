var documenterSearchIndex = {"docs":
[{"location":"manual/#Calculators","page":"Basics","title":"Calculators","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"Typically, when calculating special functions, we will use recurrence relations along with some coefficients — which frequently requires significant setup processing.  That processing can be cached, so that the calculations themselves consist primarily of memory accesses and simple arithmetic.  For this reason, we use \"calculator\" objects, which will be constructed with some indication of the largest indices you expect to use.  The calculators can then be called repeatedly for specific values of the arguments, which will compute the function values for all (or some subset of) indices.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [Spherical.AssociatedLegendreFunction]\nPages   = [\"src/associated_legendre/calculator.jl\"]","category":"page"},{"location":"manual/#Spherical.AssociatedLegendreFunction.ALFcompute!-Union{Tuple{T}, Tuple{Vector{T}, Complex{T}, Int64, ALFRecursionCoefficients{T}}} where T<:Real","page":"Basics","title":"Spherical.AssociatedLegendreFunction.ALFcompute!","text":"ALFcompute(expiβ, nmax)\nALFcompute!(P̄, expiβ, nmax)\nALFcompute(expiβ, nmax, recursion_coefficients)\nALFcompute!(P̄, expiβ, nmax, recursion_coefficients)\n\nCompute the \"fully normalized\" Associated Legendre Functions up to some maximum n value nmax.\n\nThese functions can take a vector P̄, to store the data, stored in order of increasing m most rapidly varying and then increasing n.  If not supplied, P̄ will be constructed for you and returned.\n\nThe optional recursion_coefficients argument must be an ALFRecursionCoefficients, which stores various constant coefficients used in the recursion.  This object requires more than 3x the memory and more than 20x the time to compute a single P̄ vector without this argument, but passing it will typically speed up the calculation of each P̄ by a factor of 8x or so.  Thus, if you expect to compute P̄ more than a few times, it will take less time to pre-compute those factors, and pass them to this function.\n\nNote that the base real type will be inferred from the (complex) type of expiβ.  If present, the base types of P̄ and recursion_coefficients must agree.\n\n\n\n\n\n","category":"method"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [Spherical.WignerMatrices]\nPages   = [\"wigner_matrices/calculator.jl\", \"wigner_matrices/evaluate.jl\"]","category":"page"},{"location":"manual/#Spherical.WignerMatrices.D!-Tuple{Any, WignerMatrixCalculator, Quaternionic.Quaternion}","page":"Basics","title":"Spherical.WignerMatrices.D!","text":"D!(𝔇, w, R)\nD!(w, R)\n\nCompute Wigner's 𝔇 matrix\n\nParameters\n\n𝔇 : arraylike, optional     Array into which the 𝔇 values should be written.  It should be an array of     complex, with size self.Dsize.  If not present, the array will be     created.  In either case, the array will also be returned. workspace : optional     A working array like the one returned by Wigner.newworkspace().  If not     present, this object's default workspace will be used.  Note that it is not     safe to use the same workspace on multiple threads. R : Quaternion     Array to be interpreted as a quaternionic array (thus its final dimension     must have size 4), representing the rotations on which the 𝔇 matrix will be     evaluated.\n\nReturns\n\nD : array     This is a 1-dimensional array of complex; see below.\n\nSee Also\n\nH : Compute a portion of the H matrix d : Compute the full Wigner d matrix rotate : Avoid computing the full 𝔇 matrix and rotate modes directly evaluate : Avoid computing the full 𝔇 matrix and evaluate modes directly\n\nNotes\n\nThis function is the preferred method of computing the 𝔇 matrix for large ell values.  In particular, above ell≈32 standard formulas become completely unusable because of numerical instabilities and overflow.  This function uses stable recursion methods instead, and should be usable beyond ell≈1000.\n\nThis function computes 𝔇ˡₘₚ,ₘ(R).  The result is returned in a 1-dimensional array ordered as\n\n[\n    𝔇(ell, mp, m, R)\n    for ell in range(ell_max+1)\n    for mp in range(-min(ℓ, mp_max), min(ℓ, mp_max)+1)\n    for m in range(-ell, ell+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"manual/#Spherical.WignerMatrices.d!-Tuple{Any, WignerMatrixCalculator, Complex}","page":"Basics","title":"Spherical.WignerMatrices.d!","text":"Compute Wigner's d matrix dˡₘₚ,ₘ(β)\n\nParameters\n\nexpiβ : arraylike     Values of expi(i*β) on which to evaluate the d matrix. out : arraylike, optional     Array into which the d values should be written.  It should be an array of     floats, with size self.dsize.  If not present, the array will be created.     In either case, the array will also be returned. workspace : arraylike, optional     A working array like the one returned by Wigner.newworkspace().  If not     present, this object's default workspace will be used.  Note that it is not     safe to use the same workspace on multiple threads.\n\nReturns\n\nd : array     This is a 1-dimensional array of floats; see below.\n\nSee Also\n\nH : Compute a portion of the H matrix D : Compute the full Wigner 𝔇 matrix rotate : Avoid computing the full 𝔇 matrix and rotate modes directly evaluate : Avoid computing the full 𝔇 matrix and evaluate modes directly\n\nNotes\n\nThis function is the preferred method of computing the d matrix for large ell values.  In particular, above ell≈32 standard formulas become completely unusable because of numerical instabilities and overflow.  This function uses stable recursion methods instead, and should be usable beyond ell≈1000.\n\nThe result is returned in a 1-dimensional array ordered as\n\n[\n    d(ell, mp, m, β)\n    for ell in range(ell_max+1)\n    for mp in range(-min(ℓ, mp_max), min(ℓ, mp_max)+1)\n    for m in range(-ell, ell+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"manual/#Spherical.WignerMatrices.sign-Tuple{Any}","page":"Basics","title":"Spherical.WignerMatrices.sign","text":"Return sign of input, with sign(0)=1\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"While not usually the star of the show, the following utilities can be quite helpful for actually using the rest of the code.","category":"page"},{"location":"utilities/#Complex-powers","page":"Utilities","title":"Complex powers","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"One common task we find when working with spherical functions is the computation of a range of integer powers of some complex number — so much so that it can be best to pre-compute the powers and cache their values.  While a naive approach is generally quite accurate, and reasonably fast, we can do a little better with a specialized routine.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [Spherical]\nPages   = [\"complex_powers.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#Spherical.complex_powers!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 1}, Complex{T}}} where T<:Real","page":"Utilities","title":"Spherical.complex_powers!","text":"complex_powers!(zpowers, z)\n\nCompute integer powers of z from z^0 through z^m, recursively, where m is one less than the length of the input zpowers vector.\n\nNote that z is assumed to be normalized, with complex amplitude approximately 1.\n\nSee also: complex_powers\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Spherical.complex_powers-Union{Tuple{T}, Tuple{Complex{T}, Int64}} where T<:Real","page":"Utilities","title":"Spherical.complex_powers","text":"complex_powers(z, m)\n\nCompute integer powers of z from z^0 through z^m, recursively.\n\nNote that z is assumed to be normalized, with complex amplitude approximately 1.\n\nThis algorithm is mostly due to Stoer and Bulirsch in \"Introduction to Numerical Analysis\" (page 24) — with a little help from de Moivre's formula, which is essentially exp(iθ)ⁿ = exp(inθ), as well as my own alterations to deal with different behaviors in different quadrants.\n\nThere isn't usually a huge advantage to using this specialized function.  If you just need a particular power, it will generally be far more efficient and just as accurate to compute either exp(iθ)ⁿ or exp(inθ) explicitly.  However, if you need all powers from 0 to m, this function is about 10 or 5 times faster than those options, respectively, for large m.  Like those options, this function is numerically stable, in the sense that its errors are usually smaller than m times the error from machine-precision errors in the input argument — or at worst about 50% larger, which occurs as the phase approaches multiples of π/2.\n\nSee also: complex_powers!\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Quadrature-weights","page":"Utilities","title":"Quadrature weights","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [Spherical]\nPages   = [\"weights.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#Spherical.clenshaw_curtis-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"Utilities","title":"Spherical.clenshaw_curtis","text":"clenshaw_curtis(n, [T])\n\nCompute weights for the Clenshaw-Curtis rule, wₖᶜᶜ for k ∈ 0:n.\n\nThis function uses Waldvogel's method.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Spherical.fejer1-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"Utilities","title":"Spherical.fejer1","text":"fejer1(n, [T])\n\nCompute weights for Fejér's first rule, wₖᶠ¹ for k ∈ 0:n\n\nThis function uses Waldvogel's method.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Spherical.fejer2-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"Utilities","title":"Spherical.fejer2","text":"fejer2(n, [T])\n\nCompute weights for Fejér's second rule, wₖᶠ² for k ∈ 1:n-1.\n\nThis function uses Waldvogel's method. However, contrary to Waldvogel's notation, this routine does not return the weight corresponding to the ϑ=0 or π nodes, which both have weight 0.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Y-data","page":"Utilities","title":"Y data","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"By Y data, we mean anything indexed like Y_ell m modes.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [Spherical]\nPages   = [\"indexing.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#Spherical.Yindex","page":"Utilities","title":"Spherical.Yindex","text":"Yindex(ℓ, m, ℓₘᵢₙ=0)\n\nCompute index into array of mode weights\n\nParameters\n\nℓ : int     Integer satisfying ℓₘᵢₙ <= ℓ <= ℓₘₐₓ m : int     Integer satisfying -ℓ <= m <= ℓ ℓₘᵢₙ : int, optional     Integer satisfying 0 <= ℓₘᵢₙ.  Defaults to 0.\n\nReturns\n\ni : int     Index of a particular element of the mode-weight array as described below\n\nSee Also\n\nYsize : Total size of array of mode weights Yrange : Array of (ℓ, m) indices corresponding to this array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ℓ, m)\n    for ℓ in range(ℓₘᵢₙ, ℓₘₐₓ+1)\n    for m in range(-ℓ, ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Spherical.Yrange-Tuple{Any, Any}","page":"Utilities","title":"Spherical.Yrange","text":"Yrange(ℓₘᵢₙ, ℓₘₐₓ)\n\nCreate an array of (ℓ, m) indices as in Y array\n\nParameters\n\nℓₘᵢₙ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ ℓₘₐₓ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ\n\nReturns\n\ni : int     Total size of array of mode weights arranged as described below\n\nSee Also\n\nYsize : Total size of array of mode weights Yindex : Index of a particular element of the mode weight array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ℓ, m)\n    for ℓ in range(ℓₘᵢₙ, ℓₘₐₓ+1)\n    for m in range(-ℓ, ℓ+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Spherical.Ysize-Tuple{Any, Any}","page":"Utilities","title":"Spherical.Ysize","text":"Ysize(ℓₘᵢₙ, ℓₘₐₓ)\n\nCompute total size of array of mode weights\n\nParameters\n\nℓₘᵢₙ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ ℓₘₐₓ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ\n\nReturns\n\ni : int     Total size of array of mode weights arranged as described below\n\nSee Also\n\nYrange : Array of (ℓ, m) indices corresponding to this array Yindex : Index of a particular element of the mode weight array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ℓ, m)\n    for ℓ in range(ℓₘᵢₙ, ℓₘₐₓ+1)\n    for m in range(-ℓ, ℓ+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Spherical.theta_phi-Tuple{Any, Any}","page":"Utilities","title":"Spherical.theta_phi","text":"Construct (theta, phi) grid\n\nThis grid is in the order expected by spinsfast\n\nParameters\n\nntheta : int     Number of points in the theta direction nphi : int     Number of points in the phi direction\n\nReturns\n\nthetaphigrid : ndarray     Array of pairs of floats giving the respective [theta, phi] pairs.  The     shape of this array is (ntheta, nphi, 2).\n\nNotes\n\nThe array looks like\n\n[\n    [θ, ϕ]\n    for ϕ ∈ [0, 2π)\n    for θ ∈ [0, π]\n]\n\n(note the open and closed endpoints, respectively), where ϕ and θ are uniformly sampled in their respective ranges.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#D-data","page":"Utilities","title":"D data","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"By D data, we mean anything indexed like Wigner's mathfrakD matrices, or special subsets of them, like the H matrices.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [Spherical.WignerMatrices]\nPages   = [\"wigner_matrices/indexing.jl\", \"wigner_matrices/Hrecursions.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#Spherical.WignerMatrices.WignerDindex","page":"Utilities","title":"Spherical.WignerMatrices.WignerDindex","text":"WignerDindex(ℓ, m′, m, ℓₘᵢₙ=0, m′ₘₐₓ=-1)\n\nCompute index into Wigner 𝔇 matrix\n\nParameters\n\nℓ : int     Integer satisfying ℓₘᵢₙ <= ℓ <= ℓₘₐₓ m′ : int     Integer satisfying -min(ℓₘₐₓ, m′ₘₐₓ) <= m′ <= min(ℓₘₐₓ, m′ₘₐₓ) m : int     Integer satisfying -ℓ <= m <= ℓ ℓₘᵢₙ : int, optional     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ.  Defaults to 0. m′ₘₐₓ : int, optional     Integer satisfying 0 <= m′ₘₐₓ.  Defaults to ℓ.\n\nReturns\n\ni : int     Index into Wigner 𝔇 matrix arranged as described below\n\nSee Also\n\nWignerDsize : Total size of the 𝔇 matrix WignerDrange : Array of (ℓ, m', m) indices corresponding to the 𝔇 matrix\n\nNotes\n\nThis assumes that the Wigner 𝔇 matrix is arranged as\n\n[\n    𝔇(ℓ, m′, m)\n    for ℓ in range(ℓₘᵢₙ, ℓₘₐₓ+1)\n    for m′ in range(-min(ℓ, m′ₘₐₓ), min(ℓ, m′ₘₐₓ)+1)\n    for m in range(-ℓ, ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Spherical.WignerMatrices.WignerDrange","page":"Utilities","title":"Spherical.WignerMatrices.WignerDrange","text":"WignerDrange(ℓₘᵢₙ, m′ₘₐₓ, ℓₘₐₓ=-1)\n\nCreate an array of (ℓ, m', m) indices as in 𝔇 array\n\nParameters\n\nℓₘᵢₙ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ m′ₘₐₓ : int, optional     Integer satisfying 0 <= m′ₘₐₓ.  Default is ℓₘₐₓ. ℓₘₐₓ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ\n\nSee Also\n\nWignerDsize : Total size of 𝔇 array WignerDindex : Index inside these wedges\n\nNotes\n\nThis assumes that the Wigner 𝔇 matrix is arranged as\n\n[\n    𝔇(ℓ, m′, m)\n    for ℓ in range(ℓₘᵢₙ, ℓₘₐₓ+1)\n    for m′ in range(-min(ℓ, m′ₘₐₓ), min(ℓ, m′ₘₐₓ)+1)\n    for m in range(-ℓ, ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Spherical.WignerMatrices.WignerDsize","page":"Utilities","title":"Spherical.WignerMatrices.WignerDsize","text":"WignerDsize(ℓₘᵢₙ, m′ₘₐₓ, ℓₘₐₓ=-1)\n\nCompute total size of Wigner 𝔇 matrix\n\nParameters\n\nℓₘᵢₙ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ m′ₘₐₓ : int, optional     Integer satisfying 0 <= m′ₘₐₓ.  Defaults to ℓₘₐₓ. ℓₘₐₓ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ\n\nReturns\n\ni : int     Total size of Wigner 𝔇 matrix arranged as described below\n\nSee Also\n\nWignerDrange : Array of (ℓ, m', m) indices corresponding to the 𝔇 matrix WignerDindex : Index of a particular element of the 𝔇 matrix\n\nNotes\n\nThis assumes that the Wigner 𝔇 matrix is arranged as\n\n[\n    𝔇(ℓ, m′, m)\n    for ℓ in range(ℓₘᵢₙ, ℓₘₐₓ+1)\n    for m′ in range(-min(ℓ, m′ₘₐₓ), min(ℓ, m′ₘₐₓ)+1)\n    for m in range(-ℓ, ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Spherical.WignerMatrices.WignerHindex","page":"Utilities","title":"Spherical.WignerMatrices.WignerHindex","text":"WignerHindex(ℓ, m′, m, m′ₘₐₓ)\n\nIndex to \"wedge\" arrays\n\nParameters\n\nℓ : int m′ : int m : int m′ₘₐₓ : int, optional     If nothing, it is assumed to be at least ℓ\n\nSee Also\n\nWignerHsize : Total size of wedge array WignerHrange : Array of (ℓ, m', m) indices corresponding to this wedge\n\nNotes\n\nHere, it is assumed that only data with m≥|m'| are stored, and only corresponding values are passed.  We also assume |m|≤ℓ and |m'|≤ℓ.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(ℓ, m′, m) for ℓ in range(ℓₘₐₓ+1)\n    for m′ in range(-min(ℓ, m′ₘₐₓ), min(ℓ, m′ₘₐₓ)+1)\n    for m in range(abs(m′), ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Spherical.WignerMatrices.WignerHrange","page":"Utilities","title":"Spherical.WignerMatrices.WignerHrange","text":"WignerHrange(m′ₘₐₓ, ℓₘₐₓ=-1)\n\nCreate an array of (ℓ, m', m) indices as in H array\n\nParameters\n\nℓₘₐₓ : int m′ₘₐₓ : int, optional     If nothing, it is assumed to be at least ℓ\n\nSee Also\n\nWignerHsize : Total size of wedge array WignerHindex : Index inside these wedges\n\nNotes\n\nHere, it is assumed that only data with m≥|m'| are stored, and only corresponding values are passed.  We also assume |m|≤ℓ and |m'|≤ℓ.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(ℓ, m′, m) for ℓ in range(ℓₘₐₓ+1)\n    for m′ in range(-min(ℓ, m′ₘₐₓ), min(ℓ, m′ₘₐₓ)+1)\n    for m in range(abs(m′), ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Spherical.WignerMatrices.WignerHsize","page":"Utilities","title":"Spherical.WignerMatrices.WignerHsize","text":"WignerHsize(m′ₘₐₓ, ℓₘₐₓ=-2)\n\nTotal size of array of wedges of width m′ₘₐₓ up to ℓₘₐₓ\n\nParameters\n\nℓₘₐₓ : int m′ₘₐₓ : int, optional     If nothing, it is assumed to be at least ℓ\n\nSee Also\n\nWignerHrange : Array of (ℓ, m', m) indices corresponding to this wedge WignerHindex : Index inside these wedges\n\nNotes\n\nHere, it is assumed that only data with m≥|m'| are stored, and only corresponding values are passed.  We also assume |m|≤ℓ and |m'|≤ℓ.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(ℓ, m′, m) for ℓ in range(ℓₘₐₓ+1)\n    for m′ in range(-min(ℓ, m′ₘₐₓ), min(ℓ, m′ₘₐₓ)+1)\n    for m in range(abs(m′), ℓ+1)\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Spherical.WignerMatrices.H!-Tuple{WignerMatrixCalculator, Complex}","page":"Utilities","title":"Spherical.WignerMatrices.H!","text":"H!(w, expiβ)\n\nCompute (a quarter of) the H matrix\n\nWARNING: The returned array will be a view into the workspace variable (see below for an explanation of that).  If you need to call this function again using the same workspace before extracting all information from the first call, you should use numpy.copy to make a separate copy of the result.\n\nParameters\n\nexpiβ : array_like     Value of exp(i*β) on which to evaluate the H matrix.\n\nReturns\n\nHwedge : array     This is a 1-dimensional array of floats; see below. workspace : arraylike, optional     A working array like the one returned by Wigner.newworkspace().  If not     present, this object's default workspace will be used.  Note that it is not     safe to use the same workspace on multiple threads.  Also see the WARNING     above.\n\nSee Also\n\nd : Compute the full Wigner d matrix D : Compute the full Wigner 𝔇 matrix rotate : Avoid computing the full 𝔇 matrix and rotate modes directly evaluate : Avoid computing the full 𝔇 matrix and evaluate modes directly\n\nNotes\n\nH is related to Wigner's (small) d via\n\ndₗⁿᵐ = ϵₙ ϵ₋ₘ Hₗⁿᵐ,\n\nwhere\n\n     ⎧ 1 for k≤0\nϵₖ = ⎨\n     ⎩ (-1)ᵏ for k>0\n\nH has various advantages over d, including the fact that it can be efficiently and robustly valculated via recurrence relations, and the following symmetry relations:\n\nH^{m', m}_n(β) = H^{m, m'}_n(β)\nH^{m', m}_n(β) = H^{-m', -m}_n(β)\nH^{m', m}_n(β) = (-1)^{n+m+m'} H^{-m', m}_n(π - β)\nH^{m', m}_n(β) = (-1)^{m+m'} H^{m', m}_n(-β)\n\nBecause of these symmetries, we only need to evaluate at most 1/4 of all the elements.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Spherical.WignerMatrices.nabsm_index-Tuple{Any, Any}","page":"Utilities","title":"Spherical.WignerMatrices.nabsm_index","text":"Return flat index into arrray of [n, abs(m)] pairs\n\nAssumes array is ordered as\n\n[\n    [n, m]\n    for n in range(n_max+1)\n    for m in range(n+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Spherical.WignerMatrices.nm_index-Tuple{Any, Any}","page":"Utilities","title":"Spherical.WignerMatrices.nm_index","text":"Return flat index into arrray of [n, m] pairs.\n\nAssumes array is ordered as\n\n[\n    [n, m]\n    for n in range(n_max+1)\n    for m in range(-n, n+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Spherical.WignerMatrices.nmpm_index-Tuple{Any, Any, Any}","page":"Utilities","title":"Spherical.WignerMatrices.nmpm_index","text":"Return flat index into arrray of [n, mp, m]\n\nAssumes array is ordered as\n\n[\n    [n, mp, m]\n    for n in range(n_max+1)\n    for mp in range(-n, n+1)\n    for m in range(-n, n+1)\n]\n\n\n\n\n\n","category":"method"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia package for evaluating and transforming Wigner's 𝔇 matrices, Wigner's 3-j symbols, and spin-weighted (and scalar) spherical harmonics.  These functions are evaluated directly in terms of quaternions, as well as in the more standard forms of spherical coordinates and Euler angles.[1]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"These quantities are computed using recursion relations, which makes it possible to compute to very high ℓ values.  Unlike direct evaluation of individual elements, which will generally cause overflow or underflow beyond ℓ≈30 when using double precision, these recursion relations should be valid for far higher ℓ values.  More precisely, Inf values appear starting at ℓ=22 for Float16, ℓ=183 for Float32, and ℓ=1474 for Float64.  BigFloat also works, and presumably will not overflow for any ℓ value that could reasonably fit into computer memory — though it is far slower.  Also note that DoubleFloats will work, and achieve significantly greater accuracy (but no greater range) than Float64.  The results are accurate to roughly ℓ times the precision of the input quaternion.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The conventions for this package are described in detail on this page.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note that numerous other packages cover some of these use cases, including FastTransforms.jl, FastSphericalHarmonics.jl, and this package.  However, I need support for higher-precision numbers — even at the cost of speed — which is what this package provides.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Depth = 4","category":"page"},{"location":"#Function-list","page":"Introduction","title":"Function list","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following list contains the public functions inside the Spherical module.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [Spherical]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1]: Euler angles are pretty much the worst things ever and it makes me feel bad even supporting them.  Quaternions are faster, more accurate, basically free of singularities, more intuitive, and generally easier to understand.  You can work entirely without Euler angles (I certainly do).  You absolutely never need them.  But if you're so old fashioned that you really can't give them up, they are fully supported.","category":"page"}]
}
