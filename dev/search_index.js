var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"The most important routine in this package is the computation of the 𝔇 matrices — or more specifically, of terms proportional to parts of the 𝔇 matrices.  This mostly follows the treatment of Gumerov and Duraiswami [8] (with minor modifications to account for errors in their presentation, as described here).  To seed the recursions they present, we also need to calculate the associated Legendre functions.  This is now done using the \"fully normalized column-wise recurrence formula\" (fnCWF) given by Eqs. (12)—(14) of Xing et al. [10].  This improves significantly over the older implementation using the \"modified forward row method\" of Holmes and Featherstone [12], for which the results would fail to be finite starting at ℓ=22 for Float16, ℓ=183 for Float32, and ℓ=1474 for Float64. Another approach that was never precisely implemented in this package was due to Fukushima [13], who showed that using \"X-numbers\", wherein the exponent is stored as a separate integer, (implemented in this package) in the core of the recursion could increase the range to ℓ≈2³².  Xing et al. showed that Fukushima's results exhibited increased error for certain angles, whereas their Eqs. (12)—(14) could be used directly to obtain results with greater accuracy for those certain angles, and comparable accuracy for other angles.","category":"page"},{"location":"references/","page":"References","title":"References","text":"The other major functionality of this package is map2salm / salm2map, which decomposes function values on regular grids into mode weights (coefficients), and vice versa.  The approach used here is taken from Reinecke and Seljebotn [3], with weights based on the method by Waldvogel [6].  However, this interface has been superseded by the SSHT object, which implements several approaches, including the Reinecke-Seljebotn-Waldvogel method, as well as the optimal-dimensionality method due to Elahi et al. [2], as well as a new unpublished optimal-dimensionality method I (Mike Boyle) created.","category":"page"},{"location":"references/#Bibliography","page":"References","title":"Bibliography","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"M. Boyle. How should spin-weighted spherical functions be defined? Journal of Mathematical Physics 57 (2016), arXiv:1604.08140 [gr-qc].\n\n\n\nU. Elahi, Z. Khalid, R. A. Kennedy and J. D. McEwen. An Optimal-Dimensionality Sampling for Spin-s Functions on the Sphere. IEEE Signal Processing Letters 25, 1470–1474 (2018), arXiv:1809.01321 [astro-ph.IM].\n\n\n\nM. Reinecke and D. S. Seljebotn. Libsharp—spherical harmonic transforms revisited. Astronomy & Astrophysics 554, A112 (2013), arXiv:1303.4945 [physics.comp-ph].\n\n\n\nE. B. Saff and A. B. Kuijlaars. Distributing many points on a sphere. The Mathematical Intelligencer 19, 5–11 (1997).\n\n\n\nJ. S. Brauchart and P. J. Grabner. Distributing many points on spheres: Minimal energy and designs. Journal of Complexity 31, 293–326 (2015).\n\n\n\nJ. Waldvogel. Fast Construction of the Fejér and Clenshaw–Curtis Quadrature Rules. BIT Numerical Mathematics 46, 195–202 (2006).\n\n\n\nE. T. Newman and R. Penrose. Note on the Bondi-Metzner-Sachs Group. Journal of Mathematical Physics 7, 863–870 (1966).\n\n\n\nN. A. Gumerov and R. Duraiswami. Recursive Computation of Spherical Harmonic Rotation Coefficients of Large Degree. In: Excursions in Harmonic Analysis, Volume 3 (Springer International Publishing, 2015); pp. 105–141, arXiv:1403.7698 [math.NA].\n\n\n\nP. J. Kostelec and D. N. Rockmore. FFTs on the Rotation Group. Journal of Fourier Analysis and Applications 14, 145–179 (2008).\n\n\n\nZ. Xing, S. Li, M. Tian, D. Fan and C. Zhang. Numerical experiments on column-wise recurrence formula to compute fully                   normalized associated Legendre functions of ultra-high degree and order. Journal of Geodesy 94 (2019).\n\n\n\nJ. D. McEwen and Y. Wiaux. A Novel Sampling Theorem on the Sphere. IEEE Transactions on Signal Processing 59, 5876–5887 (2011), arXiv:1110.6298 [cs.IT].\n\n\n\nS. A. Holmes and W. E. Featherstone. A unified approach to the Clenshaw summation and the recursive computation of very                   high degree and order normalised associated Legendre functions. Journal of Geodesy 76, 279–299 (2002).\n\n\n\nT. Fukushima. Numerical computation of spherical harmonics of arbitrary degree and order by                   extending exponent of floating point numbers. Journal of Geodesy 86, 271–285 (2011).\n\n\n\nP. Ajith, M. Boyle, D. A. Brown, S. Fairhurst, M. Hannam, I. Hinder, S. Husa, B. Krishnan, R. A. Mercer, F. Ohme, C. D. Ott, J. S. Read, L. Santamaria and J. T. Whelan. Data formats for numerical relativity waves (2007), arXiv:0709.0093 [gr-qc].\n\n\n\nE. U. Condon and G. H. Shortley. The Theory Of Atomic Spectra (Cambridge University Press, London, 1935).\n\n\n\nJ. N. Goldberg, A. J. Macfarlane, E. T. Newman, F. Rohrlich and E. C. Sudarshan. Spin‐s Spherical Harmonics and ð. Journal of Mathematical Physics 8, 2155–2161 (1967).\n\n\n\nJ. J. Sakurai. Modern Quantum Mechanics, revised Edition (Addison Wesley, New York, 1994).\n\n\n\nG. F. Torres Del Castillo. 3-D Spinors, Spin-Weighted Functions and their Applications, revised Edition (Birkhäuser, Boston, MA, 2003).\n\n\n\nE. P. Wigner. Group Theory and Its Application to the Quantum Mechanics of Atomic Spectra (Academic Press, New York, NY, 1959).\n\n\n\n","category":"page"},{"location":"wigner_matrices/#Wigner's-𝔇-and-d-matrices","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"","category":"section"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"Wigner's 𝔇 matrices — and to a lesser extent, the related d matrices — are extremely important in the theory of rotations.  Each element is, itself, a special function of the rotation group: in particular, an eigenfunction of the left- and right-Lie derivatives, and thus a spin-weighted spherical function.  Collectively, they describe how spin-weighted spherical functions transform under rotation.  But their accurate and efficient computation is surprisingly subtle.  This package implements the current state-of-the-art techniques for their fast and accurate computation, based on the H recursion.","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"The actual computations can be done with the D_matrices function:","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"using Quaternionic\nusing SphericalFunctions\n\nR = randn(RotorF64)\nℓₘₐₓ = 8\n𝔇 = D_matrices(R, ℓₘₐₓ)","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"However, the matrices can take up a lot of memory.  So for maximum efficiency when calling this function repeatedly with different R values, it is best to pre-allocate the necessary memory with the D_prep function, and the pass that in as an argument to D_matrices!:","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"D_storage = D_prep(ℓₘₐₓ)\n𝔇 = D_matrices!(D_storage, R)","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"(Beware that, as noted in the documentation for D_matrices!, the output 𝔇 is just a reference to part of the D_storage object, so you should not reuse D_storage until you have copied or otherwise finished using 𝔇.)","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"The output 𝔇 is a (linear!) vector of Complex numbers with the same base type as R.  The ordering of the elements is described in the documentation for D_matrices.  It is also possible to efficiently view slices of this vector as a series of individual matrices using a D_iterator:","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"for (ℓ, Dˡ) in zip(0:ℓₘₐₓ, D_iterator(𝔇, ℓₘₐₓ))\n    # Do something with the matrix Dˡ[ℓ+m′+1, ℓ+m+1]\nend","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"For the d matrices, we have almost the same interface, except that instead of the input quaternion R we only need the angle β (or its complex angle expiβ, which can be computed directly in some cases), and the output is real-valued:","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"using Quaternionic\nusing SphericalFunctions\n\nβ = π * rand(Float64)\nℓₘₐₓ = 8\nd = d_matrices(β, ℓₘₐₓ)","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"Again, for repeated calls, it is best to pre-allocate storage:","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"d_storage = d_prep(ℓₘₐₓ)\nd = d_matrices!(d_storage, β)","category":"page"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"The output d is a vector of numbers of the same type as β, ordered in the same way as the output of D_matrices.  And similarly, we can iterate over the individual matrices using a d_iterator.","category":"page"},{"location":"wigner_matrices/#Docstrings","page":"Wigner's 𝔇 and d matrices","title":"Docstrings","text":"","category":"section"},{"location":"wigner_matrices/","page":"Wigner's 𝔇 and d matrices","title":"Wigner's 𝔇 and d matrices","text":"D_matrices\nD_matrices!\nD_prep\nD_iterator\nd_matrices\nd_matrices!\nd_prep\nd_iterator","category":"page"},{"location":"wigner_matrices/#SphericalFunctions.D_matrices","page":"Wigner's 𝔇 and d matrices","title":"SphericalFunctions.D_matrices","text":"D_matrices(R, ℓₘₐₓ)\nD_matrices(α, β, γ, ℓₘₐₓ)\n\nCompute Wigner's 𝔇 matrices mathfrakD^(ell)_mm(beta) for all ell leq ell_mathrmmax.\n\nSee D_matrices! for details about the input and output values.\n\nThis function only appropriate when you need to evaluate the matrices for a single value of R or α, β, γ because it allocates large arrays and performs many calculations that could be reused.  If you need to evaluate the matrices for many values of R or α, β, γ, you should pre-allocate the storage with D_prep, and then call D_matrices! with the result instead.\n\n\n\n\n\n","category":"function"},{"location":"wigner_matrices/#SphericalFunctions.D_matrices!","page":"Wigner's 𝔇 and d matrices","title":"SphericalFunctions.D_matrices!","text":"D_matrices!(D_storage, R)\nD_matrices!(D_storage, α, β, γ)\nD_matrices!(D, R, ℓₘₐₓ)\nD_matrices!(D, α, β, γ, ℓₘₐₓ)\n\nCompute Wigner's 𝔇 matrices mathfrakD^(ell)_mm(beta) for all ell leq ell_mathrmmax.\n\nIn all cases, the result is returned in a 1-dimensional array ordered as\n\n[\n    𝔇ˡₘₚ,ₘ(R)\n    for ℓ ∈ 0:ℓₘₐₓ\n    for mp ∈ -ℓ:ℓ\n    for m ∈ -ℓ:ℓ\n]\n\nWhen the first argument is D, it will be modified, so it must be at least as large as that array. When the first argument is D_storage, it should be the quantity returned by D_prep, and the result will be written into the D field of that tuple.  Both of these options — especially the latter — reduce the number of allocations needed on each call to the corresponding functions, which should increase the speed significantly.  Note that the D or D_storage arguments must have types compatible with the type of R or α, β, γ.\n\nwarn: Warn\nWhen using the D_storage argument (which is recommended), the returned quantity D will be an alias of D_storage[1].  If you want to retain that data after the next call to D_matrices!, you should copy it with copy(D).\n\nThe α, β, γ arguments are Euler angles as described in the documentation of Quaternionic.from_euler_angles.\n\nSee also D_matrices for a simpler function call when you only need to evaluate the matrices for a single value of R or α, β, γ.\n\nExamples\n\nusing Quaternionic, SphericalFunctions\nℓₘₐₓ = 8\nT = Float64\nR = Rotor{T}(1, 2, 3, 4)  # Will be normalized automatically\nD_storage = D_prep(ℓₘₐₓ, T)\nD = D_matrices!(D_storage, R)\n\n\n\n\n\n","category":"function"},{"location":"wigner_matrices/#SphericalFunctions.D_prep","page":"Wigner's 𝔇 and d matrices","title":"SphericalFunctions.D_prep","text":"D_prep(ℓₘₐₓ, [T=Float64])\n\nConstruct storage space and pre-compute recursion coefficients to compute Wigner's mathfrakD matrix in place.\n\nThis returns the D_storage arguments needed by D_matrices!.\n\n\n\n\n\n","category":"function"},{"location":"wigner_matrices/#SphericalFunctions.D_iterator","page":"Wigner's 𝔇 and d matrices","title":"SphericalFunctions.D_iterator","text":"D_iterator(D, ℓₘₐₓ, [ℓₘᵢₙ])\n\nConstruct an Iterator that returns sub-matrices of D, each of which consists of elements (ℓ-ℓ-ℓ) through (ℓℓℓ), for ℓ from ℓₘᵢₙ through ℓₘₐₓ.  By default, ℓₘᵢₙ is 0.\n\ndanger: Inconsistent behavior\nThis iterator mistakenly returns the transpose of the result implied by this documentation.  As a result, a warning is issued every time this function is called. Rather than actually fixing this bug in this minor/patch version — which would be a breaking change — this is a final release in this major version of the package to notify users of this function (and d_iterator) that there is a problem.  The next major version of the package will likely change the actual behavior to the one implied by this docstring.  To quiet these warnings, you can use Dit = with_logger(NullLogger()) do D_iterator(...) end.\n\nNote that the returned objects are views into the original D data — meaning that you may alter their values.\n\nBecause the result is a matrix restricted to a particular ℓ value, you can index the (ℓ m m) element as [ℓ+m′+1, ℓ+m+1].  For example, you might use this as something like\n\nfor (ℓ, Dˡ) in zip(ℓₘᵢₙ:ℓₘₐₓ, D_iterator(D, ℓₘₐₓ))\n    for m′ in -ℓ:ℓ\n        for m in -ℓ:ℓ\n            Dˡ[ℓ+m′+1, ℓ+m+1]  # ... do something with Dˡ\n        end\n    end\nend\n\nAlso note that no bounds checking is done, either at instantiation time or during iteration. You are responsible for ensuring that the size of D and the values of ℓₘₐₓ and ℓₘᵢₙ make sense.\n\n\n\n\n\n","category":"type"},{"location":"wigner_matrices/#SphericalFunctions.d_matrices","page":"Wigner's 𝔇 and d matrices","title":"SphericalFunctions.d_matrices","text":"d_matrices(β, ℓₘₐₓ)\nd_matrices(expiβ, ℓₘₐₓ)\n\nCompute Wigner's d^(ell) matrices with elements d^(ell)_mm(beta) for all ell leq ell_mathrmmax.  The d matrices are sometimes called the \"reduced\" Wigner matrices, in contrast to the full mathfrakD matrices.\n\nSee d_matrices! for details about the input and output values.\n\nThis function only appropriate when you need to evaluate the matrices for a single value of β or expiβ because it allocates large arrays and performs many calculations that could be reused.  If you need to evaluate the matrices for many values of β or expiβ, you should pre-allocate the storage with d_prep, and then call d_matrices! with the result instead.\n\n\n\n\n\n","category":"function"},{"location":"wigner_matrices/#SphericalFunctions.d_matrices!","page":"Wigner's 𝔇 and d matrices","title":"SphericalFunctions.d_matrices!","text":"d_matrices!(d_storage, β)\nd_matrices!(d_storage, expiβ)\nd_matrices!(d, β, ℓₘₐₓ)\nd_matrices!(d, expiβ, ℓₘₐₓ)\n\nCompute Wigner's d^(ell) matrices with elements d^(ell)_mm(beta) for all ell leq ell_mathrmmax.  The d matrices are sometimes called the \"reduced\" Wigner matrices, in contrast to the full mathfrakD matrices.\n\nIn all cases, the result is returned in a 1-dimensional array ordered as\n\n[\n    dˡₘₚ,ₘ(β)\n    for ℓ ∈ 0:ℓₘₐₓ\n    for mp ∈ -ℓ:ℓ\n    for m ∈ -ℓ:ℓ\n]\n\nWhen the first argument is d, it will be modified, so it must be at least as large as that array.  When the first argument is d_storage, it should be the quantity returned by d_prep, and the result will be written into the d field of that tuple.  Both of these options — especially the latter — reduce the number of allocations needed on each call to the corresponding functions, which should increase the speed significantly.\n\nwarn: Warn\nWhen using the d_storage argument (which is recommended), the returned quantity d will be an alias of d_storage[1].  If you want to retain that data after the next call to d_matrices!, you should copy it with copy(d).\n\nSee also d_matrices for a simpler function call when you only need to evaluate the matrices for a single value of β or expiβ.\n\nExamples\n\nusing SphericalFunctions\nℓₘₐₓ = 8\nT = Float64\nβ = T(1)/8\nd_storage = d_prep(ℓₘₐₓ, T)\nd = d_matrices!(d_storage, β)\n\n\n\n\n\n","category":"function"},{"location":"wigner_matrices/#SphericalFunctions.d_prep","page":"Wigner's 𝔇 and d matrices","title":"SphericalFunctions.d_prep","text":"d_prep(ℓₘₐₓ, [T=Float64])\n\nConstruct space and pre-compute recursion coefficients to compute Wigner's d matrix in place.\n\nThis returns the d_storage arguments needed by d_matrices!.\n\n\n\n\n\n","category":"function"},{"location":"wigner_matrices/#SphericalFunctions.d_iterator","page":"Wigner's 𝔇 and d matrices","title":"SphericalFunctions.d_iterator","text":"d_iterator(d, ℓₘₐₓ, [ℓₘᵢₙ])\n\nConstruct an Iterator that returns sub-matrices of d, each of which consists of elements (ℓ-ℓ-ℓ) through (ℓℓℓ), for ℓ from ℓₘᵢₙ through ℓₘₐₓ.  By default, ℓₘᵢₙ is 0.\n\ndanger: Inconsistent behavior\nThis iterator mistakenly returns the transpose of the result implied by this documentation.  As a result, a warning is issued every time this function is called. Rather than actually fixing this bug in this minor/patch version — which would be a breaking change — this is a final release in this major version of the package to notify users of this function (and D_iterator) that there is a problem.  The next major version of the package will likely change the actual behavior to the one implied by this docstring.  To quiet these warnings, you can use Dit = with_logger(NullLogger()) do D_iterator(...) end.\n\nNote that the returned objects are views into the original d data — meaning that you may alter their values.\n\nBecause the result is a matrix restricted to a particular ℓ value, you can index the (ℓ m m) element as [ℓ+m′+1, ℓ+m+1].  For example, you might use this as something like\n\nfor (ℓ, dˡ) in zip(ℓₘᵢₙ:ℓₘₐₓ, d_iterator(d, ℓₘₐₓ))\n    for m′ in -ℓ:ℓ\n        for m in -ℓ:ℓ\n            dˡ[ℓ+m′+1, ℓ+m+1]  # ... do something with dˡ\n        end\n    end\nend\n\nAlso note that no bounds checking is done, either at instantiation time or during iteration. You are responsible for ensuring that the size of d and the values of ℓₘₐₓ and ℓₘᵢₙ make sense.\n\n\n\n\n\n","category":"type"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"While not usually the star of the show, the following utilities can be quite helpful for actually using the rest of the code.","category":"page"},{"location":"utilities/#Complex-powers","page":"Utilities","title":"Complex powers","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"One common task we find when working with spherical functions is the computation of a range of integer powers of some complex number — so much so that it can be best to pre-compute the powers and cache their values.  While a naive approach is generally quite accurate, and reasonably fast, we can do a little better with a specialized routine.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"complex_powers.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#SphericalFunctions.complex_powers!-Tuple{Any, Any}","page":"Utilities","title":"SphericalFunctions.complex_powers!","text":"complex_powers!(zpowers, z)\n\nCompute integer powers of z from z^0 through z^m, recursively, where m is one less than the length of the input zpowers vector.\n\nNote that z is assumed to be normalized, with complex amplitude approximately 1.\n\nSee also: complex_powers\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.complex_powers-Tuple{Any, Int64}","page":"Utilities","title":"SphericalFunctions.complex_powers","text":"complex_powers(z, m)\n\nCompute integer powers of z from z^0 through z^m, recursively.\n\nNote that z is assumed to be normalized, with complex amplitude approximately 1.\n\nThis algorithm is mostly due to Stoer and Bulirsch in \"Introduction to Numerical Analysis\" (page 24) — with a little help from de Moivre's formula, which is essentially exp(iθ)ⁿ = exp(inθ), as well as my own alterations to deal with different behaviors in different quadrants.\n\nThere isn't usually a huge advantage to using this specialized function.  If you just need a particular power, it will generally be far more efficient and just as accurate to compute either exp(iθ)ⁿ or exp(inθ) explicitly.  However, if you need all powers from 0 to m, this function is about 10 or 5 times faster than those options, respectively, for large m.  Like those options, this function is numerically stable, in the sense that its errors are usually smaller than m times the error from machine-precision errors in the input argument — or at worst about 50% larger, which occurs as the phase approaches multiples of π/2.\n\nSee also: complex_powers!\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Sizes-of-and-indexing-into-𝔇,-d,-and-Y-data","page":"Utilities","title":"Sizes of and indexing into 𝔇, d, and Y data","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"By Y data, we mean anything indexed like Y_ell m modes; by D data, we mean anything indexed like Wigner's mathfrakD matrices, or special subsets of them, like the H matrices.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"indexing.jl\", \"wigner_matrices/indexing.jl\", \"wigner_matrices/Hrecursions.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#SphericalFunctions.WignerDindex","page":"Utilities","title":"SphericalFunctions.WignerDindex","text":"WignerDindex(ℓ, m′, m, m′ₘₐₓ=ℓ)\n\nCompute index into Wigner 𝔇 matrix\n\nSee also WignerDrange and WignerDsize.\n\nNotes\n\nThis assumes that the Wigner 𝔇 matrix is arranged as\n\n[\n    𝔇(ℓ, m′, m)\n    for ℓ ∈ ℓₘᵢₙ:ℓₘₐₓ\n    for m′ ∈ -min(ℓ, m′ₘₐₓ):min(ℓ, m′ₘₐₓ)\n    for m ∈ -ℓ:ℓ\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerDrange","page":"Utilities","title":"SphericalFunctions.WignerDrange","text":"WignerDrange(ℓₘₐₓ, m′ₘₐₓ=ℓₘₐₓ)\n\nCreate an array of (ℓ, m', m) indices as in 𝔇 array\n\nSee also WignerDsize and WignerDindex.\n\nNotes\n\nThis assumes that the Wigner 𝔇 matrix is arranged as\n\n[\n    𝔇(ℓ, m′, m)\n    for ℓ ∈ ℓₘᵢₙ:ℓₘₐₓ\n    for m′ ∈ -min(ℓ, m′ₘₐₓ):min(ℓ, m′ₘₐₓ)\n    for m ∈ -ℓ:ℓ\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerDsize-Tuple{Any}","page":"Utilities","title":"SphericalFunctions.WignerDsize","text":"WignerDsize(ℓₘₐₓ, m′ₘₐₓ=ℓₘₐₓ)\n\nCompute total size of Wigner 𝔇 matrix\n\nSee also WignerDrange and WignerDindex.\n\nNotes\n\nThis assumes that the Wigner 𝔇 matrix is arranged as\n\n[\n    𝔇(ℓ, m′, m)\n    for ℓ ∈ ℓₘᵢₙ:ℓₘₐₓ\n    for m′ ∈ -min(ℓ, m′ₘₐₓ):min(ℓ, m′ₘₐₓ)\n    for m ∈ -ℓ:ℓ\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.WignerHindex","page":"Utilities","title":"SphericalFunctions.WignerHindex","text":"WignerHindex(ℓ, m′, m, m′ₘₐₓ)\n\nIndex to \"wedge\" arrays.\n\nSee also WignerHsize and WignerHrange.\n\nNotes\n\nHere, it is assumed that only data with m≥|m'| are stored, and only corresponding values are passed.  We also assume |m|≤ℓ and |m'|≤ℓ.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(ℓ, m′, m) for ℓ ∈ 0:ℓₘₐₓ\n    for m′ ∈ -min(ℓ, m′ₘₐₓ):min(ℓ, m′ₘₐₓ)\n    for m ∈ abs(m′):ℓ\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerHrange","page":"Utilities","title":"SphericalFunctions.WignerHrange","text":"WignerHrange(ℓₘₐₓ, m′ₘₐₓ=ℓₘₐₓ)\n\nCreate an array of (ℓ, m', m) indices as in H array\n\nSee also WignerHsize and WignerHindex\n\nNotes\n\nHere, it is assumed that only data with m≥|m'| are stored, and only corresponding values are passed.  We also assume |m|≤ℓ and |m'|≤ℓ.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(ℓ, m′, m) for ℓ ∈ 0:ℓₘₐₓ\n    for m′ ∈ -min(ℓ, m′ₘₐₓ):min(ℓ, m′ₘₐₓ)\n    for m ∈ abs(m′):ℓ\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.WignerHsize-Tuple{Any}","page":"Utilities","title":"SphericalFunctions.WignerHsize","text":"WignerHsize(ℓₘₐₓ, m′ₘₐₓ=ℓₘₐₓ)\n\nTotal size of array of wedges of width m′ₘₐₓ up to ℓₘₐₓ.  If m′ₘₐₓ is not given, it defaults to ℓₘₐₓ.\n\nSee also WignerHrange and WignerHindex.\n\nNotes\n\nHere, it is assumed that only data with m≥|m′| are stored, and only corresponding values are passed.  We also assume |m|≤ℓ and |m′|≤ℓ.  Neither of these are checked.  The wedge array that this function indexes is ordered as\n\n[\n    H(ℓ, m′, m) for ℓ ∈ 0:ℓₘₐₓ\n    for m′ ∈ -min(ℓ, m′ₘₐₓ):min(ℓ, m′ₘₐₓ)\n    for m ∈ abs(m′):ℓ\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.Yindex","page":"Utilities","title":"SphericalFunctions.Yindex","text":"Yindex(ℓ, m, ℓₘᵢₙ=0)\n\nCompute index into array of mode weights\n\nParameters\n\nℓ : int     Integer satisfying ℓₘᵢₙ <= ℓ <= ℓₘₐₓ m : int     Integer satisfying -ℓ <= m <= ℓ ℓₘᵢₙ : int, optional     Integer satisfying 0 <= ℓₘᵢₙ.  Defaults to 0.\n\nReturns\n\ni : int     Index of a particular element of the mode-weight array as described below\n\nSee Also\n\nYsize : Total size of array of mode weights Yrange : Array of (ℓ, m) indices corresponding to this array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ℓ, m)\n    for ℓ ∈ ℓₘᵢₙ:ℓₘₐₓ\n    for m ∈ -ℓ:ℓ\n]\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.Yrange-Tuple{Any}","page":"Utilities","title":"SphericalFunctions.Yrange","text":"Yrange(ℓₘᵢₙ, ℓₘₐₓ)\n\nCreate an array of (ℓ, m) indices as in Y array\n\nParameters\n\nℓₘᵢₙ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ ℓₘₐₓ : int     Integer satisfying 0 <= ℓₘᵢₙ <= ℓₘₐₓ\n\nReturns\n\ni : int     Total size of array of mode weights arranged as described below\n\nSee Also\n\nYsize : Total size of array of mode weights Yindex : Index of a particular element of the mode weight array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ℓ, m)\n    for ℓ ∈ ℓₘᵢₙ:ℓₘₐₓ\n    for m ∈ -ℓ:ℓ\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.Ysize-Tuple{Any}","page":"Utilities","title":"SphericalFunctions.Ysize","text":"Ysize(ℓₘₐₓ)\n\nCompute total size of array of mode weights\n\nSee Also\n\nYrange : Array of (ℓ, m) indices corresponding to this array Yindex : Index of a particular element of the mode weight array\n\nNotes\n\nThis assumes that the modes are arranged (with fixed s value) as\n\n[\n    Y(s, ℓ, m)\n    for ℓ ∈ ℓₘᵢₙ:ℓₘₐₓ\n    for m ∈ -ℓ:ℓ\n]\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions._WignerHindex-NTuple{4, Any}","page":"Utilities","title":"SphericalFunctions._WignerHindex","text":"WignerHindex(ℓ, m′, m, m′ₘₐₓ)\n\nHelper function for WignerHindex, with more constraints.\n\nThis function assumes that m ≥ |m′|.  The main WignerHindex function uses symmetries of the H array to account for cases that violate this assumption.  (But note that both that function and this one assume that |m| ≤ ℓ and |m′| ≤ ℓ.)\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.deduce_limits","page":"Utilities","title":"SphericalFunctions.deduce_limits","text":"deduce_limits(ysize, [ℓmin])\n\nDeduce the value of (ℓmin, ℓmax) that produces Y arrays of the given size.\n\nIf ℓmin is not given, it is assumed to be 0.  If it is set to nothing, the smallest possible value of ℓmin will be used.  However, note that this is not a well-posed problem; multiple combinations of (ℓmin, ℓmax) can give rise to Y arrays of the same size.\n\nSee also Ysize\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SphericalFunctions.phi_theta-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"Utilities","title":"SphericalFunctions.phi_theta","text":"phi_theta(Nϕ, Nθ, [T=Float64])\n\nConstruct (phi, theta) grid in order expected by this package.\n\nSee also theta_phi for the opposite ordering.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#SphericalFunctions.theta_phi-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"Utilities","title":"SphericalFunctions.theta_phi","text":"theta_phi(Nθ, Nϕ, [T=Float64])\n\nConstruct (theta, phi) grid in spinsfast order.\n\nNote that this order is different from the one assumed by this package; use phi_theta for the opposite ordering.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Combinatorics","page":"Utilities","title":"Combinatorics","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Spherical functions frequently involve binomial coefficients and similar terms, with arguments proportional to ℓ, which we aim to allow to be very large — of order 1,000 or more. Unfortunately, due to combinatorical explosions, this is frequently infeasible with naive methods.  Here, we collect any specialized methods that help us beat the limits.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [SphericalFunctions]\nPages   = [\"utils.jl\"]","category":"page"},{"location":"utilities/#SphericalFunctions.sqrtbinomial-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"Utilities","title":"SphericalFunctions.sqrtbinomial","text":"sqrtbinomial(n, k, [T])\n\nEvaluate the square-root of the binomial coefficient binomial(n,k) for large coefficients.\n\nOrdinarily, when n and k are standard Int arguments, the built-in binomial function will overflow around n=66, because it results in Ints.  We need much larger values. This function, which is based on a related one in SpecialFunctions.jl, returns reasonably accurate results up to n ≈ 1026 when k ≈ n/2 (which is the case of interest in many applications in this package).\n\nComputations are carried out (and returned) in type T, which defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Complete-function-list","page":"Complete function list","title":"Complete function list","text":"","category":"section"},{"location":"functions/","page":"Complete function list","title":"Complete function list","text":"The following list contains all documented functions inside the SphericalFunctions module.","category":"page"},{"location":"functions/","page":"Complete function list","title":"Complete function list","text":"Modules = [SphericalFunctions]","category":"page"},{"location":"transformations/#s-SHT-Transformations","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"","category":"section"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"One important capability of this package is the transformation between the two representations of a spin-weighted spherical function:","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"Values f of the function evaluated on a set of points or \"pixels\" in the domain of the function.\nValues f̃ of the mode weights (coefficients) of an expansion in the standard spin-weighted spherical-harmonic basis.","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"In the literature, the transformation f ↦ f̃ is usually called \"analysis\" or map2salm, while the inverse transformation f ↦ f̃ is called \"synthesis\" or salm2map.  These are both referred to as spin-spherical-harmonic transforms, or s-SHTs.","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"To describe the values of a spin-s function up to some maximum angular resolution ell_mathrmmax, we need (ell_mathrmmax+1)^2 - s^2 mode weights.  We assume throughout that the values f̃ are stored as","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"f̃ = [mode_weight(ℓ, m) for ℓ ∈ abs(s):ℓₘₐₓ for m ∈ -ℓ:ℓ]","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"(Here, mode_weight is a made-up function intended to provide a schematic.)  In particular, the m index varies most rapidly, and the ell index varies most slowly.  Correspondingly, there must be at least (ell_mathrmmax+1)^2 - s^2 function values f.  However, some s-SHT algorithms require more function values — usually by a factor of 2 or 4 — trading off between speed and memory usage.","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"The SSHT object implements these transformations, storing pre-computed constants and pre-allocated workspace for the transformations.  The interface is designed to be similar to that of FFTW.jl, whereby an SSHT object 𝒯 can be used to perform the transformation as either","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"f = 𝒯 * f̃","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"or","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"f̃ = 𝒯 \\ f","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"Currently, there are three algorithms implemented, each having different advantages and disadvantages:","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"The \"Direct\" algorithm (introduced here for the first time), which is the default, but should only be used up to ell_mathrmmax lesssim 50 because its intermediate storage requirements scale as ell_mathrmmax^4.  This algorithm is the fastest for small ell_mathrmmax, it can be used with arbitrary (non-degenerate) pixelizations, and achieves optimal dimensionality.\nThe \"Minimal\" algorithm due to Elahi et al. [2], with some minor improvements.  This algorithm is fast and — as the name implies — also achieves optimal dimensionality, and its storage scales as ell_mathrmmax^3.  However, its pixelization is restricted, and its accuracy at very high ell_mathrmmax is not as good as the \"RS\" algorithm.  The algorithm itself is not actually fully specified by Elahi et al., and leaves out some relatively simple improvements, so I have had to take some liberties with my interpretation.\nThe \"RS\" algorithm due to Reinecke and Seljebotn [3].  This forms the basis for the libsharp and ducc.sht packages.  It requires pixelizations on \"iso-latitude rings\", and does not achieve optimal dimensionality.  However, it is very fast, and its accuracy is excellent at extremely high ell_mathrmmax.","category":"page"},{"location":"transformations/#SSHT-objects","page":"s-SHT Transformations","title":"SSHT objects","text":"","category":"section"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"Modules = [SphericalFunctions]\nPages   = [\"ssht.jl\", \"ssht/direct.jl\", \"ssht/minimal.jl\", \"ssht/rs.jl\"]","category":"page"},{"location":"transformations/#SphericalFunctions.SSHT","page":"s-SHT Transformations","title":"SphericalFunctions.SSHT","text":"Supertype of storage for spin-spherical-harmonic transforms\n\n\n\n\n\n","category":"type"},{"location":"transformations/#SphericalFunctions.SSHT-Tuple{Any, Any}","page":"s-SHT Transformations","title":"SphericalFunctions.SSHT","text":"SSHT(s, ℓₘₐₓ; [method=\"Direct\"], [T=Float64], [kwargs...])\n\nConstruct an SSHT object to transform between spin-weighted spherical-harmonic mode weights and function values — performing an s-SHT.\n\nThis object behaves similarly to an AbstractFFTs.Plan object — specifically in the ability to use the semantics of algebra to perform transforms.  For example, if the function values are stored as a vector f, the mode weights as f̃, and the SSHT as 𝒯, then we can compute the function values from the mode weights as\n\nf = 𝒯 * f̃\n\nor solve for the mode weights from the function values as\n\nf̃ = 𝒯 \\ f\n\nThe first dimensions of f̃ must index the mode weights (as usual, for ℓ∈abs(s):ℓₘₐₓ and m∈-ℓ:ℓ) and the first index of f must index the locations at which the function is evaluated.  Any following dimensions will be broadcast over.  Note that certain types will broadcast using Julia threads, while others will broadcast using BLAS threads.  The relevant number of threads must be set appropriately.\n\nCertain SSHT types (currently, only Minimal and Direct) also have an option to always act in place — meaning that they simply re-use the input storage, even when used in an expression like 𝒯 \\ f.  The option must be passed as the inplace argument to the constructors, and is part of the type of the resulting object.  Regardless of the value of that option, for those types where the option exists, it is also possible to use mul! and ldiv! from the LinearAlgebra package to force operation in place.\n\nNote that different algorithms require different \"pixelizations\", or sets of Rotors on which to evaluate the function.  These can be obtained from the SSHT object using the pixels and rotors functions.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.pixels","page":"s-SHT Transformations","title":"SphericalFunctions.pixels","text":"pixels(𝒯)\n\nReturn the spherical coordinates (θ, ϕ) on which the spin-weighted spherical harmonics are evaluated.  See also rotors, which provides the actual Rotors on which they are evaluated.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#SphericalFunctions.rotors","page":"s-SHT Transformations","title":"SphericalFunctions.rotors","text":"rotors(𝒯)\n\nReturn the Rotors on which the spin-weighted spherical harmonics are evaluated.  See also pixels, which provides the corresponding spherical coordinates.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#SphericalFunctions.SSHTDirect","page":"s-SHT Transformations","title":"SphericalFunctions.SSHTDirect","text":"SSHTDirect(s, ℓₘₐₓ; decomposition=LinearAlgebra.qr, T=Float64, Rθϕ=golden_ratio_spiral_rotors(s, ℓₘₐₓ, T), inplace=true)\n\nConstruct an s-SHT object that uses the \"Direct\" method; see ₛ𝐘 for details about the method and optional arguments.  Also see SSHT for general information about how to use these objects.\n\nBy default, this uses precisely optimal sampling — meaning that the number of points on which the function is evaluated, represented by Rθϕ, is equal to the number of modes.  However, it is equally possible to evaluate on more points than there are modes.  This can be useful, for example, when processing multiple fields with different spin weights; the function could be evaluated on points appropriate for the lowest value of s, and therefore could also be used to solve for fields of all other spin weights.\n\nNote that in-place operation is possible for this type when the length of the input Rθϕ is equal to the number of modes given s and ℓₘₐₓ — and is the default behavior when possible.  See SSHT for description of in-place operation.\n\nThis method is typically better than other current implementations for ℓₘₐₓ  24, both in terms of speed and accuracy.  However, this advantage quickly falls away.  A warning will be issued if ℓₘₐₓ is greater than about 64, because this method is not likely to be the most efficient or most accurate choice.\n\n\n\n\n\n","category":"type"},{"location":"transformations/#SphericalFunctions.SSHTMinimal","page":"s-SHT Transformations","title":"SphericalFunctions.SSHTMinimal","text":"Storage for Minimal spin-spherical-harmonic transform\n\nThe Minimal algorithm was described by Elahi et al., and allows for the minimal number of function samples.\n\n\n\n\n\n","category":"type"},{"location":"transformations/#SphericalFunctions.SSHTMinimal-Union{Tuple{TT}, Tuple{Any, Any}} where TT","page":"s-SHT Transformations","title":"SphericalFunctions.SSHTMinimal","text":"SSHTMinimal(s, ℓₘₐₓ; kwargs...)\n\nConstruct a SSHTMinimal object directly.  This may also be achieved by calling the main SSHT function with the same keywords, along with method=\"Minimal\".\n\nThis object uses the algorithm described by Elahi et al.\n\nThe basic floating-point number type may be adjusted with the keyword argument T, which defaults to Float64.\n\nThe SSHs are evaluated on a series of \"rings\" at constant colatitude.  Their locations are specified by the θ keyword argument, which defaults to sorted_rings(s, ℓₘₐₓ, T).  The first element of θ is the colatitude of the smallest ring (containing 2s+1 elements), and so on to the last element of θ, which is the colatitude of the largest ring (containing 2ℓₘₐₓ+1 elements).\n\nWhenever T is either Float64 or Float32, the keyword arguments plan_fft_flags and plan_fft_timelimit may also be useful for obtaining more efficient FFTs.  They default to FFTW.ESTIMATE and Inf, respectively.  They are passed to AbstractFFTs.plan_fft.\n\nNote that, because this algorithm achieves optimal dimensionality, the transformation will be performed in place by default.  If this is not desired, pass the keyword argument inplace=false.  This will cause the algorithm to copy the input and perform in-place transformation on that copy.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.SSHTRS","page":"s-SHT Transformations","title":"SphericalFunctions.SSHTRS","text":"Storage for  spin-spherical-harmonic transform\n\nThe algorithm was described in by Reinecke and Seljebotn.\n\n\n\n\n\n","category":"type"},{"location":"transformations/#SphericalFunctions.SSHTRS-Union{Tuple{TT}, Tuple{Any, Any}} where TT","page":"s-SHT Transformations","title":"SphericalFunctions.SSHTRS","text":"SSHTRS(s, ℓₘₐₓ; kwargs...)\n\nConstruct a SSHTRS object directly.  This may also be achieved by calling the main SSHT function with the same keywords, along with method=\"RS\".\n\nThis object uses the algorithm described by Reinecke and Seljebotn.\n\nThe basic floating-point number type may be adjusted with the keyword argument T, which defaults to Float64.\n\nThe SSHs are evaluated on a series of \"rings\" at constant colatitude.  Their locations are specified by the θ keyword argument, which defaults to fejer1_rings(2ℓₘₐₓ+1, T).  If this is changed, the user should also provide the corresponding quadrature_weights argument — the default being fejer1(length(θ), T).\n\nOn each of these rings, an FFT is performed.  To reach the band limit of m =  ℓₘₐₓ, the number of points along each ring must therefore be at least 2ℓₘₐₓ+1, but may be greater.  For example, if 2ℓₘₐₓ+1 does not factorize neatly into a product of small primes, it may be preferable to use 2ℓₘₐₓ+2 points along each ring.  (In that case, whenever ℓₘₐₓ is 1 less than a power of 2, the number of points will be exactly a power of 2, which is usually particularly efficient.)  The number of points on each ring can be modified independently, if given as a vector with the same length as θ, or as a single number which is assumed to be the same for all rings.\n\nWhenever T is either Float64 or Float32, the keyword arguments plan_fft_flags and plan_fft_timelimit may also be useful for obtaining more efficient FFTs.  They default to FFTW.ESTIMATE and Inf, respectively.  They are passed to AbstractFFTs.plan_fft.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#Pixelizations","page":"s-SHT Transformations","title":"Pixelizations","text":"","category":"section"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"The algorithms implemented here require pixelizations.  While the \"Direct\" algorithm can be used with arbitrary pixelizations, the \"Minimal\" and \"RS\" algorithms require more specific choices, as noted in their docstrings.","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"Typically, \"pixelization\" refers exclusively to a choice of points on the sphere 𝕊² at which to compute function values.  Of course, as mentioned elsewhere, it is not technically possible to define spin-weighted functions as functions of a point on 𝕊² alone; we also need some sense of reference direction in the tangent space.  Quite generally, we can define spin-weighted functions on the group 𝐒𝐎(3) or 𝐒𝐩𝐢𝐧(3), so we will also refer to a choice of a set of points in 𝐒𝐩𝐢𝐧(3) (which is essentially the group of unit quaternions) as a \"pixelization\".  However, assuming spherical coordinates, a choice of coordinates on the sphere almost everywhere induces a choice of the reference direction in the tangent space, so it is almost possible to define pixelizations just in terms of points on 𝕊².  But using spherical coordinates is actually enough to fully specify the pixelization, because the degeneracies at the poles also allow us to define the reference direction.","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"In principle, we could be concerned about the choice of reference direction in the tangent space.  That is, we might expect to care about pixelizations over 𝕊³.  However, we are dealing with spin-weighted functions, which are eigenfunctions of a final rotation about the reference direction.  This means that once we choose any reference direction at each point, we know the function values for any other reference direction at those points.  In particular, an important property of a pixelization is the condition number of the transformation matrix between the function values and the mode weights.  If we rotate the reference direction at a single point, this is equivalent to multiplying the matrix by a diagonal matrix with entries of 1 everywhere except the entry corresponding to that point, where the entry is some complex phase.  This does not change the condition number of the matrix, so we can ignore the choice of reference direction at every point.  For other situations, where we might care about the choice of reference direction, it might be interesting to consider this work by Marc Alexa, and references therein.","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"Interesting discussions of various pixelizations and metrics can be found in Saff and Kuijlaars (1997) and Brauchart and Grabner (2015), as well as blog posts here and here. Note that the \"equal-area\" pixelizations of Healpix are very restrictive—only being available for very specific numbers of points—and do not provide any obvious advantages over the more flexible pixelizations available here.","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"The various pixelizations may be computed as follows:","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"Modules = [SphericalFunctions]\nPages   = [\"pixelizations.jl\"]","category":"page"},{"location":"transformations/#SphericalFunctions.clenshaw_curtis_rings-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T","page":"s-SHT Transformations","title":"SphericalFunctions.clenshaw_curtis_rings","text":"clenshaw_curtis_rings(N, [T=Float64])\n\nValues of the colatitude coordinate (θ) appropriate for quadrature by the Clenshaw-Curtis rule, using weights provided by clenshaw_curtis.\n\nNote that the first argument to this function is N, rather than the ℓₘₐₓ used in some other functions.  For spin-weighted spherical harmonics, you may want to use N=2ℓₘₐₓ+1.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.fejer1_rings-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T","page":"s-SHT Transformations","title":"SphericalFunctions.fejer1_rings","text":"fejer1_rings(N, [T=Float64])\n\nValues of the colatitude coordinate (θ) appropriate for quadrature by Fejér's first rule, using weights provided by fejer1.\n\nNote that the first argument to this function is N, rather than the ℓₘₐₓ used in some other functions.  For spin-weighted spherical harmonics, you may want to use N=2ℓₘₐₓ+1.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.fejer2_rings-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T","page":"s-SHT Transformations","title":"SphericalFunctions.fejer2_rings","text":"fejer2_rings(N, [T=Float64])\n\nValues of the colatitude coordinate (θ) appropriate for quadrature by Fejér's second rule, using weights provided by fejer2.\n\nNote that the first argument to this function is N, rather than the ℓₘₐₓ used in some other functions.  For spin-weighted spherical harmonics, you may want to use N=2ℓₘₐₓ+1.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.golden_ratio_spiral_pixels-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"s-SHT Transformations","title":"SphericalFunctions.golden_ratio_spiral_pixels","text":"golden_ratio_spiral_pixels(s, ℓₘₐₓ, [T=Float64])\n\nCover the sphere 𝕊² with pixels generated by the golden-ratio spiral. Successive pixels are separated by the azimuthal angle Δϕ = 2π(2-φ), and are uniformly distributed in cos θ.\n\nThis is also known as the \"Fibonacci sphere\" or \"Fibonacci lattice\".\n\nVisually, this is a very reasonable-looking pixelization, with fairly uniform distance between neighbors, and approximate isotropy.  No two pixels will share the same values of either θ or ϕ.  Also note that no point is present on either the North or South poles.\n\nThe returned quantity is a vector of 2-SVectors providing the spherical coordinates of each pixel.  See also golden_ratio_spiral_rotors for the corresponding Rotors.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.golden_ratio_spiral_rotors-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"s-SHT Transformations","title":"SphericalFunctions.golden_ratio_spiral_rotors","text":"golden_ratio_spiral_rotors(s, ℓₘₐₓ, [T=Float64])\n\nCover the sphere 𝕊² with pixels generated by the golden-ratio spiral.\n\nSee golden_ratio_spiral_pixels for more detailed explanation.  The quantity returned by this function is a vector of Rotors providing each pixel.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.sorted_ring_pixels-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"s-SHT Transformations","title":"SphericalFunctions.sorted_ring_pixels","text":"sorted_ring_pixels(s, ℓₘₐₓ, [T=Float64])\n\nCover the sphere 𝕊² with (ℓₘₐₓ+1)²-s² pixels distributed in rings provided by sorted_rings; see that function's documentation for more description.\n\nThe returned quantity is a vector of 2-SVectors containing the spherical coordinates of each pixel.  See also sorted_ring_rotors for the corresponding Rotors.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.sorted_ring_rotors-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"s-SHT Transformations","title":"SphericalFunctions.sorted_ring_rotors","text":"sorted_ring_rotors(s, ℓₘₐₓ, [T=Float64])\n\nCover the sphere 𝕊² with (ℓₘₐₓ+1)²-s² pixels distributed in rings provided by sorted_rings; see that function's documentation for more description.\n\nThe returned quantity is a vector of Rotors.  See also sorted_ring_rotors for the corresponding spherical coordinates.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.sorted_rings-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"s-SHT Transformations","title":"SphericalFunctions.sorted_rings","text":"sorted_rings(s, ℓₘₐₓ, [T=Float64])\n\nCompute locations of a series of rings labelled by j  sℓₘₐₓ (analogous to ℓ), where each ring will contain k = 2j+1 (analogous to m) pixels distributed evenly around the ring.  These rings are then sorted, so that the ring with the most pixels (j = ℓₘₐₓ) is closest to the equator, and the next-largest ring is placed just above or below the equator (depending on the sign of s), the next just below or above, and so on.  This is generally a fairly good first guess when minimizing the condition number of matrices used to solve for mode weights from function values.  In particular, I use this to initialize the Minimal algorithm, which is then fed into an optimizer to fine-tune the positions of the rings.\n\nThis function does not provide the individual pixels; it just provides the colatitude values of the rings on which the pixels will be placed.  The pixels themselves are provided by sorted_ring_pixels.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#Quadrature-weights","page":"s-SHT Transformations","title":"Quadrature weights","text":"","category":"section"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"The \"RS\" algorithm requires quadrature weights corresponding to the input pixelization.  Though there is a working default choice, it is possible to use others.  There are several that are currently implemented, along with their corresponding pixelizations:","category":"page"},{"location":"transformations/","page":"s-SHT Transformations","title":"s-SHT Transformations","text":"Modules = [SphericalFunctions]\nPages   = [\"weights.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"transformations/#SphericalFunctions.clenshaw_curtis-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"s-SHT Transformations","title":"SphericalFunctions.clenshaw_curtis","text":"clenshaw_curtis(n, [T])\n\nCompute n weights for the Clenshaw-Curtis rule, corresponding to n evenly spaced nodes from 0 to π inclusive.  That is, the nodes are located at\n\ntheta_k = k fracpin-1 quad k=0 ldots n-1\n\nThis function uses Waldvogel's method.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.fejer1-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"s-SHT Transformations","title":"SphericalFunctions.fejer1","text":"fejer1(n, [T])\n\nCompute n weights for Fejér's first rule, corresponding to n evenly spaced nodes from 0 to π inclusive.  That is, the nodes are located at\n\ntheta_k = k fracpin-1 quad k=0 ldots n-1\n\nThis function uses Waldvogel's method.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"transformations/#SphericalFunctions.fejer2-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:AbstractFloat","page":"s-SHT Transformations","title":"SphericalFunctions.fejer2","text":"fejer2(n, [T])\n\nCompute n weights for Fejér's second rule, corresponding to n evenly spaced nodes between 0 and π exclusive.  That is, the nodes are located at\n\ntheta_k = k fracpin+1 quad k=1 ldots n\n\nThis function uses Waldvogel's method.  However, contrary to Waldvogel's notation, this routine does not include the weight corresponding to the ϑ=0 or π nodes, which both have weight 0.\n\nThe type T may be any AbstractFloat, but defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Internal-functions","page":"Internal functions","title":"Internal functions","text":"","category":"section"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"There are various functions that are only used internally, some of which are likely to be deprecated in the near future.  These are documented here for completeness.","category":"page"},{"location":"internal/#H-recursion-and-ALFs","page":"Internal functions","title":"H recursion and ALFs","text":"","category":"section"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"The fundamental algorithm is the H recursion, which is the core computation needed for Wigner's d and 𝔇 matrices, and the spin-weighted spherical harmonics _sY_ellm, as well as map2salm functions.","category":"page"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"Modules = [SphericalFunctions]\nPages   = [\"Hrecursion.jl\"]","category":"page"},{"location":"internal/#SphericalFunctions.H!-Union{Tuple{T}, Tuple{AbstractVector, Complex{T}, Any, Any, Any}, Tuple{AbstractVector, Complex{T}, Vararg{Any, 4}}} where T<:Real","page":"Internal functions","title":"SphericalFunctions.H!","text":"H!(H, expiβ, ℓₘₐₓ, m′ₘₐₓ, H_rec_coeffs)\nH!(H, expiβ, ℓₘₐₓ, m′ₘₐₓ, H_rec_coeffs, Hindex)\n\nCompute the H matrix defined by Gumerov and Duraiswami [8].\n\nThis computation forms the basis for computing Wigner's d and 𝔇 matrices via d_matrices! and D_matrices!, the spin-weighted spherical harmonics via sYlm_values!, and for transforming from values of spin-weighted spherical functions evaluated on a grid to the corresponding mode weights via map2salm.\n\nDue to symmetries, we only need to compute ~1/4 of the elements of this matrix, so only those elements with m  m are computed.  The relevant indices of the H vector are computed based on the Hindex function — which defaults to WignerHindex, but could reasonably be WignerDindex if the input H vector contains all valid indices.  However, it is assumed that the storage scheme used for H is such that the successive m values are located in successive elements.\n\nIf mₘₐₓ  ℓₘₐₓ, we don't even need 1/4 of the elements, and only values with m  mₘₐₓ will be computed.  This is particularly useful for computing spin-weighted spherical harmonics.\n\nNote that the recursion coefficients H_rec_coeffs should be the quantity returned by H_recursion_coefficients.\n\n\n\n\n\n","category":"method"},{"location":"internal/#SphericalFunctions.H_recursion_coefficients-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:Real","page":"Internal functions","title":"SphericalFunctions.H_recursion_coefficients","text":"H_recursion_coefficients(ℓₘₐₓ, T)\n\nPre-compute constants used in Wigner H recursion.\n\n\n\n\n\n","category":"method"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"Internally, the H recursion relies on calculation of the Associated Legendre Functions (ALFs), which can also be called on their own:","category":"page"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"Modules = [SphericalFunctions]\nPages   = [\"associated_legendre.jl\"]","category":"page"},{"location":"internal/#SphericalFunctions.ALFcompute!-Union{Tuple{T}, Tuple{Vector{T}, Complex{T}, Int64, ALFRecursionCoefficients{T}}} where T<:Real","page":"Internal functions","title":"SphericalFunctions.ALFcompute!","text":"ALFcompute(expiβ, nmax)\nALFcompute!(P̄, expiβ, nmax)\nALFcompute(expiβ, nmax, recursion_coefficients)\nALFcompute!(P̄, expiβ, nmax, recursion_coefficients)\n\nCompute the \"fully normalized\" Associated Legendre Functions up to some maximum n value nmax.\n\nThese functions can take a vector P̄, to store the data, stored in order of increasing m most rapidly varying and then increasing n.  If not supplied, P̄ will be constructed for you and returned.\n\nThe optional recursion_coefficients argument must be an ALFRecursionCoefficients, which stores various constant coefficients used in the recursion.  This object requires more than 3x the memory and more than 20x the time to compute a single P̄ vector without this argument, but passing it will typically speed up the calculation of each P̄ by a factor of 8x or so.  Thus, if you expect to compute P̄ more than a few times, it will take less time to pre-compute those factors, and pass them to this function.\n\nNote that the base real type will be inferred from the (complex) type of expiβ.  If present, the base types of P̄ and recursion_coefficients must agree.\n\n\n\n\n\n","category":"method"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"The function _slambda_ellm is defined as essentially _sY_ell0, and is important internally for computing the ALFs.  We have some important utilities for computing it:","category":"page"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"SphericalFunctions.λ_recursion_initialize\nSphericalFunctions.λ_iterator\nSphericalFunctions.AlternatingCountdown","category":"page"},{"location":"internal/#SphericalFunctions.λ_recursion_initialize","page":"Internal functions","title":"SphericalFunctions.λ_recursion_initialize","text":"λ_recursion_initialize(cosθ, sin½θ, cos½θ, s, ℓ, m)\n\nThis provides initial values for the recursion to find _slambda_ellm along indices of increasing ell, due to Kostelec & Rockmore Specifically, this function computes values with ell=m.\n\n_slambda_ellm(theta)\n    = _sY_ellm(theta 0)\n    = (-1)^m sqrtfrac2ell+14pi d^ell_-ms(theta)\n\n\n\n\n\n","category":"function"},{"location":"internal/#SphericalFunctions.λ_iterator","page":"Internal functions","title":"SphericalFunctions.λ_iterator","text":"λ_iterator(θ, s, m)\n\nConstruct an object to iterate over ₛλₗₘ values.\n\nThe ₛλₗₘ(θ) function is defined as the spin-weighted spherical harmonic evaluated at spherical coordinates (θ ϕ), with ϕ=0.  In particular, note that it is real-valued. The return type is determined by the type of θ (or more precisely, cos½θ).\n\nThis algorithm by Kostelec & Rockmore allows us to iterate over increasing ℓ values, for given fixed s and m values.\n\nNote that this iteration has no inherent bound, so if you try to iterate over all values, you will end up in an infinite loop.  Instead, you can zip this iterator with another:\n\nθ = 0.1\ns = -2\nm = 1\nλ = λ_iterator(θ, s, m)\nΔ = max(abs(s), abs(m))\nfor (ℓ, ₛλₗₘ) ∈ zip(Δ:Δ+5, λ)\n    @show (ℓ, ₛλₗₘ)\nend\n\nAlternatively, you could use Iterates.take(λ, 6), for example.\n\nNote that the iteration always begins with ℓ = Δ = max(abs(s), abs(m)).\n\n\n\n\n\n","category":"type"},{"location":"internal/#SphericalFunctions.AlternatingCountdown","page":"Internal functions","title":"SphericalFunctions.AlternatingCountdown","text":"Simple iterator to count down to 0, with alternating signs\n\njulia> collect(AlternatingCountdown(5))\n11-element Vector{Int64}:\n  5\n -5\n  4\n -4\n  3\n -3\n  2\n -2\n  1\n -1\n  0\n\n\n\n\n\n","category":"type"},{"location":"internal/#ₛ𝐘","page":"Internal functions","title":"ₛ𝐘","text":"","category":"section"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"Various d, D, and sYlm functions are important in the main API.  Their names and signatures have been tweaked from older versions of this package.  The only one with remaining documentation is ₛ𝐘, which could probably be replaced by sYlm_values, except that the default pixelization is golden_ratio_spiral_rotors, which makes it very convenient for interacting with SSHT.","category":"page"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"ₛ𝐘","category":"page"},{"location":"internal/#SphericalFunctions.ₛ𝐘","page":"Internal functions","title":"SphericalFunctions.ₛ𝐘","text":"ₛ𝐘(s, ℓₘₐₓ, [T=Float64], [Rθϕ=golden_ratio_spiral_rotors(s, ℓₘₐₓ, T)])\n\nConstruct a matrix of ₛYₗₘ(Rθϕ) values for the input s and all nontrivial (ell m) up to ℓₘₐₓ.\n\nThis is a fast and accurate method for mapping between the vector of spin-weighted spherical-harmonic mode weights ₛ𝐟ₗₘ and the vector of function values on the sphere ₛ𝐟ⱼₖ, as\n\nₛ𝐟ⱼₖ = ₛ𝐘 ₛ𝐟ₗₘ\n\nwhere the right-hand side represents the matrix-vector product.  As usual, we assume that the ₛ𝐟ₗₘ modes are ordered by increasing m  -ℓℓ, and ℓ  sℓₘₐₓ.  The ordering of the ₛ𝐟ⱼₖ values will be determined by the ordering of the argument Rθϕ.\n\nNote that the number of modes need not be the same as the number of points on which the function is evaluated, which would imply that the output matrix is not square.  To be able to invert the relationship, however, we need the number of points ₛ𝐟ⱼₖ to be at least as large as the number of modes ₛ𝐟ₗₘ.\n\nNote that the usefulness of this approach is limited by the fact that the size of this matrix scales as ℓₘₐₓ⁴.  As such, it is mostly useful only for ℓₘₐₓ of order dozens, rather than — say — the tens of thousands that CMB astronomy or lensing require, for example.\n\nDirect application and inversion of this matrix are used in the \"direct\" methods of s-SHT transformations.  See SSHTDirect for details about the implementation.\n\n\n\n\n\n","category":"function"},{"location":"internal/#Transformation","page":"Internal functions","title":"Transformation","text":"","category":"section"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"The newer SSHT interface is more efficient for most purposes, but this package used to use functions named map2salm, which is still present, but may be deprecated.","category":"page"},{"location":"internal/","page":"Internal functions","title":"Internal functions","text":"Modules = [SphericalFunctions]\nPages   = [\"map2salm.jl\"]","category":"page"},{"location":"internal/#SphericalFunctions.map2salm!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, Int64, Int64, Any}} where T<:Real","page":"Internal functions","title":"SphericalFunctions.map2salm!","text":"map2salm!(salm, map, spin, ℓmax)\nmap2salm!(salm, map, plan)\n\nTransform map values sampled on the sphere to _sa_ell m modes in place.\n\nFor details, see map2salm.\n\n\n\n\n\n","category":"method"},{"location":"internal/#SphericalFunctions.map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, Int64, Int64}, Tuple{AbstractArray{Complex{T}}, Int64, Int64, Any}} where T<:Real","page":"Internal functions","title":"SphericalFunctions.map2salm","text":"map2salm(map, spin, ℓmax)\nmap2salm(map, plan)\n\nTransform map values sampled on the sphere to _sa_ell m modes.\n\nThe map array should have size Nφ along its first dimension and Nϑ along its second; any number of dimensions may follow.  The spin must be entered explicitly, and ℓmax is the highest ℓ value you want in the output.\n\nFor repeated applications of this function with different values of map, it is more efficient to pre-compute plan using plan_map2salm.  These functions will create a new salm array on each call.  To operate in place on a pre-allocated salm array, use map2salm!.\n\nThe core of this function follows the method described by Reinecke and Seljebotn.\n\n\n\n\n\n","category":"method"},{"location":"internal/#SphericalFunctions.plan_map2salm-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, Int64, Int64}} where T<:Real","page":"Internal functions","title":"SphericalFunctions.plan_map2salm","text":"plan_map2salm(map, spin, ℓmax)\n\nPrecompute values to use in executing map2salm or map2salm!.\n\nThe arguments to this function exactly mirror those of the first form of map2salm, and all but the first argument in the first form of map2salm!.  The plan returned by this function can be passed to the second forms of those functions to avoid some computation and allocation costs.\n\nNote that the plan object is not thread safe; a separate plan should be created for each thread that will use one, or locks should be used to ensure that a single plan is not used at the same time on different threads.\n\n\n\n\n\n","category":"method"},{"location":"sYlm/#{}_{s}Y_{\\ell,m}-functions","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"","category":"section"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"The spin-weighted spherical harmonics are an important set of functions defined on the rotation group 𝐒𝐎(3), or more generally, the spin group 𝐒𝐩𝐢𝐧(3) that covers it.  They are eigenfunctions of the left- and right-Lie derivatives, and are particularly useful in describing the angular dependence of polarized fields, like the electromagnetic field and gravitational-wave field.  Originally introduced by Newman and Penrose [7], they are essentially components of Wigner's frakD matrices:","category":"page"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"_sY_ellm(mathbfR)\n  = (-1)^s sqrtfrac2ell+14pi  frakD^(ell)_m -s(mathbfR)","category":"page"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"As such, they can be computed using the same H recursion algorithm as the Wigner frakD^(ell)_m -s matrices.  But because not all values of s in -ellell are used, we can be much more efficient in both storage and computation time.","category":"page"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"The user interface is very similar to the one for Wigner's 𝔇 and d matrices:","category":"page"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"using Quaternionic\nusing SphericalFunctions\n\nR = randn(RotorF64)\nℓₘₐₓ = 8\ns = -2\nY = sYlm_values(R, ℓₘₐₓ, s)","category":"page"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"Again, the results can take up a lot of memory, so for maximum efficiency when calling this function repeatedly with different R values, it is best to pre-allocate the necessary memory with the sYlm_prep function, and the pass that in as an argument to sYlm_values!:","category":"page"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"Y_storage = sYlm_prep(ℓₘₐₓ, s)\nY = sYlm_values!(Y_storage, R, s)","category":"page"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"(Beware that, as noted in the documentation for sYlm_values!, the output Y is just a reference to part of the Y_storage object, so you should not reuse Y_storage until you have copied or otherwise finished using Y.)","category":"page"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"The output Y is a single vector of Complex numbers with the same base type as R.  The ordering of the elements is described in the documentation for sYlm_values!.  It is also possible to efficiently view slices of this vector as a series of individual vectors using a sYlm_iterator:","category":"page"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"for (ℓ, Yˡ) in zip(0:ℓₘₐₓ, sYlm_iterator(Y, ℓₘₐₓ))\n    # Do something with the matrix Yˡ[ℓ+m′+1, ℓ+m+1]\nend","category":"page"},{"location":"sYlm/#Docstrings","page":"_sY_ellm functions","title":"Docstrings","text":"","category":"section"},{"location":"sYlm/","page":"_sY_ellm functions","title":"_sY_ellm functions","text":"sYlm_values\nsYlm_values!\nsYlm_prep\nsYlm_iterator","category":"page"},{"location":"sYlm/#SphericalFunctions.sYlm_values","page":"_sY_ellm functions","title":"SphericalFunctions.sYlm_values","text":"sYlm_values(R, ℓₘₐₓ, spin)\nsYlm_values(θ, ϕ, ℓₘₐₓ, spin)\n\nCompute values of the spin-weighted spherical harmonic _sY_ell m(R) for all ell leq ell_mathrmmax.\n\nSee sYlm_values! for details about the input and output values.\n\nThis function only appropriate when you need to evaluate the _sY_ell m for a single value of R or θ, ϕ because it allocates large arrays and performs many calculations that could be reused.  If you need to evaluate the matrices for many values of R or θ, ϕ, you should pre-allocate the storage with sYlm_prep, and then call sYlm_values! with the result instead.\n\n\n\n\n\n","category":"function"},{"location":"sYlm/#SphericalFunctions.sYlm_values!","page":"_sY_ellm functions","title":"SphericalFunctions.sYlm_values!","text":"sYlm_values!(sYlm_storage, R, spin)\nsYlm_values!(sYlm_storage, θ, ϕ, spin)\nsYlm_values!(sYlm, R, ℓₘₐₓ, spin)\nsYlm_values!(sYlm, θ, ϕ, ℓₘₐₓ, spin)\n\nCompute values of the spin-weighted spherical harmonic _sY_ell m(R) for all ell leq ell_mathrmmax.\n\nThe spherical harmonics of spin weight s are related to Wigner's mathfrakD matrix as\n\nbeginaligned\n_sY_ell m(R)\n  = (-1)^s sqrtfrac2ell+14pi mathfrakD^(ell)_m -s(R) \n  = (-1)^s sqrtfrac2ell+14pi barmathfrakD^(ell)_-s m(barR)\nendaligned\n\nIn all cases, the result is returned in a 1-dimensional array ordered as\n\n[\n    ₛYₗₘ(R)\n    for ℓ ∈ 0:ℓₘₐₓ\n    for m ∈ -ℓ:ℓ\n]\n\nWhen the first argument is Y, it will be modified, so it must be at least as large as that array. When the first argument is sYlm_storage, it should be the quantity returned by sYlm_prep, and the result will be written into the Y field of that tuple.  Both of these options — especially the latter — reduce the number of allocations needed on each call to the corresponding functions, which should increase the speed significantly.  Note that the Y or sYlm_storage arguments must have types compatible with the type of R or θ, ϕ.\n\nwarn: Warn\nWhen using the sYlm_storage argument (which is recommended), the returned quantity sYlm will be an alias of sYlm_storage[1].  If you want to retain that data after the next call to sYlm_values!, you should copy it with copy(sYlm).\n\nThe θ, ϕ arguments are spherical coordinates as described in the documentation of Quaternionic.from_spherical_coordinates.\n\nSee also sYlm_values for a simpler function call when you only need to evaluate the _sY_ell m for a single value of R or θ, ϕ.\n\nExamples\n\nusing Quaternionic, SphericalFunctions\nspin = -2\nℓₘₐₓ = 8\nT = Float64\nR = Rotor{T}(1, 2, 3, 4)  # Will be normalized automatically\nsYlm_storage = sYlm_prep(ℓₘₐₓ, spin, T)\nsYlm = sYlm_values!(sYlm_storage, R, spin)\n\n\n\n\n\n","category":"function"},{"location":"sYlm/#SphericalFunctions.sYlm_prep","page":"_sY_ellm functions","title":"SphericalFunctions.sYlm_prep","text":"sYlm_prep(ℓₘₐₓ, sₘₐₓ, [T=Float64, [ℓₘᵢₙ=0]])\n\nConstruct storage space and pre-compute recursion coefficients to compute spin-weighted spherical-harmonic values _sY_ell m in place.\n\nThis returns the sYlm_storage arguments needed by sYlm_values!.\n\nNote that the result of this function can be passed to sYlm_values!, even if the value of spin passed to that function is smaller (in absolute value) than the sₘₐₓ passed to this function.  That is, the sYlm_storage returned by this function can be used to compute _sY_ell m values for numerous values of the spin.\n\n\n\n\n\n","category":"function"},{"location":"sYlm/#SphericalFunctions.sYlm_iterator","page":"_sY_ellm functions","title":"SphericalFunctions.sYlm_iterator","text":"sYlm_iterator(Y, ℓₘₐₓ, [ℓₘᵢₙ, [iₘᵢₙ]])\n\nConstruct an Iterator that returns sub-vectors of Y, each of which consists of elements (ℓ-ℓ) through (ℓℓ), for ℓ from ℓₘᵢₙ through ℓₘₐₓ.\n\nNote that the returned objects are views into the original Y data — meaning that you may alter their values.\n\nBecause the result is a vector restricted to a particular ℓ value, you can index the (ℓ m) element as [ℓ+m+1].  For example, you might use this as something like\n\nfor (ℓ, Yˡ) in zip(ℓₘᵢₙ:ℓₘₐₓ, sYlm_iterator(Y, ℓₘₐₓ))\n    for m in -ℓ:ℓ\n        Yˡ[ℓ+m+1]  # ... do something with Yˡ\n    end\nend\n\nBy default, Y is assumed to contain all possible values, beginning with (0,0).  However, if ℓₘᵢₙ is not 0, this can be ambiguous: do we mean that Y really starts with the (0,0) element and we are just asking to begin the iteration higher?  Or do we mean that Y doesn't even contain data for lower ℓ values?  We can resolve this using iₘᵢₙ, which gives the index of ℓₘᵢₙ in Y.  By default, we assume the first case, and set iₘᵢₙ=Ysize(ℓₘᵢₙ-1)+1. However, if Y doesn't contain data below ℓₘᵢₙ, we could use iₘᵢₙ=1 to indicate the index in Y at which to find (ℓₘᵢₙ-ℓₘᵢₙ).\n\nAlso note that no bounds checking is done, either at instantiation time or during iteration.  You are responsible for ensuring that the size of Y and the values of ℓₘₐₓ, ℓₘᵢₙ, and iₘᵢₙ make sense.\n\n\n\n\n\n","category":"type"},{"location":"operators/#Differential-operators","page":"Differential operators","title":"Differential operators","text":"","category":"section"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Spin-weighted spherical functions cannot be defined on the sphere S^2, but are well defined on the group mathrmSpin(3) cong mathrmSU(2) or the rotation group mathrmSO(3).  (See Boyle [1] for the explanation.)  However, this also allows us to define a variety of differential operators acting on these functions, relating to infinitesimal motions in these groups, acting either from the left or the right on their arguments.  Right or left matters because the groups mentioned above are all non-commutative groups.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"In general, the left Lie derivative of a function f(Q) over the unit quaternions with respect to a generator of rotation g is defined as","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_g(f)Q = -fraci2\n    left fracdfleft(exp(tg) Qright)dt right_t=0","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Note that the exponential multiplies Q on the left — hence the name.  We will see below that this agrees with the usual definition of the angular-momentum from physics, except that in quantum physics a factor of hbar is usually included.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"So, for example, a rotation about the z axis has the quaternion z as its generator of rotation, and L_z defined in this way agrees with the usual angular-momentum operator L_z familiar from spherical-harmonic theory, and reduces to it when the function has spin weight 0, but also applies to functions of general spin weight.  Similarly, we can compute L_x and L_y, and take appropriate combinations to find the usual raising and lowering (ladder) operators L_+ and L_-.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"In just the same way, we can define the right Lie derivative of a function f(Q) over the unit quaternions with respect to a generator of rotation g as","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"R_g(f)Q = -fraci2\n    left fracdfleft(Q exp(tg)right)dt right_t=0","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Note that the exponential multiplies Q on the right — hence the name.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"This operator is less common in physics, because it represents the dependence of the function on the choice of frame (or coordinate system), which is not usually of interest. Multiplication on the left represents a rotation of the physical system, while rotation on the right represents a rotation of the coordinate system.  However, this dependence on coordinate system is precisely what defines the spin weight of a function, so this class of operators is relevant in discussions of spin-weighted spherical functions.  In particular, the operators R_pm correspond (up to a sign) to the spin-raising and -lowering operators eth and bareth originally introduced by Newman and Penrose [7], as explained in greater detail by Boyle [1].","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Note that these definitions are extremely general, in that they can be used for any Lie group, and for any complex-valued function on that group.  And in full generality, we have the useful properties of linearity:","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_smathbfa = sL_mathbfa\nqquad textand qquad\nR_smathbfa = sR_mathbfa","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"and","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_mathbfa+mathbfb = L_mathbfa + L_mathbfb\nqquad textand qquad\nR_mathbfa+mathbfb = R_mathbfa + R_mathbfb","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"for any scalar s and any elements of the Lie algebra mathbfa and mathbfb.  In particular, if the Lie algebra has a basis mathbfe_(j), we use the shorthand L_j and R_j for L_mathbfe_(j) and R_mathbfe_(j), respectively, and we can expand any operator in terms of these basis operators:","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_mathbfa = sum_j a_j L_j\nqquad textand qquad\nR_mathbfa = sum_j a_j R_j","category":"page"},{"location":"operators/#Commutators","page":"Differential operators","title":"Commutators","text":"","category":"section"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"In general, for generators a and b, we have the commutator relations","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"left L_a L_b right = fraci2 L_ab\nqquad\nleft R_a R_b right = -fraci2 R_ab","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"where ab is the commutator of the two generators, which can be obtained directly as the commutator of the corresponding quaternions.  Note the sign difference between these two equations.  The factors of pm i2 are inherited directly from the definitions of L_g and R_g given above, but they appear there with the same sign.  The sign difference between these two commutator equations results from the fact that the quaternions are multiplied in opposite orders in the two cases.  It could be absorbed by defining the operators with opposite signs.[1]  The arbitrary sign choices used above are purely for historical reasons.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Again, these results are valid for general (finite-dimensional) Lie groups, but a particularly interesting case is in application to the three-dimensional rotation group.  In the following, we will apply our results to this group.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"The commutator relations for L are consistent — except for the differing use of hbar — with the usual relations from quantum mechanics:","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"left L_j L_k right = i hbar sum_l=1^3 varepsilon_jkl L_l","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Here, j, k, and l are indices that run from 1 to 3, and index the set of basis vectors (hatx haty hatz).  If we represent an arbitrary basis vector as hate_j, then the quaternion commutator ab in the expression for L_a L_b becomes","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"hate_j hate_k = 2 sum_l=1^3 varepsilon_jkl hate_l","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Plugging this into the general expression L_a L_b = fraci2 L_ab, we obtain (up to the factor of hbar) the version frequently seen in quantum physics.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"[1]: In fact, we can define the left and right Lie derivative operators quite generally, for functions on any Lie group and for the corresponding Lie algebra.  And in all cases (at least for finite-dimensional Lie algebras) we obtain the same commutator relations. The only potential difference is that it may not make sense to use the coefficient i2 in general; it was chosen here for consistency with the standard angular-momentum operators. If that coefficient is changed in the definitions of the Lie derivatives, the only change to the commutator relations would the substitution of that coefficient.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"The raising and lowering operators relative to L_z and R_z satisfy — by definition of raising and lowering operators — the relations","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_z L_pm = pm L_pm\nqquad\nR_z R_pm = pm R_pm","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"These allow us to solve — up to an overall factor — for those operators in terms of the basic generators (again, noting the sign difference):","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_pm = L_x pm i L_y\nqquad\nR_pm = R_x mp i R_y","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"(Interestingly, this procedure also shows that rasing and lowering operators can only exist if the factor in front of the derivatives in the definitions of L_g and R_g are pure imaginary numbers.)  In particular, this results in the commutator relations","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_+ L_- = 2L_z\nqquad\nR_+ R_- = 2R_z","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Here, the signs are similar because the two sign differences noted above essentially cancel each other out.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"In the functions listed below, these operators are returned as matrices acting on vectors of mode weights.  As such, we can actually evaluate these commutators as given to cross-validate the expressions and those functions.","category":"page"},{"location":"operators/#Transformations-of-functions-vs.-mode-weights","page":"Differential operators","title":"Transformations of functions vs. mode weights","text":"","category":"section"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"One important point to note is that mode weights transform \"contravariantly\" (very loosely speaking) relative to the spin-weighted spherical functions under some operators.  For example, take the action of the L_+ operator, which acts on a SWSH as","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"L_+ left_sY_ellmright (R) = sqrt(ell-m)(ell+m+1) _sY_ellm+1(R)","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"We can use this to derive the mode weights of a general spin-weighted function f under the action of this operator:[2]","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"beginaligned\nleftL_+ fright_ellm\n=\nint leftL_+ f(R)right _sbarY_ellm(R) dR \n=\nint leftL_+ sum_ellmf_ellm _sY_ellm(R)right _sbarY_ellm(R) dR \n=\nint sum_ellm f_ellm leftL_+ _sY_ellm(R)right _sbarY_ellm(R) dR \n=\nsum_ellm f_ellm int leftL_+ _sY_ellm(R)right _sbarY_ellm(R) dR \n=\nsum_ellm f_ellm int leftsqrt(ell-m)(ell+m+1) _sY_ellm+1(R)right _sbarY_ellm(R) dR \n=\nsum_ellm f_ellm sqrt(ell-m)(ell+m+1) int _sY_ellm+1(R) _sbarY_ellm(R) dR \n=\nsum_ellm f_ellm sqrt(ell-m)(ell+m+1) delta_ellell delta_mm+1 \n=\nf_ellm-1 sqrt(ell-m+1)(ell+m)\nendaligned","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Note that this expression (and in particular its signs) more resembles the expression for L_- left_sY_ellmright than for L_+ left_sY_ellmright.  Similar relations hold for the action of L_-.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"[2]: A technical note about the integrals above: the integrals should be taken over the appropriate space and with the appropriate weight such that the SWSHs are orthonormal.  In general, this integral should be over mathrmSpin(3) and weighted by 12pi so that the result will be either 0 or 1; in general the SWSHs are not truly orthonormal when integrated over an S^2 subspace (nor even is the integral invariant). However, if we know that the spins are the same in both cases, it is possible to integrate over an S^2 subspace.","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"However, it is important to note that the same \"contravariance\" is not present for the spin-raising and -lowering operators:","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"beginaligned\nlefteth fright_ellm\n=\nint lefteth f(R)right _s+1barY_ellm(R) dR \n=\nint lefteth sum_ellmf_ellm _sY_ellm(R)right _s+1barY_ellm(R) dR \n=\nsum_ellm f_ellm int lefteth _sY_ellm(R)right _s+1barY_ellm(R) dR \n=\nsum_ellm f_ellm sqrt(ell-s)(ell+s+1) int _s+1Y_ellm(R) _s+1barY_ellm(R) dR \n=\nsum_ellm f_ellm sqrt(ell-s)(ell+s+1) delta_ellell delta_mm \n=\nf_ellm sqrt(ell-s)(ell+s+1)\nendaligned","category":"page"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Similarly bareth — and R_pm of course — obey this more \"covariant\" form of transformation.","category":"page"},{"location":"operators/#Docstrings","page":"Differential operators","title":"Docstrings","text":"","category":"section"},{"location":"operators/","page":"Differential operators","title":"Differential operators","text":"Modules = [SphericalFunctions]\nPages   = [\"operators.jl\"]","category":"page"},{"location":"operators/#SphericalFunctions.Lz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.Lz","text":"Lz(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the angular-momentum operator associated with the z direction.  This is the standard L_z operator, familiar from basic physics, extended to work with SWSHs.  Note that this is the left Lie derivative; see Rz for the equivalent right Lie derivative.  See the documentation or Boyle for more details.\n\nIn terms of the SWSHs, we can write the action of L_z as\n\nL_z _sY_ellm = m _sY_ellm\n\nSee also L², L₊, L₋, R², Rz, R₊, R₋, ð, ð̄.\n\n\n\n\n\n","category":"method"},{"location":"operators/#SphericalFunctions.L²-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.L²","text":"L²(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the total angular-momentum operator from ℓₘᵢₙ up to ℓₘₐₓ.  If not present, ℓₘᵢₙ is assumed to be abs(s).  The argument s is ignored; it is present only for consistency with other operators, and is assumed to be 0 if not present.\n\nThis is the standard L² operator, familiar from basic physics, extended to work with SWSHs.  It is also known as the Casimir operator, and is equal to\n\nL^2 = L_x^2 + L_y^2 + L_z^2 = fracL_+L_- + L_-L_+ + 2L_zL_z2\n\nNote that these are the left Lie derivatives, but L^2 = R^2, where R is the right Lie derivative.  See the documentation or Boyle for more details.\n\nIn terms of the SWSHs, we can write the action of L^2 as\n\nL^2 _sY_ellm = ell(ell+1) _sY_ellm\n\nSee also Lz, L₊, L₋, R², Rz, R₊, R₋, ð, ð̄.\n\n\n\n\n\n","category":"method"},{"location":"operators/#SphericalFunctions.L₊-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.L₊","text":"L₊(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the angular-momentum raising operator.  This is the standard L_+ operator, familiar from basic physics, extended to work with SWSHs.  Note that this is the left Lie derivative; see R₊ for the equivalent right Lie derivative.  See the documentation or Boyle for more details.\n\nWe define L_+ to be the raising operator for the left Lie derivative with respect to rotation about z: L_z.  By definition, this implies the commutator relation L_z L_+ = L_+, which allows us to derive L_+ = L_x + i L_y\n\nIn terms of the SWSHs, we can write the action of L_+ as\n\nL_+ _sY_ellm = sqrt(ell-m)(ell+m+1) _sY_ellm+1\n\nConsequently, the mode weights of a function are affected as\n\nleftL_+(f)right_sellm = sqrt(ell+m)(ell-m+1)leftfright_sellm-1\n\nSee also L², Lz, L₋, R², Rz, R₊, R₋, ð, ð̄.\n\n\n\n\n\n","category":"method"},{"location":"operators/#SphericalFunctions.L₋-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.L₋","text":"L₋(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the angular-momentum lowering operator.  This is the standard L_- operator, familiar from basic physics, extended to work with SWSHs.  Note that this is the left Lie derivative; see R₋ for the equivalent right Lie derivative.  See the documentation or Boyle for more details.\n\nWe define L_- to be the lowering operator for the left Lie derivative with respect to rotation about z: L_z.  By definition, this implies the commutator relation L_z L_- = -L_-, which allows us to derive L_- = L_x - i L_y\n\nIn terms of the SWSHs, we can write the action of L_- as\n\nL_- _sY_ellm = sqrt(ell+m)(ell-m+1) _sY_ellm-1\n\nConsequently, the mode weights of a function are affected as\n\nleftL_-(f)right_sellm = sqrt(ell-m)(ell+m+1)leftfright_sellm+1\n\nSee also L², Lz, L₊, L₋, R², Rz, R₊, R₋, ð, ð̄.\n\n\n\n\n\n","category":"method"},{"location":"operators/#SphericalFunctions.Rz-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.Rz","text":"Rz(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the right angular-momentum operator associated with the z direction.\n\nThis is the R_z operator, much like the L_z operator familiar from basic physics, but in terms of the right Lie derivative, and extended to work with SWSHs.  See Lz for the equivalent left Lie derivative.  See the documentation or Boyle for more details.\n\nIn terms of the SWSHs, we can write the action of R_z as\n\nR_z _sY_ellm = -s _sY_ellm\n\nNote the unfortunate sign of s, which seems to be opposite to what we expect, and arises from the choice of definition of s in the original paper by Newman and Penrose.\n\nSee also L², Lz, L₊, L₋, R², R₊, R₋, ð, ð̄.\n\n\n\n\n\n","category":"method"},{"location":"operators/#SphericalFunctions.R²-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.R²","text":"R²(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the total angular-momentum operator from ℓₘᵢₙ up to ℓₘₐₓ.  If not present, ℓₘᵢₙ is assumed to be abs(s).  The argument s is ignored; it is present only for consistency with other operators, and is assumed to be 0 if not present.\n\nThis is the R^2 operator, much like the L^2 operator familiar from basic physics, but in terms of the right Lie derivative, and extended to work with SWSHs.  It is also known as the Casimir operator, and is equal to\n\nR^2 = R_x^2 + R_y^2 + R_z^2 = fracR_+R_- + R_-R_+ + 2R_zR_z2\n\nNote that these are the right Lie derivatives, but L^2 = R^2, where L is the left Lie derivative.  See the documentation or Boyle for more details.\n\nIn terms of the SWSHs, we can write the action of R^2 as\n\nR^2 _sY_ellm = ell(ell+1) _sY_ellm\n\nSee also L², Lz, L₊, L₋, Rz, R₊, R₋, ð, ð̄.\n\n\n\n\n\n","category":"method"},{"location":"operators/#SphericalFunctions.R₊-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.R₊","text":"R₊(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the right angular-momentum raising operator.\n\nThis is the R_+ operator, much like the L_+ operator familiar from basic physics, but in terms of the right Lie derivative, and extended to work with SWSHs.  See L₊ for the equivalent left Lie derivative.  See the documentation or Boyle for more details.\n\nWe define R_+ to be the raising operator for the right Lie derivative with respect to rotation about z: R_z.  By definition, this implies the commutator relation R_z R_+ = R_+, which allows us to derive R_+ = R_x - i R_y\n\nIn terms of the SWSHs, we can write the action of R_+ as\n\nR_+ _sY_ellm = sqrt(ell+s)(ell-s+1) _s-1Y_ellm\n\nConsequently, the mode weights of a function are affected as\n\nleftR_+(f)right_sellm = sqrt(ell+s)(ell-s+1)leftfright_s-1ellm\n\nBecause of the unfortunate sign of s arising from the choice of definition of s in the original paper by Newman and Penrose, this is a lowering operator for s, though it really is a raising operator for R_z, and raises the eigenvalue of the corresponding Wigner matrix.\n\nSee also L², Lz, L₊, L₋, R², Rz, R₋, ð, ð̄.\n\n\n\n\n\n","category":"method"},{"location":"operators/#SphericalFunctions.R₋-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.R₋","text":"R₋(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute the right angular-momentum lowering operator.\n\nThis is the R_- operator, much like the L_- operator familiar from basic physics, but in terms of the right Lie derivative, and extended to work with SWSHs.  See L₋ for the equivalent left Lie derivative.  See the documentation or Boyle for more details.\n\nWe define R_- to be the raising operator for the right Lie derivative with respect to rotation about z: R_z.  By definition, this implies the commutator relation R_z R_- = -R_-, which allows us to derive R_- = R_x + i R_y\n\nIn terms of the SWSHs, we can write the action of R_- as\n\nR_- _sY_ellm = sqrt(ell-s)(ell+s+1) _s+1Y_ellm\n\nConsequently, the mode weights of a function are affected as\n\nleftR_-(f)right_sellm = sqrt(ell-s)(ell+s+1)leftfright_s+1ellm\n\nBecause of the unfortunate sign of s arising from the choice of definition of s in the original paper by Newman and Penrose, this is a raising operator for s, though it really is a lowering operator for R_z, and lowers the eigenvalue of the corresponding Wigner matrix - though that raises the eigenvalue of the corresponding Wigner matrix.\n\nSee also L², Lz, L₊, L₋, R², Rz, R₊, ð, ð̄.\n\n\n\n\n\n","category":"method"},{"location":"operators/#SphericalFunctions.ð-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.ð","text":"ð(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute coefficients for the spin-raising operator eth.\n\nThis operator was originally defined by Newman and Penrose, but is more completely defined by Boyle.  It is identical to R₋.  Refer to that function's documentation for more details.\n\nBy definition, the spin-raising operator satisfies the commutator relation S eth = eth (where S is the spin operator, which just multiplies the function by its spin). In terms of the SWSHs, we can write the action of eth as\n\n    eth _sY_ellm = sqrt(ell-s)(ell+s+1) _s+1Y_ellm\n\nConsequently, the mode weights of a function are affected as\n\nlefteth fright_sellm = sqrt(ell-s)(ell+s+1)leftfright_s+1ellm\n\nSee also ð̄,  L², Lz, L₊, L₋, R², Rz, R₊.\n\n\n\n\n\n","category":"method"},{"location":"operators/#SphericalFunctions.ð̄-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Differential operators","title":"SphericalFunctions.ð̄","text":"ð̄(s, ℓₘᵢₙ, ℓₘₐₓ, [T])\n\nCompute coefficients for the spin-lowering operator bareth.\n\nThis operator was originally defined by Newman and Penrose, but is more completely defined by Boyle.  It is opposite to R₊ — meaning that bareth = -R.  Refer to that function's documentation for more details.\n\nBy definition, the spin-lowering operator satisfies the commutator relation S bareth = -bareth (where S is the spin operator, which just multiplies the function by its spin).  In terms of the SWSHs, we can write the action of bareth as\n\nbareth _sY_ellm = -sqrt(ell+s)(ell-s+1) _s-1Y_ellm\n\nConsequently, the mode weights of a function are affected as\n\nleftbareth fright_sellm\n= -sqrt(ell-s)(ell+s+1)leftfright_s+1ellm\n\nSee also ð,  L², Lz, L₊, L₋, R², Rz, R₊.\n\n\n\n\n\n","category":"method"},{"location":"notes/sampling_theorems/#Sampling-theorems-and-transformations-of-spin-weighted-spherical-harmonics","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"","category":"section"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"McEwen and Wiaux [11] (MW) provide a very thorough review of the literature on sampling theorems related to spin-weighted spherical harmonics up to 2011.  Reinecke and Seljebotn [3] (RS) outlined one of the more efficient and accurate implementations of spin-weighted spherical harmonic transforms (sSHT) currently available as libsharp, but their algorithm is 4L², whereas McEwen and Wiaux's is2L², while Elahi et al. [2] (EKKM) have obtained the optimal result that scales as L².","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"The downside of the EKKM algorithm is that the θ values at which to sample have to be obtained by iteratively minimizing the condition numbers of various matrices (which are involved in the computation itself).  This expensive step only has to be performed once per choice of spin s and maximum ℓ value L.  Otherwise, the results of this algorithm seem to be relatively good — at least for L up to 64.  This does not compare favorably with the MW algorithm, which has slowly growing errors through L = 4096.","category":"page"},{"location":"notes/sampling_theorems/#EKKM-analysis","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"EKKM analysis","text":"","category":"section"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"The EKKM analysis looks like the following (with some notational changes).  We begin by defining","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  _stildef_theta(m) = int_0^2pi _sf(theta phi) e^-imphi dphi","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"We will denote the vector of these quantities for all values of theta as _stildemathbff_m.  Inserting the _sY_ellm expansion for _sf(theta phi), and performing the integration using orthogonality of complex exponentials, we can find that","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  _stildef_theta(m) = (-1)^s 2pi sum_ell=Delta^L sqrtfrac2ell+14pi d_m-s^ell(theta) _sf_ellm","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"Now, denoting the vector of _sf_ellm for all values of ell as _smathbff_m, we can write this as a matrix-vector equation:","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  _stildemathbff_m = (-1)^s 2pi _smathbfd_m _smathbff_m","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"We are effectively measuring the _stildemathbff_m values, we can easily construct the _smathbfd_m matrix, and we are seeking the _smathbff_m values, so we can just invert this equation to solve for the latter.","category":"page"},{"location":"notes/sampling_theorems/#Discretizing-the-Fourier-transform","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Discretizing the Fourier transform","text":"","category":"section"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"Now, the only flaw in this analysis is that we have undersampled everywhere except ell = L, which means that the second equation (re-expressing the Fourier transforms as a sum using orthogonality of complex exponentials) isn't quite right; in general there is some folding due to aliasing of higher-frequency modes, so we need an additional sum over mm.  Or perhaps more precisely, the first equation isn't actually what we implement.  It should look more like this:","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  _stildef_j(m) = sum_k=0^2j _sf(theta_j phi_k) e^-imphi_k Delta phi","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"where phi_k = frac2pi k2j+1, and Delta phi = frac2pi2j+1.  (Recall the subtle notational distinction common in time-frequency analysis that tildes(t_j) = Delta t tildes_j, which would suggest we use _stildef_j(m) = Delta phi _stildef_jm.)  Next, we can insert the expansion for _sf(theta phi):","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"beginaligned\n    _stildef_j(m)\n    = sum_k=0^2j sum_ellm _sf_ellm _sY_ellm(theta_j phi_k) e^-imphi_k Delta phi \n    = sum_k=0^2j sum_ellm _sf_ellm (-1)^s sqrtfrac2ell+14pi d_ell^m-s(theta_j) e^i m phi_k e^-imphi_k frac2pi2j+1 \n    = (-1)^s frac2pi2j+1 sum_ellm _sf_ellm sqrtfrac2ell+14pi d_ell^m-s(theta_j) sum_k=0^2je^i (m-m) phi_k\nendaligned","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"We can evaluate this last sum easily:","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  sum_k=0^2je^i (m-m) phi_k = begincases\n    2j+1  m-m = n(2j+1) mathrmfor ninmathbbZ \n    0  mathrmotherwise\n  endcases","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"This allows us to simplify as","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"beginaligned\n    _stildef_j(m) = (-1)^s 2pi sum_ellm _sf_ellm sqrtfrac2ell+14pi d_ell^m-s(theta_j)\nendaligned","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"where m ranges over m + n(2j+1) for all nin mathbbZ such that m + n(2j+1) leq ell — that is, all nin mathbbZ such that","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  left lceil frac-ell-m2j+1 right rceil leq n leq left lfloor fracell-m2j+1 right rfloor","category":"page"},{"location":"notes/sampling_theorems/#Matrix-representation","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Matrix representation","text":"","category":"section"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"Usually, we would take the sum over ell ranging from mathrmmax(ms) to L, and the sum over m ranging over m + n(2j+1) for all nin mathbbZ such that m + n(2j+1) leq ell. However, we can also consider these sums to range over all possible values of ell m, and just set the coefficient to zero whenever these conditions are not satisfied.  In that case, we can again think of this as a (much larger) vector-matrix equation reading","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"  _stildemathbff = (-1)^s 2pi _smathbfd _smathbff","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"where the index on _stildemathbff loops over j and m, the index on _smathbff loops over ell and m, and the indices on _smathbfd loop over each of those pairs.","category":"page"},{"location":"notes/sampling_theorems/#De-aliasing","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"De-aliasing","text":"","category":"section"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"While it is far simpler to simply invert the full _smathbfd matrix, its size scales as L^4, which means that it very quickly becomes impractical to store and manipulate the full matrix. In CMB astronomy, for example, it is not uncommon to use L into the tens of thousands, which would make the full matrix utterly impractical to use.","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"However, the matrix has a fairly sparse structure, with the number of nonzero elements scaling as L^3.  More particularly, the sparsity has a fairly special structure, where the full matrix is mostly block diagonal, along with some sparse upper triangular elements.  Of course, the goal is to solve the linear equation.  For that, the first obvious choice is an LU decomposition. Unfortunately, the L and U components are not sparse.  A second obvious choice is the QR decomposition, which is more tailored to the structure of this matrix — the Q factor being essentially just the block diagonal, and the R factor being a somewhat less sparse upper triangle.","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"In principle, this alone could delay the impracticality threshold — though still not enough for CMB astronomy.  We can use the unusual structure to solve the linear equation in a more piecewise fashion, with fairly low memory overhead.  Essentially, we start with the highest-k values, and solve for the corresponding highest-m values.  Those harmonics will alias to other frequencies in theta_j rings with j  k.  But crucially, we know how they alias, and can simply remove them from the Fourier transforms of those rings.  We then repeat, solving for the next-highest k values, and so on.","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"The following pseudo-code summarizes the analysis algorithm, modifying the input in place:","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"# Iterate over rings, doing Fourier decompositions on each\nfor j ∈ abs(s):ℓₘₐₓ\n    fft!(ₛf[j])  # Perform in-place FFT\n    fftshift!(ₛf[j])  # Cycle order of FFT elements in place to match order of modes\n    ₛf[j] *= 2π / (2j+1)  # Change normalization\nend\n\nfor m ∈ AlternatingCountdown(ℓₘₐₓ)  # Iterate over +m, then -m, down to m=0\n    Δ = max(abs(s), abs(m))\n\n    # Gather the `m` data from each ring into a temporary workspace\n    for j ∈ Δ:ℓₘₐₓ\n        ₛfₘ[j] = ₛf[Yindex(j, m, abs(s))]\n    end\n\n    # Solve for the mode weights from the Fourier components\n    ₛf̃ₘ[Δ:ℓₘₐₓ] = ₛΛ[m] \\ ₛfₘ[Δ:ℓₘₐₓ]\n\n    # Distribute the data back into the output\n    for ℓ ∈ Δ:ℓₘₐₓ\n        ₛf[Yindex(ℓ, m, abs(s))] = ₛf̃ₘ[ℓ]\n    end\n\n    # De-alias Fourier components from rings with values of j < Δ\n    for j′ ∈ abs(s):m-1\n        m′ = mod(j′+m, 2j′+1)-j′  # `m` aliases into `(j′, m′)`\n        α = 2π * sum(\n            𝒯.ₛf̃ₘ[ℓ] * ₛλₗₘ\n            for (ℓ, ₛλₗₘ) ∈ zip(Δ:ℓₘₐₓ, λ_iterator(𝒯.θ[j′], s, m))\n        )\n        ₛf[Yindex(j′, m′, abs(s))] -= α\n    end\n\nend","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"The following pseudo-code summarizes the synthesis algorithm, modifying the input in place:","category":"page"},{"location":"notes/sampling_theorems/","page":"Sampling theorems and transformations of spin-weighted spherical harmonics","title":"Sampling theorems and transformations of spin-weighted spherical harmonics","text":"for m ∈ AlternatingCountup(ℓₘₐₓ)  # Iterate over +m, then -m, up from m=0\n    Δ = max(abs(s), abs(m))\n\n    # Iterate over rings, combining contributions for this `m` value\n    for j ∈ Δ:ℓₘₐₓ\n        # We will accumulate into 𝒯.ₛfₘ, and write it out at the end of the loop\n        ₛfₘ[j] = false\n\n        # Direct (non-aliased) contributions from m′ == m\n        λ = λ_iterator(𝒯.θ[j], s, m)\n        for (ℓ, ₛλₗₘ) ∈ zip(Δ:ℓₘₐₓ, λ)\n            ₛfₘ[j] += ₛf̃[Yindex(ℓ, m, abs(s))] * ₛλₗₘ\n        end\n\n        # Aliased contributions from |m′| > j > |m|\n        for ℓ′ ∈ j:ℓₘₐₓ\n            for n ∈ cld(-ℓ′-m, 2j+1):fld(ℓ′-m, 2j+1)\n                m′ = m + n*(2j+1)\n                if abs(m′) > j\n                    ₛλₗ′ₘ′ = ₛΛ[m′][j,ℓ′]\n                    𝒯.ₛfₘ[j] += ₛf̃[Yindex(ℓ′, m′, abs(s))] * ₛλₗ′ₘ′\n                end\n            end\n        end\n\n    end  # j\n\n    # Distribute the data back into the output\n    @threads for j ∈ Δ:ℓₘₐₓ\n        ₛf̃[Yindex(j, m, abs(s))] = 𝒯.ₛfₘ[j]\n    end\n\nend  # m\n\n# Iterate over rings, doing Fourier decompositions on each\nfor j ∈ abs(s):ℓₘₐₓ\n    ifftshift!(ₛf̃[j]) # Cycle order of modes in place to match order of FFT elements\n    bfft!(ₛf̃ⱼ[j]) # Perform in-place BFFT\nend","category":"page"},{"location":"notes/H_recursions/#Algorithm-for-computing-H","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"The H array, as given by Gumerov and Duraiswami [8], is related to Wigner's (small) d matrices — which is itself related to the (big) mathfrakD matrices and the various spin-weighted spherical harmonics _sY_ellm — via","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"d_ell^mm = epsilon_m epsilon_-m H_ell^mm","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"where","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"epsilon_k =\n  begincases\n    1  kleq 0 \n    (-1)^k  k  0\n  endcases","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"H has various advantages over d, including the fact that it can be efficiently and robustly valculated via recurrence relations, and the following symmetry relations:","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  H^m m_n(β) = H^m m_n(β) \n  H^m m_n(β) = H^-m -m_n(β) \n  H^m m_n(β) = (-1)^n+m+m H^-m m_n(π - β) \n  H^m m_n(β) = (-1)^m+m H^m m_n(-β)\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Because of these symmetries, we only need to evaluate at most 1/4 of all the elements.","category":"page"},{"location":"notes/H_recursions/#Steps-to-compute-H","page":"Algorithm for computing H","title":"Steps to compute H","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"The following describes various details that are not spelled out correctly by Gumerov and Duraiswami [8].  All equation numbers refer to that paper.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Because of the symmetries noted above, we only compute H^m m_n with m  m — roughly one quarter of all possible values.  Furthermore, for computations of spin-weighted spherical harmonics of weight s, we only need to compute values with m  s, which constitutes a dramatic savings when s  ℓₘₐₓ.  The data are stored in the array Hwedge.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"However, some parts of this calculation require calculating terms with m=n+1 — whereas such elements of d and mathfrakD are considered zero.  For this purpose, we need additional storage.  Rather than allocating extra space, or requiring some additional workspace to be passed in, we can actually use parts of the input H data space for temporary storage while these extra terms are needed, which is before those parts of the storage are needed.  Specifically, we need this additional storage for H^0 m_n_mathrmmax+1 with m in 0 n_mathrmmax+1, and we can use the storage destined for H^-1 m_n_mathrmmax with m in 1 n_mathrmmax.  But this leaves two more indices, which we just store as individual variables — HΩ and HΨ — representing the last and second-to-last of these additional elements stored.","category":"page"},{"location":"notes/H_recursions/#Step-1","page":"Algorithm for computing H","title":"Step 1","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Set H_0^00=1.","category":"page"},{"location":"notes/H_recursions/#Step-2","page":"Algorithm for computing H","title":"Step 2","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Compute values H^0m_n(β) for m=0ldotsn and H^0m_n+1(β) for m=0ldotsn+1.  Using Eq. (32), we see that within Gumerov and Duraiswami's conventions","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  H^0m_n(β) = (-1)^m sqrtfrac(n-m)(n+m) P^m_n(cos β) \n                 = frac1sqrtk_m (2n+1) P_nm(cos β)\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Here, k_0=1 and k_m=2 for m0, and P is defined as","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"  P_nm = sqrtfrack_m(2n+1)(n-m)(n+m) P_nm","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Note that the factor of (-1)^m in the first equation above is different from the convention used here, and is related to the Condon-Shortley phase. Note that Gumerov and Duraiswami use the notation P^m_n, whereas we are using the notation P_nm — which usually differ by a factor of (-1)^m.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"We use the \"fully normalized\" associated Legendre functions (fnALF) P because, as explained by Xing et al. [10], it is possible to compute these values very efficiently and accurately, while also delaying the onset of overflow and underflow.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"The algorithm Xing et al. describe as the best for computing P is due to Belikov (1991), and is given by them as","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  P_00 = 1 \n  P_10 = sqrt3 cos β \n  P_11 = sqrt3 sin β \n  P_n0 = a_n cos β P_n-10 - b_n fracsin β2 P_n-11 \n  P_nm =\n    c_nm cos β P_n-1m\n    - sin β left d_nm P_n-1m+1 - e_nm P_n-1m-1 right\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"where the coefficients are given by","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  a_n = sqrtfrac2n+12n-1 \n  b_n = sqrtfrac2(n-1)(2n+1)n(2n-1) \n  c_nm = frac1n sqrtfrac(n+m)(n-m)(2n+1)2n-1 \n  d_nm = frac12n sqrtfrac(n-m)(n-m-1)(2n+1)2n-1 \n  e_nm = frac12n sqrtfrac22-delta_0^m-1 sqrtfrac(n+m)(n+m-1)(2n+1)2n-1\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Now, we can directly obtain a recurrence relation for H^0m_n = P_nm  sqrtk_m (2n+1) from those expressions:","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  H^00_0 = 1 \n  H^00_1 = cos β \n  H^01_1 = sqrt12 sin β \n  H^00_n = cos β H^00_n-1 - b_n sin β H^01_n-1 \n  H^0m_n =\n    c_nm cos β H^0m_n-1\n    - sin β left d_nm H^0m+1_n-1 - e_nm H^0m-1_n-1 right\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"where the coefficients are given by","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"beginaligned\n  b_n = sqrtfracn-1n \n  c_nm = frac1n sqrt(n+m)(n-m) \n  d_nm = frac12n sqrt(n-m)(n-m-1) \n  e_nm = frac12n sqrt(n+m)(n+m-1)\nendaligned","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Note that the coefficients all simplified (in fact, a_n disappeared), without any increase in the complexity of the recurrence relations themselves.  Rewriting Belikov's algorithm explicitly in terms of the H^0m_n also allows us to avoid an extra normalization step.","category":"page"},{"location":"notes/H_recursions/#Step-3","page":"Algorithm for computing H","title":"Step 3","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Compute H^1m_n(β) for m=1ldotsn using relation (41).  Symmetry and shift of the indices allow this relation to be written as","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"b^0_n+1 H^1 m_n\n  = fracb^m1_n+1 (1cos β)2 H^0 m+1_n+1\n   fracb^ m1_n+1 (1+cos β)2 H^0 m1_n+1\n   a^m_n sin β H^0 m_n+1","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Here the constants are defined by","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"a^m_n = sqrtfrac(n+m+1)(n-m+1) (2n+1)(2n+3)","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"b^m_n = mathrmsgn(m) sqrtfrac(n-m-1)(n-m) (2n-1)(2n+1)","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Note that all values are assumed to be zero whenever m  n, we use mathrmsgn(0)=1 (unlike the common convention that mathrmsgn(0)=0), and we have a^m_n = a^-m_n.  Also note that these coefficients only appear in this step, and because of how they appear (specifically, because b always appears with argument n+1), we can factor out the denominators in the definitions of the constants.  We obtain this simplified formula","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"H^1 m_n\n  = -frac1sqrtn(n+1) left\n      fracbarb^m1_n+1 (1cos β)2 H^0 m+1_n+1\n      + fracbarb^ m1_n+1 (1+cos β)2 H^0 m1_n+1\n      + bara^m_n sin β H^0 m_n+1\n    right","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"with","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"bara^m_n = sqrt(n+m+1)(n-m+1)","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"barb^m_n+1 = sqrt(n-m)(n-m+1)","category":"page"},{"location":"notes/H_recursions/#Step-4","page":"Algorithm for computing H","title":"Step 4","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Recursively compute H^m+1 m_n(β) for m=1ldotsn1, m=mn using relation (50) resolved with respect to H^m+1 m_n:","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"d^m_n H^m+1 m_n\n  = d^m1_n H^m1 m_n\n   d^m1_n H^m m1_n\n  + d^m_n H^m m+1_n","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"(where the last term drops out for m=n).  The constants are defined by","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"d^m_n = fracmathrmsgn(m)2 sqrt(n-m)(n+m+1)","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Note that we can drop the factor of 12, and for this case only the sign is always +1.","category":"page"},{"location":"notes/H_recursions/#Step-5","page":"Algorithm for computing H","title":"Step 5","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Recursively compute H^m1 m_n(β) for m=0ldotsn+1, m=mldotsn using relation (50) resolved with respect to H^m1 m_n:","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"d^m1_n H^m1 m_n\n  = d^m_n H^m+1 m_n\n  + d^m1_n H^m m1_n\n   d^m_n H^m m+1_n","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"(where the last term drops out for m=n).","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"NOTE: Although Gumerov and Duraiswami specify the loop over m to start at -1, I find it necessary to start at 0, or there will be missing information. This also requires setting the H^0 -1_n components (for all n) before beginning this loop.","category":"page"},{"location":"notes/H_recursions/#Pre-computing-constants-versus-computing-on-the-fly","page":"Algorithm for computing H","title":"Pre-computing constants versus computing on the fly","text":"","category":"section"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"Each of the constants a^m_n, b^m_n, and c^m_n involves divisions and square-roots, which can be very costly to compute.  It can be advantageous to pre-compute the constants, and simply index the pre-computed arrays rather than re-computing them on each recursion.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"If we include the cost of computing all these constants in a single call to the H recurrence, it can be much cheaper to compute each constant as needed within the algorithm, rather than computing them all at once at the beginning of the algorithm — but only for very small computations, such as those involving n_mathrmmax  10.  Beyond this, despite the storage penalties for all those constants, it turns out to be better to pre-compute them.  However, it should be noted that the fractional cost of storing the constants is sim 3n_mathrmmax compared to just storing H itself, so this will never be a very significant amount of space.","category":"page"},{"location":"notes/H_recursions/","page":"Algorithm for computing H","title":"Algorithm for computing H","text":"On the other hand, if we can pre-compute the constants just once, and store them between multiple calls to the H recurrence, then it is always advantageous to do so — typically by factors of 2 or 3 in speed.  The only difficulty here is ensuring that each call to the recurrence has access to the constants, which can be a little awkward when using multiple processes and/or threads.  However, it should be thread safe, since we only need to read those constants within the H recurrence.  All in all, I conclude that it is probably not worth the effort to maintain separate versions of the recurrence for pre-computed and on-the-fly constants.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is a Julia package for evaluating and transforming Wigner's 𝔇 matrices, and spin-weighted spherical harmonics _sY_ellm (which includes the ordinary scalar spherical harmonics).  Because both 𝔇 and the harmonics are most correctly considered functions on the rotation group 𝐒𝐎(3) — or more generally, the spin group 𝐒𝐩𝐢𝐧(3) that covers it — these functions are evaluated directly in terms of quaternions.  Concessions are also made for more standard forms of spherical coordinates and Euler angles.[1] Among other applications, those functions permit \"synthesis\" (evaluation of the spin-weighted spherical functions) of spin-weighted spherical harmonic coefficients on regular or distorted grids.  This package also includes functions enabling efficient \"analysis\" (decomposition into mode coefficients) of functions evaluated on regular grids to high order and accuracy.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"These quantities are computed using recursion relations, which makes it possible to compute to very high ℓ values.  Unlike direct evaluation of individual elements, which would generally cause overflow or underflow beyond ℓ≈30 when using double precision, these recursion relations should be valid for far higher ℓ values.  More precisely, when using this package, Inf values appear starting at ℓ=128 for Float16, but I have not yet found any for values up to at least ℓ=1024 with Float32, and presumably far higher for Float64. BigFloat also works, and presumably will not overflow for any ℓ value that could reasonably fit into computer memory — though it is far slower.  Also note that DoubleFloats will work, and achieve significantly greater accuracy (but no greater ℓ range) than Float64.  In all cases, results are typically accurate to roughly ℓ times the precision of the input quaternion.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The conventions for this package are mostly inherited from — and are described in detail by — its predecessors found here and here.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note that numerous other packages cover some of these use cases, including FastTransforms.jl, FastSphericalHarmonics.jl, WignerSymbols.jl, and WignerFamilies.jl.  However, I need support for quaternions (via Quaternionic.jl) and for higher-precision numbers — even at the cost of a very slight decrease in speed in some cases — which are what this package provides.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1]: Euler angles are quite generally a very poor choice for computing with rotations.  (The only context in which they may be preferred is when analytically integrating some analytically known functions.)  Almost universally, it is best to use quaternions when computing with rotations. All the computations done within this package use quaternions; the user interfaces involving Euler angles essentially convert to/from quaternions. While the calculations needed for those conversions would still need to be done if this package used Euler angles internally — meaning that this approach is as efficient as any — that work can be avoided entirely if you work with quaternions directly.","category":"page"}]
}
