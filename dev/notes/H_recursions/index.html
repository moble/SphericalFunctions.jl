<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithm for computing H · SphericalFunctions.jl</title><link rel="canonical" href="https://moble.github.io/SphericalFunctions.jl/stable/notes/H_recursions/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SphericalFunctions.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../manual/">Primary functions</a></li><li><a class="tocitem" href="../../utilities/">Utilities</a></li><li><span class="tocitem">Notes</span><ul><li class="is-active"><a class="tocitem" href>Algorithm for computing <span>$H$</span></a><ul class="internal"><li><a class="tocitem" href="#Steps-to-compute-H"><span>Steps to compute <span>$H$</span></span></a></li><li><a class="tocitem" href="#Pre-computing-constants-versus-computing-on-the-fly"><span>Pre-computing constants versus computing on the fly</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Notes</a></li><li class="is-active"><a href>Algorithm for computing <span>$H$</span></a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithm for computing <span>$H$</span></a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/moble/SphericalFunctions.jl/blob/main/docs/src/notes/H_recursions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Algorithm-for-computing-H"><a class="docs-heading-anchor" href="#Algorithm-for-computing-H">Algorithm for computing <span>$H$</span></a><a id="Algorithm-for-computing-H-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-for-computing-H" title="Permalink"></a></h1><p>The <span>$H$</span> array, as given by <a href="https://arxiv.org/abs/1403.7698">Gumerov and Duraiswami</a>, is related to Wigner&#39;s (small) <span>$d$</span> matrices — which is itself related to the (big) <span>$\mathfrak{D}$</span> matrices and the various spin-weighted spherical harmonics <span>${}_{s}Y_{\ell,m}$</span> — via</p><p class="math-container">\[d_{\ell}^{m&#39;,m} = \epsilon_{m&#39;} \epsilon_{-m} H_{\ell}^{m&#39;,m},\]</p><p>where</p><p class="math-container">\[\epsilon_k =
  \begin{cases}
    1 &amp; k\leq 0, \\
    (-1)^k &amp; k &gt; 0.
  \end{cases}\]</p><p><span>$H$</span> has various advantages over <span>$d$</span>, including the fact that it can be efficiently and robustly valculated via recurrence relations, and the following symmetry relations:</p><p class="math-container">\[\begin{aligned}
  H^{m&#39;, m}_n(β) &amp;= H^{m, m&#39;}_n(β) \\
  H^{m&#39;, m}_n(β) &amp;= H^{-m&#39;, -m}_n(β) \\
  H^{m&#39;, m}_n(β) &amp;= (-1)^{n+m+m&#39;} H^{-m&#39;, m}_n(π - β) \\
  H^{m&#39;, m}_n(β) &amp;= (-1)^{m+m&#39;} H^{m&#39;, m}_n(-β)
\end{aligned}\]</p><p>Because of these symmetries, we only need to evaluate at most 1/4 of all the elements.</p><h2 id="Steps-to-compute-H"><a class="docs-heading-anchor" href="#Steps-to-compute-H">Steps to compute <span>$H$</span></a><a id="Steps-to-compute-H-1"></a><a class="docs-heading-anchor-permalink" href="#Steps-to-compute-H" title="Permalink"></a></h2><p>The following describes various details that are not spelled out correctly by <a href="https://arxiv.org/abs/1403.7698">Gumerov and Duraiswami</a>.  All equation numbers refer to that paper.</p><p>Because of the symmetries noted above, we only compute <span>$H^{m&#39;, m}_n$</span> with <span>$m ≥ |m&#39;|$</span> — roughly one quarter of all possible values.  Furthermore, for computations of spin-weighted spherical harmonics of weight <span>$s$</span>, we only need to compute values with <span>$|m&#39;| ≤ |s|$</span>, which constitutes a dramatic savings when <span>$|s| ≪ ℓₘₐₓ$</span>.  The data are stored in the array <code>Hwedge</code>.</p><p>However, some parts of this calculation require calculating terms with <span>$m=n+1$</span> — whereas such elements of <span>$d$</span> and <span>$\mathfrak{D}$</span> are considered zero.  For this purpose, we need additional storage.  Rather than allocating extra space, or requiring some additional workspace to be passed in, we can actually use parts of the input <span>$H$</span> data space for temporary storage while these extra terms are needed, which is before those parts of the storage are needed.  Specifically, we need this additional storage for <span>$H^{0, m}_{n_\mathrm{max}+1}$</span> with <span>$m \in [0, n_\mathrm{max}+1]$</span>, and we can use the storage destined for <span>$H^{-1, m}_{n_\mathrm{max}}$</span> with <span>$m \in [1, n_\mathrm{max}]$</span>.  But this leaves two more indices, which we just store as individual variables — <code>HΩ</code> and <code>HΨ</code> — representing the last and second-to-last of these additional elements stored.</p><h3 id="Step-1"><a class="docs-heading-anchor" href="#Step-1">Step 1</a><a id="Step-1-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1" title="Permalink"></a></h3><p>Set <span>$H_{0}^{0,0}=1$</span>.</p><h3 id="Step-2"><a class="docs-heading-anchor" href="#Step-2">Step 2</a><a id="Step-2-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2" title="Permalink"></a></h3><p>Compute values <span>$H^{0,m}_{n}(β)$</span> for <span>$m=0,\ldots,n$</span> and <span>$H^{0,m}_{n+1}(β)$</span> for <span>$m=0,\ldots,n+1$</span>.  Using Eq. (32), we see that within Gumerov and Duraiswami&#39;s conventions</p><p class="math-container">\[\begin{aligned}
  H^{0,m}_{n}(β) &amp;= (-1)^m \sqrt{\frac{(n-|m|)!}{(n+|m|)!}} P^{|m|}_{n}(\cos β) \\
                 &amp;= \frac{1}{\sqrt{k_m (2n+1)}} P̄_{n,|m|}(\cos β).
\end{aligned}\]</p><p>Here, <span>$k_0=1$</span> and <span>$k_m=2$</span> for <span>$m&gt;0$</span>, and <span>$P̄$</span> is defined as</p><p class="math-container">\[  P̄_{n,|m|} = \sqrt{\frac{k_m(2n+1)(n-m)!}{(n+m)!}} P_{n,|m|}.\]</p><p>Note that the factor of <span>$(-1)^m$</span> in the first equation above is different from the convention used here, and is related to the <a href="https://en.wikipedia.org/wiki/Spherical_harmonics#Condon%E2%80%93Shortley_phase">Condon-Shortley phase</a>. Note that Gumerov and Duraiswami use the notation <span>$P^{|m|}_{n}$</span>, whereas we are using the notation <span>$P_{n,|m|}$</span> — which usually differ by a factor of <span>$(-1)^m$</span>.</p><p>We use the &quot;fully normalized&quot; associated Legendre functions (fnALF) <span>$P̄$</span> because, as explained by <a href="https://doi.org/10.1007/s00190-019-01331-0">Xing et al. (2020)</a>, it is possible to compute these values very efficiently and accurately, while also delaying the onset of overflow and underflow.</p><p>The algorithm Xing et al. describe as the best for computing <span>$P̄$</span> is due to Belikov (1991), and is given by them as</p><p class="math-container">\[\begin{aligned}
  P̄_{0,0} &amp;= 1 \\
  P̄_{1,0} &amp;= \sqrt{3} \cos β \\
  P̄_{1,1} &amp;= \sqrt{3} \sin β \\
  P̄_{n,0} &amp;= a_n \cos β P̄_{n-1,0} - b_n \frac{\sin β}{2} P̄_{n-1,1} \\
  P̄_{n,m} &amp;=
    c_{n,m} \cos β P̄_{n-1,m}
    - \sin β \left[ d_{n,m} P̄_{n-1,m+1} - e_{n,m} P̄_{n-1,m-1} \right],
\end{aligned}\]</p><p>where the coefficients are given by</p><p class="math-container">\[\begin{aligned}
  a_n &amp;= \sqrt{\frac{2n+1}{2n-1}} \\
  b_n &amp;= \sqrt{\frac{2(n-1)(2n+1)}{n(2n-1)}} \\
  c_{n,m} &amp;= \frac{1}{n} \sqrt{\frac{(n+m)(n-m)(2n+1)}{2n-1}} \\
  d_{n,m} &amp;= \frac{1}{2n} \sqrt{\frac{(n-m)(n-m-1)(2n+1)}{2n-1}} \\
  e_{n,m} &amp;= \frac{1}{2n} \sqrt{\frac{2}{2-\delta_0^{m-1}}} \sqrt{\frac{(n+m)(n+m-1)(2n+1)}{2n-1}}.
\end{aligned}\]</p><p>Now, we can directly obtain a recurrence relation for <span>$H^{0,m}_{n} = P̄_{n,|m|} / \sqrt{k_m (2n+1)}$</span> from those expressions:</p><p class="math-container">\[\begin{aligned}
  H^{0,0}_{0} &amp;= 1 \\
  H^{0,0}_{1} &amp;= \cos β \\
  H^{0,1}_{1} &amp;= \sqrt{1/2} \sin β \\
  H^{0,0}_{n} &amp;= ā_n \cos β H^{0,0}_{n-1} - b̄_n \sin β H^{0,1}_{n-1} \\
  H^{0,m}_{n} &amp;=
    c̄_{n,m} \cos β H^{0,m}_{n-1}
    - \sin β \left[ d̄_{n,m} H^{0,m+1}_{n-1} - ē_{n,m} H^{0,m-1}_{n-1} \right],
\end{aligned}\]</p><p>where the coefficients are given by</p><p class="math-container">\[\begin{aligned}
  b̄_n &amp;= \sqrt{\frac{n-1}{n}} \\
  c̄_{n,m} &amp;= \frac{1}{n} \sqrt{(n+m)*(n-m)} \\
  d̄_{n,m} &amp;= \frac{1}{2n} \sqrt{(n-m)*(n-m-1)} \\
  ē_{n,m} &amp;= \frac{1}{2n} \sqrt{(n+m)*(n+m-1)}.
\end{aligned}\]</p><p>Note that the coefficients all simplified (in fact, <span>$a_n$</span> disappeared), without any increase in the complexity of the recurrence relations themselves.  Rewriting Belikov&#39;s algorithm explicitly in terms of the <span>$H^{0,m}_{n}$</span> also allows us to avoid an extra normalization step.</p><h3 id="Step-3"><a class="docs-heading-anchor" href="#Step-3">Step 3</a><a id="Step-3-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3" title="Permalink"></a></h3><p>Compute <span>$H^{1,m}_{n}(β)$</span> for <span>$m=1,\ldots,n$</span> using relation (41).  Symmetry and shift of the indices allow this relation to be written as</p><p class="math-container">\[b^{0}_{n+1} H^{1, m}_{n}
  = \frac{b^{−m−1}_{n+1} (1−\cos β)}{2} H^{0, m+1}_{n+1}
  − \frac{b^{ m−1}_{n+1} (1+\cos β)}{2} H^{0, m−1}_{n+1}
  − a^{m}_{n} \sin β H^{0, m}_{n+1}.\]</p><p>Here the constants are defined by</p><p class="math-container">\[a^{m}_{n} = \sqrt{\frac{(n+m+1)(n-m+1)} {(2n+1)(2n+3)}},\]</p><p class="math-container">\[b^{m}_{n} = \mathrm{sgn}(m) \sqrt{\frac{(n-m-1)(n-m)} {(2n-1)(2n+1)}}.\]</p><p>Note that all values are assumed to be zero whenever <span>$|m| &gt; n$</span>, we use <span>$\mathrm{sgn}(0)=1$</span> (unlike the common convention that <span>$\mathrm{sgn}(0)=0$</span>), and we have <span>$a^{m}_{n} = a^{-m}_{n}$</span>.  Also note that these coefficients <em>only</em> appear in this step, and because of how they appear (specifically, because <span>$b$</span> always appears with argument <span>$n+1$</span>), we can factor out the denominators in the definitions of the constants.  We obtain this simplified formula</p><p class="math-container">\[H^{1, m}_{n}
  = -\frac{1}{\sqrt{n(n+1)}} \left[
      \frac{\bar{b}^{−m−1}_{n+1} (1−\cos β)}{2} H^{0, m+1}_{n+1}
      + \frac{\bar{b}^{ m−1}_{n+1} (1+\cos β)}{2} H^{0, m−1}_{n+1}
      + \bar{a}^{m}_{n} \sin β H^{0, m}_{n+1}
    \right],\]</p><p>with</p><p class="math-container">\[\bar{a}^{m}_{n} = \sqrt{(n+m+1)(n-m+1)},\]</p><p class="math-container">\[\bar{b}^{m}_{n+1} = \sqrt{(n-m)(n-m+1)}.\]</p><h3 id="Step-4"><a class="docs-heading-anchor" href="#Step-4">Step 4</a><a id="Step-4-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4" title="Permalink"></a></h3><p>Recursively compute <span>$H^{m&#39;+1, m}_{n}(β)$</span> for <span>$m&#39;=1,\ldots,n−1$</span>, <span>$m=m&#39;,...,n$</span> using relation (50) resolved with respect to <span>$H^{m&#39;+1, m}_{n}$</span>:</p><p class="math-container">\[d^{m&#39;}_{n} H^{m&#39;+1, m}_{n}
  = d^{m&#39;−1}_{n} H^{m&#39;−1, m}_{n}
  − d^{m−1}_{n} H^{m&#39;, m−1}_{n}
  + d^{m}_{n} H^{m&#39;, m+1}_{n}\]</p><p>(where the last term drops out for <span>$m=n$</span>).  The constants are defined by</p><p class="math-container">\[d^{m}_{n} = \frac{\mathrm{sgn}(m)}{2} \sqrt{(n-m)(n+m+1)}.\]</p><p>Note that we can drop the factor of <span>$1/2$</span>, and <em>for this case only</em> the sign is always +1.</p><h3 id="Step-5"><a class="docs-heading-anchor" href="#Step-5">Step 5</a><a id="Step-5-1"></a><a class="docs-heading-anchor-permalink" href="#Step-5" title="Permalink"></a></h3><p>Recursively compute <span>$H^{m&#39;−1, m}_{n}(β)$</span> for <span>$m&#39;=0,\ldots,−n+1$</span>, <span>$m=−m&#39;,\ldots,n$</span> using relation (50) resolved with respect to <span>$H^{m&#39;−1, m}_{n}$</span>:</p><p class="math-container">\[d^{m&#39;−1}_{n} H^{m&#39;−1, m}_{n}
  = d^{m&#39;}_{n} H^{m&#39;+1, m}_{n}
  + d^{m−1}_{n} H^{m&#39;, m−1}_{n}
  − d^{m}_{n} H^{m&#39;, m+1}_{n}\]</p><p>(where the last term drops out for <span>$m=n$</span>).</p><p>NOTE: Although Gumerov and Duraiswami specify the loop over <span>$m&#39;$</span> to start at -1, I find it necessary to start at 0, or there will be missing information. This also requires setting the <span>$H^{0, -1}_{n}$</span> components (for all <span>$n$</span>) before beginning this loop.</p><h2 id="Pre-computing-constants-versus-computing-on-the-fly"><a class="docs-heading-anchor" href="#Pre-computing-constants-versus-computing-on-the-fly">Pre-computing constants versus computing on the fly</a><a id="Pre-computing-constants-versus-computing-on-the-fly-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-computing-constants-versus-computing-on-the-fly" title="Permalink"></a></h2><p>Each of the constants <span>$a^{m}_{n}$</span>, <span>$b^{m}_{n}$</span>, and <span>$c^{m}_{n}$</span> involves divisions and square-roots, which can be very costly to compute.  It can be advantageous to pre-compute the constants, and simply index the pre-computed arrays rather than re-computing them on each recursion.</p><p><em>If</em> we include the cost of computing all these constants in a single call to the <span>$H$</span> recurrence, it can be much cheaper to compute each constant as needed within the algorithm, rather than computing them all at once at the beginning of the algorithm — but only for very small computations, such as those involving <span>$n_{\mathrm{max}} ≈ 10$</span>.  Beyond this, despite the storage penalties for all those constants, it turns out to be better to pre-compute them.  However, it should be noted that the fractional cost of storing the constants is <span>$\sim 3/n_{\mathrm{max}}$</span> compared to just storing <span>$H$</span> itself, so this will never be a very significant amount of space.</p><p>On the other hand, if we can pre-compute the constants just once, and store them between multiple calls to the <span>$H$</span> recurrence, then it is always advantageous to do so — typically by factors of 2 or 3 in speed.  The only difficulty here is ensuring that each call to the recurrence has access to the constants, which can be a little awkward when using multiple processes and/or threads.  However, it should be thread safe, since we only need to read those constants within the <span>$H$</span> recurrence.  All in all, I conclude that it is probably not worth the effort to maintain separate versions of the recurrence for pre-computed and on-the-fly constants.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../utilities/">« Utilities</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 5 October 2022 18:12">Wednesday 5 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
